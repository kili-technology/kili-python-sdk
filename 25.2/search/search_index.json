{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting started with the Kili Python SDK","text":""},{"location":"#what-is-kili","title":"What is Kili?","text":"<p>Kili is a platform that empowers a data-centric approach to Machine Learning through quality training data creation. It provides collaborative data annotation tools and APIs that enable quick iterations between reliable dataset building and model training. More info about the product here.</p> <p>If you are looking for the Kili product documentation, it is located here.</p>"},{"location":"#the-kili-python-sdk","title":"The Kili Python SDK","text":"<p>Kili Python SDK has been designed to perform complex project-related tasks by using the Python programming language. Using Kili Python SDK, you can write scripts for repetitive tasks and then integrate them in one machine learning or data science workflow. For people who are familiar with Python, it may be perfect middle ground between complex GraphQL queries and simple, but less flexible CLI one-liners.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>You only need Python 3.9 or higher.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the Kili client with pip:</p> <pre><code>pip install kili\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<ul> <li>Create and copy a Kili API key</li> <li>Add the <code>KILI_API_KEY</code> variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier:</li> </ul> <pre><code>export KILI_API_KEY='&lt;you api key value here&gt;'\n</code></pre> <ul> <li>Instantiate the Kili client:</li> </ul> <pre><code>from kili.client import Kili\nkili = Kili()\n</code></pre> <p>Info</p> <p>You can also pass the API key as an argument during <code>Kili</code> initialization:</p> <pre><code>kili = Kili(api_key='&lt;you api key value here&gt;')\n</code></pre> <p>Great!</p> <p>You can now begin to use the Kili Python SDK! \ud83c\udf89</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Welcome to the Kili Tutorials Homepage!</p> <p>We understand that getting started with a new product can sometimes be challenging. That's why we have created this page to provide you with easy-to-follow tutorials that will help you understand how to use the Kili Python SDK in no time.</p> <p>Here is a brief overview of our tutorials:</p>"},{"location":"tutorials/#basic-project-setup","title":"Basic project setup","text":"<p>In this tutorial you will learn how to set up a new project in Kili, configure its settings, and add assets and users to it.</p>"},{"location":"tutorials/#importing-assets","title":"Importing assets","text":"<p>This tutorial will show you how to import assets into your Kili project and add asset metadata.</p> <p>Because videos and Rich Text assets may be more complex to import, we\u2019ve created separate tutorials devoted to them:</p> <ul> <li>For video assets, refer to this tutorial.</li> <li>For rich text assets, see here.</li> <li>For PDF assets, see here.</li> <li>For Geospatial multi-layer assets, see here.</li> <li>For LLM Static, see here.</li> </ul>"},{"location":"tutorials/#importing-labels","title":"Importing labels","text":"<p>In this tutorial you will learn how to import different types of label formats supported by Kili, including model-based pre-annotations and pre-existing labels from other projects.</p> <p>This tutorial explains how to use a powerful OpenAI Large Language Model (LLM) to generate pre-annotations, which will then be imported into a Named Entity Recognition (NER) Kili project.</p> <p>For other specific use cases, see these tutorials:</p> <ul> <li>Importing OCR pre-annotations</li> <li>Importing segmentation pre-annotations</li> <li>Importing DINOv2 classification pre-annotations</li> <li>Importing labels from shapefiles</li> <li>Importing labels from GeoJSON</li> </ul> <p>Additionally, we\u2019ve devoted one tutorial to explaining the most common use cases for importing and using model-generated labels: actively monitoring the quality of a model currently deployed to production to detect issues like data drift, and using a model to speed up the process of label creation.</p>"},{"location":"tutorials/#working-with-labels","title":"Working with labels","text":"<p>In this section, you\u2019ll learn the various ways you can process labels with Kili.</p> <p>This tutorial shows you how to upload medical images to Kili using pydicom, upload dicom tags as metadata to your assets, download segmentation labels from Kili, and finally convert them to Numpy masks for visualization with matplotlib.</p> <p>The Tagtog to Kili tutorial will show you how to convert and import your tagtog assets and labels into Kili.</p> <p>The label parsing tutorial will show you how you can read and write label data more efficiently.</p> <p>This tutorial shows how to import COCO annotations into Kili.</p> <p>This tutorial shows how to import PascalVOC annotations into Kili.</p>"},{"location":"tutorials/#managing-workflows","title":"Managing workflows","text":"<p>In this tutorial you will learn how to manage your review queue, set up quality assurance measures, assign specific labelers to assets, and prioritize assets to be annotated.</p>"},{"location":"tutorials/#exporting-project-data","title":"Exporting Project Data","text":"<p>This tutorial will show you how to export your project\u2019s assets and labels to different formats supported by Kili.</p>"},{"location":"tutorials/#plugins","title":"Plugins","text":"<p>A plugin is a custom Python script uploaded to Kili and triggered by an event that you define. For instance, you can trigger a specific action when a labeler clicks on Submit.</p> <p>In this tutorial you will learn how to create your own custom plugins.</p> <p>Here, you\u2019ll find example use cases for using Kili plugins.</p> <p>For a more specific use case, follow this tutorial on how to set up and use Kili plugins to monitor the quality of labels added to your project in real-time, without having to involve human reviewers.</p> <p>Webhooks are really similar to plugins, except they are self-hosted, and require a web service deployed at your end, callable by Kili. To learn how to use webhooks, follow this tutorial.</p>"},{"location":"tutorials/#llm-dynamic-project","title":"LLM Dynamic Project","text":"<p>This tutorial guides you through setting up a Kili project with an integrated LLM. You'll learn how to create and link the LLM model to the project and initiate a conversation using the Kili SDK.</p>"},{"location":"tutorials/#integrations","title":"Integrations","text":"<p>This tutorial will show you how train an object detection model with Vertex AI AutoML and Kili for faster annotation</p>"},{"location":"tutorials/#more","title":"More","text":"<p>For more tutorials and recipes, see our Github repository.</p>"},{"location":"cli/","title":"Getting started with the Kili CLI","text":""},{"location":"cli/#what-is-kili-cli","title":"What is Kili CLI","text":"<p>Kili CLI has been designed to run key actions on your projects with powerful commands. For the actions it supports, the CLI offers a more compact way to manage your projects than the Python SDK. Note that the Python SDK offers more options and may still be used for more complex project management tasks.</p>"},{"location":"cli/#authentication","title":"Authentication","text":"<ul> <li>Create and copy a Kili API key</li> <li>Add the <code>KILI_API_KEY</code> variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier:</li> </ul> <pre><code>export KILI_API_KEY='&lt;you api key value here&gt;'\n</code></pre> <p>Info</p> <p>While launching commands, you can also provide you API key through the <code>--api-key</code> option. If you set your api key in the <code>KILI_API_KEY</code> environment variable and provide it once again through the <code>--api-key</code> option, Kili CLI will use the api key value provided in command options.</p>"},{"location":"cli/#usage","title":"Usage","text":"<p>The main command is <code>kili</code>. It currently has only one subcommand <code>project</code> that entails all the commands for project management :</p> <pre><code>kili project [COMMAND]\n</code></pre>"},{"location":"cli/#workflow-example","title":"Workflow example","text":"<p>Let's take an example where you want to start a project from scratch  You can download ressources to run this example here. Once in the current directory where all files are stored, you can run the following commands:</p>"},{"location":"cli/#create-a-project","title":"Create a project","text":"<p>To create an IMAGE project:</p> <pre><code>kili project create \\\n            json_interface.json \\\n            --title \"Quality inspection\" \\\n            --input-type IMAGE \\\n            --description \"Steel defects on production line\"\n</code></pre> <p>Ouput:</p> <pre><code>ID                         URL\n&lt;project_id&gt;               https://cloud.kili-technology.com/label/projects/&lt;project_id&gt;/\n</code></pre>"},{"location":"cli/#list-your-projects","title":"List your projects","text":"<pre><code>kili project list --max 10\n</code></pre> <p>Ouput:</p> <pre><code>TITLE                                ID                      PROGRESS  DESCRIPTION\nQuality inspection                   &lt;project_id&gt;                0.0%  Steel defects on production line...\n</code></pre>"},{"location":"cli/#recover-your-project-id","title":"Recover your project ID","text":"<pre><code>export project_id=$(kili project list \\\n              | grep -m1 \"Quality inspection\" \\\n              | awk '{print $3}')\n</code></pre>"},{"location":"cli/#add-a-member-to-your-project","title":"Add a member to your project","text":"<pre><code>kili project member add \\\n                &lt;email_adress&gt; \\\n                --project-id $project_id \\\n                --role REVIEWER\n</code></pre> <p>Ouput:</p> <pre><code>1 member(s) have been successfully added to project: &lt;project_id&gt;\n</code></pre>"},{"location":"cli/#list-the-projects-members","title":"List the project's members","text":"<pre><code>kili project member list --project-id $project_id\n</code></pre> <p>Ouput:</p> <pre><code>ROLE      NAME            EMAIL                ID                         ORGANIZATION\nADMIN     &lt;your_name&gt;     &lt;your_email&gt;         &lt;your_member_id&gt;           &lt;your_organization&gt;\nREVIEWER  &lt;reviewer_name&gt; &lt;email_adress&gt;       &lt;member_id&gt;                &lt;your_organization&gt;\n</code></pre>"},{"location":"cli/#import-data-to-your-project","title":"Import data to your project","text":"<p>To import data, provide a list of files or folders (you can also procide a csv file external_id and file's paths)</p> <pre><code>kili project import \\\n    assets \\\n    --project-id $project_id\n</code></pre> <p>Ouput:</p> <pre><code>40 files have been successfully imported\n</code></pre>"},{"location":"cli/#import-labels-to-your-project","title":"Import labels to your project","text":"<p>To import labels, provide a list of files or folders.</p> <p>You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example).  File's name must be equal to asset's external_id. In the demo folder, the labels are in a folder called ground_truths</p> <pre><code>kili project label \\\n    ground_truths \\\n    --project-id $project_id\n</code></pre> <p>Outputs:</p> <pre><code>40 labels have been successfully imported\n</code></pre> <p>If you have run a pre-annotation model, you can also import labels as predictions. These labels will be seen as pre-annotation in the labeling interface.</p> <pre><code>kili project label \\\n    ground_truths \\\n    --project-id $project_id \\\n    --prediction \\\n    --model-name YOLO-run-3\n</code></pre> <p>Outputs:</p> <pre><code>40 labels have been successfully imported\n</code></pre>"},{"location":"cli/#get-metrics-of-your-project","title":"Get metrics of your project","text":"<pre><code>kili project describe $project_id\n</code></pre> <p>Ouput:</p> <pre><code>Title        Quality inspection\nDescription  Steel defects on production line\n\nDataset KPIs\n------------\nTotal number of assets      40\nNumber of remaining assets  10\nSkipped assets              0\nProgress                    25.0%\n\nQuality KPIs\n------------\nProject consensus           N/A\nProject honeypot            N/A\nNumber of reviewed assets   0\nNumber of open issues       0\nNumber of solved issues     0\nNumber of open questions    0\nNumber of solved questions  0\n</code></pre>"},{"location":"cli/reference/","title":"kili","text":"<p>Kili Command line Interface.</p> <p>To get all the available commands, please type: <code>kili project --help</code>.</p> <p>Usage:</p> <pre><code>kili [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--version</code> boolean Show the version and exit. <code>False</code> <code>-h</code>, <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#project","title":"project","text":"<p>Commands to interact with a Kili project.</p> <p>Usage:</p> <pre><code>kili project [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>-h</code>, <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#copy","title":"copy","text":"<p>Copy an existing Kili project.</p> <p>The copy can include or not the json interface, quality settings, members, assets and labels of the source project.</p> <p>By default, only the json interface, quality settings and project members are copied.</p> <p>By default, this method is not configured with a retry mechanism and its timeout is extended to 10 minutes.</p> <p>If no <code>title</code> is provided, the source project title will be used. If no description is provided, the description will be set to an empty string.</p> <p>Returns the new project id and title once the copy is finished.</p> <p>\\b</p> <p>Examples</p> <p>Copy a project and set a new title and new description: <pre><code>kili project copy clbqn56b331234567890l41c0 \\\\\n    --title \"New project title\" \\\\\n    --description \"New project description\"\n</code></pre> Copy the json interface but not the members: <pre><code>kili project copy clbqn56b331234567890l41c0 \\\\\n    --with-json-interface \\\\\n    --without-members\n</code></pre></p> <p>Usage:</p> <pre><code>kili project copy [OPTIONS] FROM_PROJECT_ID\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--title</code> text New project title. None <code>--description</code> text New project description. None <code>--with-json-interface</code> / <code>--without-json-interface</code> boolean Copy json interface. <code>True</code> <code>--with-quality-settings</code> / <code>--without-quality-settings</code> boolean Copy quality settings. <code>True</code> <code>--with-members</code> / <code>--without-members</code> boolean Copy members. <code>True</code> <code>--with-assets</code> / <code>--without-assets</code> boolean Copy assets. <code>False</code> <code>--with-labels</code> / <code>--without-labels</code> boolean Copy labels. <code>False</code> <code>-h</code>, <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#create","title":"create","text":"<p>Create a Kili project.</p> <p>interface must be a path pointing to your json interface file</p> <p>If no interface is provided, --from-project can be used to create a new project with the json_interface of another project (assets will not be copied).</p> <p>\\b</p> <p>Examples</p> <p><pre><code>kili project create \\\\\n     path/to/interface.json \\\\\n    --input-type TEXT \\\\\n    --title \"Invoice annotation project\"\n</code></pre> <pre><code>kili project create \\\\\n    --from-project &lt;project_id_src&gt; \\\\\n    --input-type TEXT \\\\\n    --title \"Invoice annotation project\"\n</code></pre></p> <p>To build a Kili project interface, please visit: \\n https://docs.kili-technology.com/docs/customizing-the-interface-through-json-settings</p> <p>Usage:</p> <pre><code>kili project create [OPTIONS] [INTERFACE]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--from-project</code> text project_id of another Kili project None <code>--title</code> text Project Title. _required <code>--input-type</code> choice (<code>IMAGE</code> | <code>PDF</code> | <code>TEXT</code> | <code>VIDEO</code> | <code>LLM_RLHF</code> | <code>LLM_INSTR_FOLLOWING</code> | <code>LLM_STATIC</code>) Project input data type. Please check your license to see which ones you have access to. _required <code>--description</code> text Project description. `` <code>--stdout-format</code> text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). <code>plain</code> <code>-h</code>, <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#describe","title":"describe","text":"<p>Show project description and analytics.</p> <p>\\b</p> <p>Examples</p> <pre><code>kili project describe --project-id &lt;project_id&gt;\n</code></pre> <p>Usage:</p> <pre><code>kili project describe [OPTIONS] PROJECT_ID\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>-h</code>, <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#export","title":"export","text":"<p>Export the Kili labels of a project to a given format.</p> <p>Info</p> <p>The supported formats are:</p> <ul> <li>Yolo V4, V5, V7, V8 for object detection tasks.</li> <li>Kili (a.k.a raw) for all tasks.</li> <li>COCO for object detection tasks (bounding box and semantic segmentation).</li> <li>Pascal VOC for object detection tasks (bounding box).</li> </ul> <p>Cloud storage</p> <p>Export with asset download (<code>--with-assets</code>) is not allowed for projects connected to a cloud storage.</p> <p>Examples</p> <p><pre><code>kili project export \\\n    --project-id &lt;project_id&gt; \\\n    --output-format coco \\\n    --output-file /tmp/export.zip\n</code></pre> <pre><code>kili project export \\\n    --project-id &lt;project_id&gt; \\\n    --output-format yolo_v5 \\\n    --output-file /tmp/export_split.zip \\\n    --layout split\n</code></pre></p> <p>Usage:</p> <pre><code>kili project export [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--output-format</code> choice (<code>raw</code> | <code>kili</code> | <code>yolo_v4</code> | <code>yolo_v5</code> | <code>yolo_v7</code> | <code>yolo_v8</code> | <code>coco</code> | <code>pascal_voc</code> | <code>geojson</code>) Format into which the label data will be converted _required <code>--output-file</code> text File into which the labels are saved. _required <code>--layout</code> choice (<code>split</code> | <code>merged</code>) Layout of the label files: 'split' to group labels per job, 'merged' to have one folder with every labels. <code>merged</code> <code>--single-file</code> boolean Layout of the label files. Single file mode is only available for some specific formats (COCO and Kili). <code>False</code> <code>--with-assets</code> / <code>--without-assets</code> boolean Download assets in the export. <code>True</code> <code>--normalized-coordinates</code> / <code>--pixel-coordinates</code> boolean Whether to use normalized coordinates or not. None <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--verbose</code> boolean Show more logs <code>False</code> <code>-h</code>, <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#import","title":"import","text":"<p>Add assets into a project.</p> <p>Files can be paths to files or to folders. You can provide several paths separated by spaces.</p> <p>If no Files are provided, --from-csv can be used to import assets from a CSV file with two columns:</p> <ul> <li><code>external_id</code>: external id of the asset.</li> <li><code>content</code>: paths to the asset file or a url hosting the asset.</li> </ul> <p>\\b</p> <p>Examples</p> <p><pre><code>kili project import \\\\\n    dir1/dir2/ dir1/dir3/test1.png \\\\\n    --project-id &lt;project_id&gt;\n</code></pre> <pre><code>kili project import \\\\\n    dir1/dir3/video.mp4 \\\\\n    --project-id &lt;project_id&gt; \\\\\n    --frames \\\\\n    --fps 24\n</code></pre> <pre><code>kili project import \\\\\n    --from-csv assets_list.csv \\\\\n    --project-id &lt;project_id&gt; \\\\\n    --frames \\\\\n    --fps 24\n</code></pre></p> <p>\\b</p> <p>Unsupported imports</p> <p>Currently, this command does not support:</p> <ul> <li>the import of videos from local frames, rich text and time series assets</li> <li>the import of assets with metadata or with a custom external_id</li> </ul> <p>For such imports, please use the <code>append_many_to_dataset</code> method in the Kili SDK.</p> <p>Usage:</p> <pre><code>kili project import [OPTIONS] [FILES]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--from-csv</code> path path to a csv file with required columns:external_id, content required columns: None <code>--frames</code> boolean Only for a frame project, import videos as frames. The import time is longer with this option. <code>False</code> <code>--fps</code> integer Only for a frame project, import videos with a specific frame rate None <code>--verbose</code> boolean Show more logs <code>False</code> <code>-h</code>, <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#label","title":"label","text":"<p>Import labels or predictions.</p> <p>Files can be paths to files or to folders.  You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example). File's name must be equal to asset's external_id.</p> <p>\\b</p> <p>Examples</p> <p>To import default labels: <pre><code>kili project label \\\\\n    dir/labels/ dir/ground-truth/image1.json \\\\\n    --project-id &lt;project_id&gt;\n</code></pre> To import labels as predictions: <pre><code>kili project label \\\\\n    dir/predictions/ \\\\\n    --project-id &lt;project_id&gt; \\\\\n    --prediction \\\\\n    --model-name YOLO-run-3\n</code></pre> To import labels as predictions in the Yolo v5 format into a target job: <pre><code>kili project label \\\\\n    dir/predictions/ \\\\\n    --project-id &lt;project_id&gt; \\\\\n    --prediction \\\\\n    --model-name YOLO-v5 \\\\\n    --metadata-file classes.yml \\\\\n    --target-job IMAGE_DETECTION_JOB \\\\\n    --input-format yolo_v5\n    --overwrite True\n</code></pre></p> <p>Usage:</p> <pre><code>kili project label [OPTIONS] [FILES]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--prediction</code> boolean Tells to import labels as predictions, which means that they will appear as pre-annotations in the Kili interface <code>False</code> <code>--model-name</code> text Name of the model that generated predictions, if labels are sent as predictions None <code>--verbose</code> boolean Show more logs <code>False</code> <code>--input-format</code> choice (<code>yolo_v4</code> | <code>yolo_v5</code> | <code>yolo_v7</code> | <code>kili</code> | <code>raw</code>) Format in which the labels are encoded <code>kili</code> <code>--metadata-file</code> text File containing format metadata (if relevant to the input format) None <code>--target-job</code> text Job name in the project where to upload the labels (if relevant to the input format) None <code>--overwrite</code> boolean when uploading prediction or inference labels, if the <code>overwrite</code> flag is activated, it will overwrite existing labels with the same model name and of the same label type, on the targeted assets. <code>False</code> <code>-h</code>, <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#list","title":"list","text":"<p>List your projects.</p> <p>\\b</p> <p>Examples</p> <pre><code>kili project list --max 10 --stdout-format pretty\n</code></pre> <p>Usage:</p> <pre><code>kili project list [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--stdout-format</code> text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). <code>plain</code> <code>--max</code> integer Maximum number of project to display. <code>100</code> <code>-h</code>, <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#member","title":"member","text":"<p>Commands to interact with Kili project members.</p> <p>Usage:</p> <pre><code>kili project member [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>-h</code>, <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#add","title":"add","text":"<p>Add members to a Kili project.</p> <p>Emails can be passed directly as arguments. You can provide several emails separated by spaces.</p> <p>Examples</p> <p><pre><code>kili project member add \\\n    --project-id &lt;project_id&gt; \\\n    --role REVIEWER \\\n    john.doe@test.com jane.doe@test.com\n</code></pre> <pre><code>kili project member add \\\n    --project-id &lt;project_id&gt; \\\n    --from-csv path/to/members.csv\n</code></pre> <pre><code>kili project member add \\\n    --project-id &lt;project_id&gt; \\\n    --from-project &lt;project_id_scr&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>kili project member add [OPTIONS] [EMAILS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--role</code> choice (<code>ADMIN</code> | <code>TEAM_MANAGER</code> | <code>REVIEWER</code> | <code>LABELER</code>) Project role of the added user(s). None <code>--from-csv</code> path path to a csv file with required columns:email required columns: role None <code>--from-project</code> text project_id of another Kili project None <code>-h</code>, <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#list_1","title":"list","text":"<p>List the members of the project.</p> <p>Examples</p> <pre><code>kili project member list &lt;project_id&gt; --stdout-format pretty\n</code></pre> <p>Usage:</p> <pre><code>kili project member list [OPTIONS] PROJECT_ID\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--stdout-format</code> text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). <code>plain</code> <code>-h</code>, <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#rm","title":"rm","text":"<p>Remove members from a Kili project.</p> <p>Emails can be passed directly as arguments. You can provide several emails separated by spaces.</p> <p>Examples</p> <p><pre><code>kili project member rm \\\n    --project-id &lt;project_id&gt; \\\n    john.doe@test.com\n</code></pre> <pre><code>kili project member rm \\\n    --project-id &lt;project_id&gt; \\\n    --from-csv path/to/members.csv\n</code></pre> <pre><code>kili project member rm \\\n    --project-id &lt;project_id&gt; \\\n    --all\n</code></pre></p> <p>Usage:</p> <pre><code>kili project member rm [OPTIONS] [EMAILS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--from-csv</code> path path to a csv file with required columns:email required columns: role None <code>--all</code> boolean Remove all users from project <code>False</code> <code>-h</code>, <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#update","title":"update","text":"<p>Update member's role of a Kili project.</p> <p>Emails can be passed directly as arguments. You can provide several emails separated by spaces.</p> <p>Examples</p> <p><pre><code>kili project member update\\\n    --project-id &lt;project_id&gt; \\\n    --role REVIEWER \\\n    john.doe@test.com\n</code></pre> <pre><code>kili project member update \\\n    --project-id &lt;project_id&gt; \\\n    --from-csv path/to/members.csv\n</code></pre> <pre><code>kili project member update \\\n    --project-id &lt;project_id&gt; \\\n    --from-project &lt;project_id_scr&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>kili project member update [OPTIONS] [EMAILS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--role</code> choice (<code>ADMIN</code> | <code>TEAM_MANAGER</code> | <code>REVIEWER</code> | <code>LABELER</code>) Project role of the added user(s). None <code>--from-csv</code> path path to a csv file with required columns:email required columns: role None <code>--from-project</code> text project_id of another Kili project None <code>-h</code>, <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"sdk/asset/","title":"Asset module","text":"<p>Methods attached to the Kili client, to run actions on assets.</p> Source code in <code>kili/presentation/client/asset.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass AssetClientMethods(BaseClientMethods):\n    \"\"\"Methods attached to the Kili client, to run actions on assets.\"\"\"\n\n    # pylint: disable=too-many-arguments, redefined-builtin, too-many-locals\n    @overload\n    def assets(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        skip: int = 0,\n        fields: Optional[ListOrTuple[str]] = None,\n        asset_id_in: Optional[List[str]] = None,\n        asset_id_not_in: Optional[List[str]] = None,\n        consensus_mark_gt: Optional[float] = None,\n        consensus_mark_lt: Optional[float] = None,\n        disable_tqdm: Optional[bool] = None,\n        external_id_contains: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        format: Optional[str] = None,\n        honeypot_mark_gt: Optional[float] = None,\n        honeypot_mark_lt: Optional[float] = None,\n        label_author_in: Optional[List[str]] = None,\n        label_consensus_mark_gt: Optional[float] = None,\n        label_consensus_mark_lt: Optional[float] = None,\n        label_created_at: Optional[str] = None,\n        label_created_at_gt: Optional[str] = None,\n        label_created_at_lt: Optional[str] = None,\n        label_honeypot_mark_gt: Optional[float] = None,\n        label_honeypot_mark_lt: Optional[float] = None,\n        label_type_in: Optional[List[LabelType]] = None,\n        metadata_where: Optional[dict] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        label_category_search: Optional[str] = None,\n        download_media: bool = False,\n        local_media_dir: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        consensus_mark_gte: Optional[float] = None,\n        consensus_mark_lte: Optional[float] = None,\n        inference_mark_gte: Optional[float] = None,\n        inference_mark_lte: Optional[float] = None,\n        label_labeler_in: Optional[ListOrTuple[str]] = None,\n        label_labeler_not_in: Optional[ListOrTuple[str]] = None,\n        label_reviewer_in: Optional[ListOrTuple[str]] = None,\n        label_reviewer_not_in: Optional[ListOrTuple[str]] = None,\n        assignee_in: Optional[ListOrTuple[str]] = None,\n        assignee_not_in: Optional[ListOrTuple[str]] = None,\n        label_consensus_mark_gte: Optional[float] = None,\n        label_consensus_mark_lte: Optional[float] = None,\n        label_created_at_gte: Optional[str] = None,\n        label_created_at_lte: Optional[str] = None,\n        label_honeypot_mark_gte: Optional[float] = None,\n        label_honeypot_mark_lte: Optional[float] = None,\n        issue_type: Optional[IssueType] = None,\n        issue_status: Optional[IssueStatus] = None,\n        external_id_strictly_in: Optional[List[str]] = None,\n        external_id_in: Optional[List[str]] = None,\n        label_output_format: Literal[\"dict\", \"parsed_label\"] = \"dict\",\n        skipped: Optional[bool] = None,\n        status_in: Optional[List[AssetStatus]] = None,\n        step_name_in: Optional[List[str]] = None,\n        step_status_in: Optional[List[StatusInStep]] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def assets(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        skip: int = 0,\n        fields: Optional[ListOrTuple[str]] = None,\n        asset_id_in: Optional[List[str]] = None,\n        asset_id_not_in: Optional[List[str]] = None,\n        consensus_mark_gt: Optional[float] = None,\n        consensus_mark_lt: Optional[float] = None,\n        disable_tqdm: Optional[bool] = None,\n        external_id_contains: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        format: Optional[str] = None,\n        honeypot_mark_gt: Optional[float] = None,\n        honeypot_mark_lt: Optional[float] = None,\n        label_author_in: Optional[List[str]] = None,\n        label_consensus_mark_gt: Optional[float] = None,\n        label_consensus_mark_lt: Optional[float] = None,\n        label_created_at: Optional[str] = None,\n        label_created_at_gt: Optional[str] = None,\n        label_created_at_lt: Optional[str] = None,\n        label_honeypot_mark_gt: Optional[float] = None,\n        label_honeypot_mark_lt: Optional[float] = None,\n        label_type_in: Optional[List[LabelType]] = None,\n        metadata_where: Optional[dict] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        label_category_search: Optional[str] = None,\n        download_media: bool = False,\n        local_media_dir: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        consensus_mark_gte: Optional[float] = None,\n        consensus_mark_lte: Optional[float] = None,\n        inference_mark_gte: Optional[float] = None,\n        inference_mark_lte: Optional[float] = None,\n        label_labeler_in: Optional[ListOrTuple[str]] = None,\n        label_labeler_not_in: Optional[ListOrTuple[str]] = None,\n        label_reviewer_in: Optional[ListOrTuple[str]] = None,\n        label_reviewer_not_in: Optional[ListOrTuple[str]] = None,\n        assignee_in: Optional[ListOrTuple[str]] = None,\n        assignee_not_in: Optional[ListOrTuple[str]] = None,\n        label_consensus_mark_gte: Optional[float] = None,\n        label_consensus_mark_lte: Optional[float] = None,\n        label_created_at_gte: Optional[str] = None,\n        label_created_at_lte: Optional[str] = None,\n        label_honeypot_mark_gte: Optional[float] = None,\n        label_honeypot_mark_lte: Optional[float] = None,\n        issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n        issue_status: Optional[IssueStatus] = None,\n        external_id_strictly_in: Optional[List[str]] = None,\n        external_id_in: Optional[List[str]] = None,\n        label_output_format: Literal[\"dict\", \"parsed_label\"] = \"dict\",\n        skipped: Optional[bool] = None,\n        status_in: Optional[List[AssetStatus]] = None,\n        step_name_in: Optional[List[str]] = None,\n        step_status_in: Optional[List[StatusInStep]] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def assets(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        skip: int = 0,\n        fields: Optional[ListOrTuple[str]] = None,\n        asset_id_in: Optional[List[str]] = None,\n        asset_id_not_in: Optional[List[str]] = None,\n        consensus_mark_gt: Optional[float] = None,\n        consensus_mark_lt: Optional[float] = None,\n        disable_tqdm: Optional[bool] = None,\n        external_id_contains: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        format: Optional[str] = None,\n        honeypot_mark_gt: Optional[float] = None,\n        honeypot_mark_lt: Optional[float] = None,\n        label_author_in: Optional[List[str]] = None,\n        label_consensus_mark_gt: Optional[float] = None,\n        label_consensus_mark_lt: Optional[float] = None,\n        label_created_at: Optional[str] = None,\n        label_created_at_gt: Optional[str] = None,\n        label_created_at_lt: Optional[str] = None,\n        label_honeypot_mark_gt: Optional[float] = None,\n        label_honeypot_mark_lt: Optional[float] = None,\n        label_type_in: Optional[List[LabelType]] = None,\n        metadata_where: Optional[dict] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        label_category_search: Optional[str] = None,\n        download_media: bool = False,\n        local_media_dir: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        consensus_mark_gte: Optional[float] = None,\n        consensus_mark_lte: Optional[float] = None,\n        inference_mark_gte: Optional[float] = None,\n        inference_mark_lte: Optional[float] = None,\n        label_labeler_in: Optional[ListOrTuple[str]] = None,\n        label_labeler_not_in: Optional[ListOrTuple[str]] = None,\n        label_reviewer_in: Optional[ListOrTuple[str]] = None,\n        label_reviewer_not_in: Optional[ListOrTuple[str]] = None,\n        assignee_in: Optional[ListOrTuple[str]] = None,\n        assignee_not_in: Optional[ListOrTuple[str]] = None,\n        label_consensus_mark_gte: Optional[float] = None,\n        label_consensus_mark_lte: Optional[float] = None,\n        label_created_at_gte: Optional[str] = None,\n        label_created_at_lte: Optional[str] = None,\n        label_honeypot_mark_gte: Optional[float] = None,\n        label_honeypot_mark_lte: Optional[float] = None,\n        issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n        issue_status: Optional[Literal[\"CANCELLED\", \"OPEN\", \"SOLVED\"]] = None,\n        external_id_strictly_in: Optional[List[str]] = None,\n        external_id_in: Optional[List[str]] = None,\n        label_output_format: Literal[\"dict\", \"parsed_label\"] = \"dict\",\n        skipped: Optional[bool] = None,\n        status_in: Optional[List[AssetStatus]] = None,\n        step_name_in: Optional[List[str]] = None,\n        step_status_in: Optional[List[StatusInStep]] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Union[Iterable[Dict], \"pd.DataFrame\"]:\n        # pylint: disable=line-too-long\n        \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints.\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset to retrieve.\n            asset_id_in: A list of the IDs of the assets to retrieve.\n            asset_id_not_in: A list of the IDs of the assets to exclude.\n            skip: Number of assets to skip (they are ordered by their date of creation, first to last).\n            fields: All the fields to request among the possible fields for the assets.\n                    See [the documentation](https://api-docs.kili-technology.com/types/objects/asset) for all possible fields.\n            first: Maximum number of assets to return.\n            consensus_mark_gt: Deprecated. Use `consensus_mark_gte` instead.\n            consensus_mark_lt: Deprecated. Use `consensus_mark_lte` instead.\n            external_id_contains: Deprecated. Use `external_id_strictly_in` instead.\n            metadata_where: Filters by the values of the metadata of the asset.\n            honeypot_mark_gt: Deprecated. Use `honeypot_mark_gte` instead.\n            honeypot_mark_lt: Deprecated. Use `honeypot_mark_lte` instead.\n            label_type_in: Returned assets should have a label whose type belongs to that list, if given.\n            label_author_in: Returned assets should have a label whose author belongs to that list, if given. An author can be designated by the first name, the last name, or the first name + last name.\n            label_consensus_mark_gt: Deprecated. Use `label_consensus_mark_gte` instead.\n            label_consensus_mark_lt: Deprecated. Use `label_consensus_mark_lte` instead.\n            label_created_at: Returned assets should have a label whose creation date is equal to this date.\n            label_created_at_gt: Deprecated. Use `label_created_at_gte` instead.\n            label_created_at_lt: Deprecated. Use `label_created_at_lte` instead.\n            label_honeypot_mark_gt: Deprecated. Use `label_honeypot_mark_gte` instead.\n            label_honeypot_mark_lt: Deprecated. Use `label_honeypot_mark_lte` instead.\n            updated_at_gte: Returned assets should have an update date that is greater or equal to this date. The update date represents the last time a modification has been done at the asset level.\n            updated_at_lte: Returned assets should have an update date that is lower or equal to this date. The update date represents the last time a modification has been done at the asset level.\n            format: If equal to 'pandas', returns a pandas DataFrame\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the assets is returned.\n            label_category_search: Returned assets should have a label that follows this category search query.\n            download_media: Tell is the media have to be downloaded or not.\n            local_media_dir: Directory where the media are downloaded if `download_media` is True.\n            created_at_gte: Returned assets should have their import date greater or equal to this date.\n            created_at_lte: Returned assets should have their import date lower or equal to this date.\n            honeypot_mark_lte: Maximum amount of honeypot for the asset.\n            honeypot_mark_gte: Minimum amount of honeypot for the asset.\n            consensus_mark_lte: Maximum amount of consensus for the asset.\n            consensus_mark_gte: Minimum amount of consensus for the asset.\n            inference_mark_gte: Minimum amount of human/model IoU for the asset.\n            inference_mark_lte: Maximum amount of human/model IoU for the asset.\n            label_labeler_in: Returned assets should have a label whose labeler belongs to that list, if given.\n            label_labeler_not_in: Returned assets should have a label whose labeler does not belong to that list, if given.\n            label_reviewer_in: Returned assets should have a label whose reviewer belongs to that list, if given.\n            label_reviewer_not_in: Returned assets should have a label whose reviewer does not belong to that list, if given.\n            assignee_in: Returned assets should have an assigned user that belongs to that list, if given.\n            assignee_not_in: Returned assets should have an assigned user that does not belong to that list, if given.\n            label_consensus_mark_gte: Returned assets should have a label whose consensus is greater or equal to this number.\n            label_consensus_mark_lte: Returned assets should have a label whose consensus is lower or equal to this number.\n            label_created_at_lte: Returned assets should have a label whose creation date is lower or equal to this date.\n            label_created_at_gte: Returned assets should have a label whose creation date is greater or equal to this date.\n            label_honeypot_mark_gte: Returned assets should have a label whose honeypot is greater or equal to this number.\n            label_honeypot_mark_lte: Returned assets should have a label whose honeypot is lower or equal to this number.\n            issue_type: Returned assets should have issues of type `QUESTION` or `ISSUE`.\n            issue_status: Returned assets should have issues of status `CANCELLED`, `OPEN` or `SOLVED`.\n            external_id_strictly_in: Returned assets should have external ids that match exactly the ones in the list.\n            external_id_in: Returned assets should have external ids that partially match the ones in the list.\n                For example, with `external_id_in=['abc']`, any asset with an external id containing `'abc'` will be returned.\n            label_output_format: If `parsed_label`, the labels in the assets will be parsed. More information on parsed labels in the [documentation](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/label_parsing/).\n            skipped: Returned assets should be skipped\n                Only applicable if the project is in WorkflowV1 (legacy).\n            status_in: Returned assets should have a status that belongs to that list, if given.\n                Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED`.\n                Only applicable if the project is in the WorkflowV1 (legacy).\n            step_name_in: Returned assets are in the step whose name belong to that list, if given.\n                Only applicable if the project is in WorkflowV2.\n            step_status_in: Returned assets have the status in their step that belongs to that list, if given.\n                Only applicable if the project is in WorkflowV2.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        !!! info \"Filtering by label properties\"\n            When the assets are filtered by label properties using any of `label_*` filter arguments, as soon as **one**\n            label matches **all** the label property criteria, the asset is kept and returned by the method. If any of the\n            `labels.*` or `latestLabel.*` subfields are queried, **all** the labels of the kept assets are returned together\n            with the assets (and not only the ones matching the criteria)\n\n        Returns:\n            An asset list, an asset generator or a pandas DataFrame that match a set of constraints.\n\n        Example:\n            ```\n            # returns the assets list of the project\n            &gt;&gt;&gt; kili.assets(project_id)\n            &gt;&gt;&gt; kili.assets(project_id, asset_id=asset_id)\n            # returns a generator of the project assets\n            &gt;&gt;&gt; kili.assets(project_id, as_generator=True)\n            ```\n\n        !!! example \"How to filter based on Metadata\"\n            - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\"\n            - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\" or value \"value2\n            - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n                have key \"key2\" with a value between 2 and 10.\n\n        !!! example \"How to filter based on label categories\"\n            The search query is composed of logical expressions following this format:\n\n                [job_name].[category_name].count [comparaison_operator] [value]\n            where:\n\n            - `[job_name]` is the name of the job in the interface\n            - `[category_name]` is the name of the category in the interface for this job\n            - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n            - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n            These operations can be separated by OR and AND operators:\n                ```python\n                label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n                label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n                label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n                ```\n        \"\"\"\n        if format == \"pandas\" and as_generator:\n            raise ValueError(\n                'Argument values as_generator==True and format==\"pandas\" are not compatible.'\n            )\n\n        if external_id_contains is not None:\n            warnings.warn(\n                \"external_id_contains is deprecated, use external_id_strictly_in instead\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n\n        for arg_name, arg_value in zip(\n            (\n                \"consensus_mark_gt\",\n                \"consensus_mark_lt\",\n                \"honeypot_mark_gt\",\n                \"honeypot_mark_lt\",\n                \"label_consensus_mark_gt\",\n                \"label_consensus_mark_lt\",\n                \"label_created_at_gt\",\n                \"label_created_at_lt\",\n                \"label_honeypot_mark_gt\",\n                \"label_honeypot_mark_lt\",\n            ),\n            (\n                consensus_mark_gt,\n                consensus_mark_lt,\n                honeypot_mark_gt,\n                honeypot_mark_lt,\n                label_consensus_mark_gt,\n                label_consensus_mark_lt,\n                label_created_at_gt,\n                label_created_at_lt,\n                label_honeypot_mark_gt,\n                label_honeypot_mark_lt,\n            ),\n        ):\n            if arg_value:\n                warnings.warn(\n                    f\"'{arg_name}' is deprecated, please use\"\n                    f\" '{arg_name.replace('_gt', '_gte').replace('_lt', '_lte')}' instead.\",\n                    DeprecationWarning,\n                    stacklevel=1,\n                )\n\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n\n        project_use_cases = ProjectUseCases(self.kili_api_gateway)\n        project_steps, project_workflow_version = project_use_cases.get_project_steps_and_version(\n            project_id\n        )\n        if fields is None:\n            fields = get_asset_default_fields(project_workflow_version=project_workflow_version)\n        elif project_workflow_version == \"V1\":\n            for invalid_field in filter(lambda f: f.startswith(\"currentStep.\"), fields):\n                warnings.warn(\n                    f\"Field {invalid_field} requested : request 'status' field instead for this project\",\n                    stacklevel=1,\n                )\n        elif \"status\" in fields:\n            warnings.warn(\n                \"Field status requested : request 'currentStep.name' and 'currentStep.status' fields instead for this project\",\n                stacklevel=1,\n            )\n\n        step_id_in = None\n        if (\n            step_name_in is not None\n            or step_status_in is not None\n            or status_in is not None\n            or skipped is not None\n        ):\n            check_asset_workflow_arguments(\n                project_workflow_version=project_workflow_version,\n                asset_workflow_filters={\n                    \"skipped\": skipped,\n                    \"status_in\": status_in,\n                    \"step_name_in\": step_name_in,\n                    \"step_status_in\": step_status_in,\n                },\n            )\n            if project_workflow_version == \"V2\" and step_name_in is not None:\n                step_id_in = extract_step_ids_from_project_steps(\n                    project_steps=project_steps,\n                    step_name_in=step_name_in,\n                )\n\n        asset_use_cases = AssetUseCases(self.kili_api_gateway)\n        filters = AssetFilters(\n            project_id=ProjectId(project_id),\n            asset_id=AssetId(asset_id) if asset_id else None,\n            asset_id_in=cast(List[AssetId], asset_id_in) if asset_id_in else None,\n            asset_id_not_in=cast(List[AssetId], asset_id_not_in) if asset_id_not_in else None,\n            consensus_mark_gte=consensus_mark_gt or consensus_mark_gte,\n            consensus_mark_lte=consensus_mark_lt or consensus_mark_lte,\n            external_id_strictly_in=(\n                cast(List[AssetExternalId], external_id_strictly_in or external_id_contains)\n                if external_id_strictly_in or external_id_contains\n                else None\n            ),\n            external_id_in=cast(List[AssetExternalId], external_id_in) if external_id_in else None,\n            honeypot_mark_gte=honeypot_mark_gt or honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lt or honeypot_mark_lte,\n            inference_mark_gte=inference_mark_gte,\n            inference_mark_lte=inference_mark_lte,\n            label_author_in=label_author_in,\n            label_consensus_mark_gte=label_consensus_mark_gt or label_consensus_mark_gte,\n            label_consensus_mark_lte=label_consensus_mark_lt or label_consensus_mark_lte,\n            label_created_at=label_created_at,\n            label_created_at_gte=label_created_at_gt or label_created_at_gte,\n            label_created_at_lte=label_created_at_lt or label_created_at_lte,\n            label_honeypot_mark_gte=label_honeypot_mark_gt or label_honeypot_mark_gte,\n            label_honeypot_mark_lte=label_honeypot_mark_lt or label_honeypot_mark_lte,\n            label_type_in=label_type_in,\n            metadata_where=metadata_where,\n            skipped=skipped,\n            status_in=status_in,\n            updated_at_gte=updated_at_gte,\n            updated_at_lte=updated_at_lte,\n            label_category_search=label_category_search,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            label_labeler_in=label_labeler_in,\n            label_labeler_not_in=label_labeler_not_in,\n            label_reviewer_in=label_reviewer_in,\n            label_reviewer_not_in=label_reviewer_not_in,\n            assignee_in=assignee_in,\n            assignee_not_in=assignee_not_in,\n            issue_status=issue_status,\n            issue_type=issue_type,\n            step_id_in=step_id_in,\n            step_status_in=step_status_in,\n        )\n        assets_gen = asset_use_cases.list_assets(\n            filters,\n            fields,\n            download_media=download_media,\n            local_media_dir=local_media_dir,\n            label_output_format=label_output_format,\n            options=QueryOptions(disable_tqdm=disable_tqdm, first=first, skip=skip),\n        )\n\n        if format == \"pandas\":\n            import pandas as pd  # pylint: disable=import-outside-toplevel\n\n            return pd.DataFrame(list(assets_gen))\n\n        if as_generator:\n            return assets_gen\n        return list(assets_gen)\n\n    # pylint: disable=too-many-arguments,too-many-locals\n    @typechecked\n    def count_assets(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_id_in: Optional[List[str]] = None,\n        asset_id_not_in: Optional[List[str]] = None,\n        external_id_contains: Optional[List[str]] = None,\n        metadata_where: Optional[dict] = None,\n        status_in: Optional[List[AssetStatus]] = None,\n        consensus_mark_gt: Optional[float] = None,\n        consensus_mark_lt: Optional[float] = None,\n        honeypot_mark_gt: Optional[float] = None,\n        honeypot_mark_lt: Optional[float] = None,\n        label_type_in: Optional[List[LabelType]] = None,\n        label_author_in: Optional[List[str]] = None,\n        label_consensus_mark_gt: Optional[float] = None,\n        label_consensus_mark_lt: Optional[float] = None,\n        label_created_at: Optional[str] = None,\n        label_created_at_gt: Optional[str] = None,\n        label_created_at_lt: Optional[str] = None,\n        label_honeypot_mark_gt: Optional[float] = None,\n        label_honeypot_mark_lt: Optional[float] = None,\n        skipped: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        label_category_search: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        consensus_mark_gte: Optional[float] = None,\n        consensus_mark_lte: Optional[float] = None,\n        inference_mark_gte: Optional[float] = None,\n        inference_mark_lte: Optional[float] = None,\n        label_labeler_in: Optional[ListOrTuple[str]] = None,\n        label_labeler_not_in: Optional[ListOrTuple[str]] = None,\n        label_reviewer_in: Optional[ListOrTuple[str]] = None,\n        label_reviewer_not_in: Optional[ListOrTuple[str]] = None,\n        assignee_in: Optional[ListOrTuple[str]] = None,\n        assignee_not_in: Optional[ListOrTuple[str]] = None,\n        label_consensus_mark_gte: Optional[float] = None,\n        label_consensus_mark_lte: Optional[float] = None,\n        label_created_at_gte: Optional[str] = None,\n        label_created_at_lte: Optional[str] = None,\n        label_honeypot_mark_gte: Optional[float] = None,\n        label_honeypot_mark_lte: Optional[float] = None,\n        issue_type: Optional[IssueType] = None,\n        issue_status: Optional[IssueStatus] = None,\n        external_id_strictly_in: Optional[List[str]] = None,\n        external_id_in: Optional[List[str]] = None,\n        step_name_in: Optional[List[str]] = None,\n        step_status_in: Optional[List[StatusInStep]] = None,\n    ) -&gt; int:\n        # pylint: disable=line-too-long\n        \"\"\"Count and return the number of assets with the given constraints.\n\n        Parameters beginning with 'label_' apply to labels, others apply to assets.\n\n        Args:\n            project_id: Identifier of the project\n            asset_id: The unique id of the asset to retrieve.\n            asset_id_in: A list of the ids of the assets to retrieve.\n            asset_id_not_in: A list of the ids of the assets to exclude.\n            external_id_contains: Deprecated. Use `external_id_strictly_in` instead.\n            metadata_where: Filters by the values of the metadata of the asset.\n            status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED`.\n            consensus_mark_gt: Deprecated. Use `consensus_mark_gte` instead.\n            consensus_mark_lt: Deprecated. Use `consensus_mark_lte` instead.\n            honeypot_mark_gt: Deprecated. Use `honeypot_mark_gte` instead.\n            honeypot_mark_lt: Deprecated. Use `honeypot_mark_lte` instead.\n            label_type_in: Returned assets should have a label whose type belongs to that list, if given.\n            label_author_in: Returned assets should have a label whose author belongs to that list, if given. An author can be designated by the first name, the last name, or the first name + last name.\n            label_consensus_mark_gt: Deprecated. Use `label_consensus_mark_gte` instead.\n            label_consensus_mark_lt: Deprecated. Use `label_consensus_mark_lte` instead.\n            label_created_at: Returned assets should have a label whose creation date is equal to this date.\n            label_created_at_gt: Deprecated. Use `label_created_at_gte` instead.\n            label_created_at_lt: Deprecated. Use `label_created_at_lte` instead.\n            label_honeypot_mark_gt: Deprecated. Use `label_honeypot_mark_gte` instead.\n            label_honeypot_mark_lt: Deprecated. Use `label_honeypot_mark_lte` instead.\n            skipped: Returned assets should be skipped.\n            updated_at_gte: Returned assets should have an update date that is greated or equal to this date. The update date represents the last time a modification has been done at the asset level.\n            updated_at_lte: Returned assets should have an update date that is lower or equal to this date. The update date represents the last time a modification has been done at the asset level.\n            label_category_search: Returned assets should have a label that follows this category search query.\n            created_at_gte: Returned assets should have their import date greater or equal to this date.\n            created_at_lte: Returned assets should have their import date lower or equal to this date.\n            honeypot_mark_lte: Maximum amount of honeypot for the asset.\n            honeypot_mark_gte: Minimum amount of honeypot for the asset.\n            consensus_mark_lte: Maximum amount of consensus for the asset.\n            consensus_mark_gte: Minimum amount of consensus for the asset.\n            inference_mark_gte: Minimum amount of human/model IoU for the asset.\n            inference_mark_lte: Maximum amount of human/model IoU for the asset.\n            label_labeler_in: Returned assets should have a label whose labeler belongs to that list, if given.\n            label_labeler_not_in: Returned assets should have a label whose labeler does not belong to that list, if given.\n            label_reviewer_in: Returned assets should have a label whose reviewer belongs to that list, if given.\n            label_reviewer_not_in: Returned assets should have a label whose reviewer does not belong to that list, if given.\n            assignee_in: Returned assets should have an assigned user that belongs to that list, if given.\n            assignee_not_in: Returned assets should have an assigned user that does not belong to that list, if given.\n            label_consensus_mark_gte: Returned assets should have a label whose consensus is greater or equal to this number.\n            label_consensus_mark_lte: Returned assets should have a label whose consensus is lower or equal to this number.\n            label_created_at_lte: Returned assets should have a label whose creation date is lower or equal to this date.\n            label_created_at_gte: Returned assets should have a label whose creation date is greater or equal to this date.\n            label_honeypot_mark_gte: Returned assets should have a label whose honeypot is greater or equal to this number.\n            label_honeypot_mark_lte: Returned assets should have a label whose honeypot is lower or equal to this number.\n            issue_type: Returned assets should have issues of type `QUESTION` or `ISSUE`.\n            issue_status: Returned assets should have issues of status `OPEN` or `SOLVED`.\n            external_id_strictly_in: Returned assets should have external ids that match exactly the ones in the list.\n            external_id_in: Returned assets should have external ids that partially match the ones in the list.\n                For example, with `external_id_in=['abc']`, any asset with an external id containing `'abc'` will be returned.\n            step_name_in: Returned assets are in a step whose name belong to that list, if given.\n                Only applicable if the project is in WorkflowV2.\n            step_status_in: Returned assets have the status of their step that belongs to that list, if given.\n                Possible choices: `TO_DO`, `DOING`, `PARTIALLY_DONE`, `REDO`, `DONE`, `SKIPPED`.\n                Only applicable if the project is in WorkflowV2.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            The number of assets that match the given constraints.\n\n        Examples:\n            &gt;&gt;&gt; kili.count_assets(project_id=project_id)\n            250\n            &gt;&gt;&gt; kili.count_assets(asset_id=asset_id)\n            1\n\n        !!! example \"How to filter based on Metadata\"\n            - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\"\n            - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\" or value \"value2\n            - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n                have key \"key2\" with a value between 2 and 10.\n        \"\"\"\n        if external_id_contains is not None:\n            warnings.warn(\n                \"external_id_contains is deprecated, use external_id_strictly_in instead\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n\n        for arg_name, arg_value in zip(\n            (\n                \"consensus_mark_gt\",\n                \"consensus_mark_lt\",\n                \"honeypot_mark_gt\",\n                \"honeypot_mark_lt\",\n                \"label_consensus_mark_gt\",\n                \"label_consensus_mark_lt\",\n                \"label_created_at_gt\",\n                \"label_created_at_lt\",\n                \"label_honeypot_mark_gt\",\n                \"label_honeypot_mark_lt\",\n            ),\n            (\n                consensus_mark_gt,\n                consensus_mark_lt,\n                honeypot_mark_gt,\n                honeypot_mark_lt,\n                label_consensus_mark_gt,\n                label_consensus_mark_lt,\n                label_created_at_gt,\n                label_created_at_lt,\n                label_honeypot_mark_gt,\n                label_honeypot_mark_lt,\n            ),\n        ):\n            if arg_value:\n                warnings.warn(\n                    f\"'{arg_name}' is deprecated, please use\"\n                    f\" '{arg_name.replace('_gt', '_gte').replace('_lt', '_lte')}' instead.\",\n                    DeprecationWarning,\n                    stacklevel=1,\n                )\n\n        step_id_in = None\n        if status_in is not None or step_name_in is not None or step_status_in is not None:\n            project_use_cases = ProjectUseCases(self.kili_api_gateway)\n            (\n                project_steps,\n                project_workflow_version,\n            ) = project_use_cases.get_project_steps_and_version(project_id)\n            check_asset_workflow_arguments(\n                project_workflow_version=project_workflow_version,\n                asset_workflow_filters={\n                    \"skipped\": skipped,\n                    \"step_name_in\": step_name_in,\n                    \"step_status_in\": step_status_in,\n                    \"status_in\": status_in,\n                },\n            )\n\n            if project_workflow_version == \"V2\" and step_name_in is not None:\n                step_id_in = extract_step_ids_from_project_steps(\n                    project_steps=project_steps,\n                    step_name_in=step_name_in,\n                )\n\n        filters = AssetFilters(\n            project_id=ProjectId(project_id),\n            asset_id=AssetId(asset_id) if asset_id else None,\n            asset_id_in=cast(List[AssetId], asset_id_in) if asset_id_in else None,\n            asset_id_not_in=cast(List[AssetId], asset_id_not_in) if asset_id_not_in else None,\n            consensus_mark_gte=consensus_mark_gt or consensus_mark_gte,\n            consensus_mark_lte=consensus_mark_lt or consensus_mark_lte,\n            external_id_strictly_in=(\n                cast(List[AssetExternalId], external_id_strictly_in or external_id_contains)\n                if external_id_strictly_in or external_id_contains\n                else None\n            ),\n            external_id_in=cast(List[AssetExternalId], external_id_in) if external_id_in else None,\n            honeypot_mark_gte=honeypot_mark_gt or honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lt or honeypot_mark_lte,\n            inference_mark_gte=inference_mark_gte,\n            inference_mark_lte=inference_mark_lte,\n            label_author_in=label_author_in,\n            label_labeler_in=label_labeler_in,\n            label_labeler_not_in=label_labeler_not_in,\n            label_reviewer_in=label_reviewer_in,\n            label_reviewer_not_in=label_reviewer_not_in,\n            assignee_in=assignee_in,\n            assignee_not_in=assignee_not_in,\n            label_consensus_mark_gte=label_consensus_mark_gt or label_consensus_mark_gte,\n            label_consensus_mark_lte=label_consensus_mark_lt or label_consensus_mark_lte,\n            label_created_at=label_created_at,\n            label_created_at_gte=label_created_at_gt or label_created_at_gte,\n            label_created_at_lte=label_created_at_lt or label_created_at_lte,\n            label_honeypot_mark_gte=label_honeypot_mark_gt or label_honeypot_mark_gte,\n            label_honeypot_mark_lte=label_honeypot_mark_lt or label_honeypot_mark_lte,\n            label_type_in=label_type_in,\n            metadata_where=metadata_where,\n            skipped=skipped,\n            status_in=status_in,\n            updated_at_gte=updated_at_gte,\n            updated_at_lte=updated_at_lte,\n            label_category_search=label_category_search,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            issue_status=issue_status,\n            issue_type=issue_type,\n            step_id_in=step_id_in,\n            step_status_in=step_status_in,\n        )\n        asset_use_cases = AssetUseCases(self.kili_api_gateway)\n        return asset_use_cases.count_assets(filters)\n</code></pre> <p>Set of Asset mutations.</p> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass MutationsAsset(BaseOperationEntrypointMixin):\n    \"\"\"Set of Asset mutations.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n    @typechecked\n    def append_many_to_dataset(\n        self,\n        project_id: str,\n        content_array: Optional[Union[List[str], List[dict], List[List[dict]]]] = None,\n        multi_layer_content_array: Optional[List[List[dict]]] = None,\n        external_id_array: Optional[List[str]] = None,\n        id_array: Optional[List[str]] = None,\n        is_honeypot_array: Optional[List[bool]] = None,\n        status_array: Optional[List[str]] = None,\n        json_content_array: Optional[List[Union[List[Union[dict, str]], None]]] = None,\n        json_metadata_array: Optional[List[dict]] = None,\n        disable_tqdm: Optional[bool] = None,\n        wait_until_availability: bool = True,\n        from_csv: Optional[str] = None,\n        csv_separator: str = \",\",\n    ) -&gt; Dict[Literal[\"id\", \"asset_ids\"], Union[str, List[str]]]:\n        # pylint: disable=line-too-long\n        \"\"\"Append assets to a project.\n\n        Args:\n            project_id: Identifier of the project\n            content_array: List of elements added to the assets of the project\n                Must not be None except if you provide multi_layer_content_array or json_content_array.\n\n                - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets.\n                - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing\n                    images/pdf on your computer.\n                - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to\n                existing video files on your computer. If you want to import video from frames, look at the json_content\n                section below.\n                - For an `VIDEO_LEGACY` project, the content can be only be URLs.\n                - For an `LLM_RLHF` project, the content can be dicts with the keys `prompt` and `completions`,\n                paths to local json files or URLs to json files.\n            multi_layer_content_array: List containing multiple lists of paths.\n                Each path correspond to a layer of a geospatial asset. Should be used only for `IMAGE` and `GEOSPATIAL` projects.\n            external_id_array: List of external ids given to identify the assets.\n                If None, random identifiers are created.\n            id_array: Disabled parameter. Do not use.\n            is_honeypot_array:  Whether to use the asset for honeypot\n            status_array: DEPRECATED and does not have any effect.\n            json_content_array: Useful for `VIDEO` or `TEXT` or `IMAGE` projects only.\n\n                - For `VIDEO` projects, each element is a sequence of frames, i.e. a\n                    list of URLs to images or a list of paths to images.\n                - For `TEXT` projects, each element is a json_content dict,\n                    formatted according to documentation [on how to import\n                rich-text assets](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/import_text_assets/).\n                - For `IMAGES` projects, it is used for satellite imagery each element is a list of json_content dicts\n                    formatted according to documentation [on how to add multi-layer images]\n                    (https://docs.kili-technology.com/docs/adding-assets-to-project#adding-multi-layer-images)\n\n            json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys.\n\n                - Add metadata visible on the asset\n                    Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': '','key1': 'value1'}]`.\n                - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30).\n                    Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`.\n                - In Image projects with geoTIFF assets, you can specify the epsg, the `minZoom` and `maxZoom` values for the `processingParameters` key.\n                    - The epsg is a number that defines the projection that will be used for the asset. Values that can be used are either 4326 or 3857, the 2\n                    projections that we support. If this number is not set, by default we keep the initial projection of the asset if it is 4326 or 3857, either\n                    we reproject the asset to EPSG:3857 by default.\n                    - The `minZoom` parameter defines the zoom level that users are not allowed to zoom out from. It also affects the zoom levels for which we\n                    generate the tiles when tiling the asset (for asset with size &gt; 30MB).\n                    - The `maxZoom` value affects asset generation: the higher the value, the greater the level of details and the size of the asset. It also affects\n                    the zoom levels for which we generate the tiles when tiling the asset (for asset with size &gt; 30MB).\n                    - Example for one asset: `json_metadata_array = [{'processingParameters': {'epsg': 3758, 'minZoom': 17, 'maxZoom': 19}}]`.\n            disable_tqdm: If `True`, the progress bar will be disabled\n            wait_until_availability: If `True`, the function will return once the assets are fully imported in Kili.\n                If `False`, the function will return faster but the assets might not be fully processed by the server.\n            from_csv: Path to a csv file containing the text assets to import.\n                Only used for `TEXT` projects.\n                If provided, `content_array` and `external_id_array` must be None.\n                The csv file header must specify the columns `content` and `externalId`.\n            csv_separator: Separator used in the csv file. Only used if `from_csv` is provided.\n\n\n        Returns:\n            A dictionary with two fields: `id` which is the project id and `asset_ids` which is a list of the created asset ids.\n            In the case where assets are uploaded asynchronously (for video imported as frames or big images or tiff images), the method return an empty list of asset ids.\n\n        Examples:\n            &gt;&gt;&gt; kili.append_many_to_dataset(\n                    project_id=project_id,\n                    content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png'])\n\n        !!! example \"Recipe\"\n            - For more detailed examples on how to import assets,\n                see [the recipe](https://docs.kili-technology.com/recipes/importing-data).\n            - For more detailed examples on how to import text assets,\n                see [the recipe](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/import_text_assets/).\n        \"\"\"\n        if from_csv is not None:\n            if content_array is not None or external_id_array is not None:\n                raise ValueError(\n                    \"If from_csv is provided, content_array and external_id_array must not be\"\n                    \" provided.\"\n                )\n            content_array, external_id_array = get_text_assets_from_csv(\n                from_csv=from_csv, csv_separator=csv_separator\n            )\n\n        if (\n            is_empty_list_with_warning(\"append_many_to_dataset\", \"content_array\", content_array)\n            or is_empty_list_with_warning(\n                \"append_many_to_dataset\", \"json_content_array\", json_content_array\n            )\n            or is_empty_list_with_warning(\n                \"append_many_to_dataset\", \"multi_layer_content_array\", multi_layer_content_array\n            )\n        ):\n            return {\"id\": project_id, \"asset_ids\": []}\n\n        if status_array is not None:\n            warnings.warn(\n                \"status_array is deprecated and will not be sent in the call. Asset status is\"\n                \" automatically computed based on its labels and cannot be overwritten.\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n\n        if (\n            content_array is None\n            and multi_layer_content_array is None\n            and json_content_array is None\n        ):\n            raise ValueError(\n                \"Variables content_array, multi_layer_content_array and json_content_array cannot be both None.\"\n            )\n\n        if content_array is not None and multi_layer_content_array is not None:\n            raise ValueError(\n                \"Variables content_array and multi_layer_content_array cannot be both provided.\"\n            )\n\n        nb_data = (\n            len(content_array)\n            if content_array is not None\n            else (\n                len(multi_layer_content_array)\n                if multi_layer_content_array is not None\n                else len(json_content_array)  # type:ignore\n            )\n        )\n\n        field_mapping = {\n            \"content\": content_array,\n            \"multi_layer_content\": multi_layer_content_array,\n            \"json_content\": json_content_array,\n            \"external_id\": external_id_array,\n            \"id\": id_array,\n            \"json_metadata\": json_metadata_array,\n            \"is_honeypot\": is_honeypot_array,\n        }\n        assets = [{}] * nb_data\n        for key, value in field_mapping.items():\n            if value is not None:\n                assets = [{**assets[i], key: value[i]} for i in range(nb_data)]\n        created_asset_ids = import_assets(\n            self,  # pyright: ignore[reportGeneralTypeIssues]\n            project_id=ProjectId(project_id),\n            assets=assets,\n            disable_tqdm=disable_tqdm,\n            verify=wait_until_availability,\n        )\n        return {\"id\": project_id, \"asset_ids\": created_asset_ids}\n\n    @typechecked\n    def assign_assets_to_labelers(\n        self,\n        to_be_labeled_by_array: List[List[str]],\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"Assign a list of assets to a list of labelers.\n\n        Args:\n            asset_ids: The internal asset IDs to assign.\n            external_ids: The external asset IDs to assign (if `asset_ids` is not already provided).\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n            to_be_labeled_by_array: The array of list of labelers to assign per labelers (list of userIds).\n\n        Returns:\n            A list of dictionaries with the asset ids.\n\n        Examples:\n            &gt;&gt;&gt; kili.assign_assets_to_labelers(\n                    asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                    to_be_labeled_by_array=[['cm3yja6kv0i698697gcil9rtk','cm3yja6kv0i000000gcil9rtk'],\n                                            ['cm3yja6kv0i698697gcil9rtk']]\n                )\n\n                # The following call resets the assignees on the asset_ids given.\n            &gt;&gt;&gt; kili.assign_assets_to_labelers(\n                    asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                    to_be_labeled_by_array=[[], []]\n                )\n        \"\"\"\n        if is_empty_list_with_warning(\n            \"assign_assets_to_labelers\", \"asset_ids\", asset_ids\n        ) and is_empty_list_with_warning(\"assign_assets_to_labelers\", \"external_ids\", external_ids):\n            return []\n\n        if (asset_ids is not None and external_ids is not None) or (\n            asset_ids is None and external_ids is None\n        ):\n            raise MissingArgumentError(\"Please provide either `asset_ids` or `external_ids`.\")\n\n        resolved_asset_ids = self._resolve_asset_ids(asset_ids, external_ids, project_id)\n\n        if len(resolved_asset_ids) != len(to_be_labeled_by_array):\n            raise MutationError(\"There must be as many assets as there are lists of labelers.\")\n\n        formated_results = []\n        for asset_id, to_be_labeled_by in zip(resolved_asset_ids, to_be_labeled_by_array):\n            payload = {\"userIds\": to_be_labeled_by, \"where\": {\"id\": asset_id}}\n            results = self.graphql_client.execute(GQL_ASSIGN_ASSETS, payload)\n            formated_results.append(results)\n        return formated_results\n\n    @typechecked\n    def update_properties_in_assets(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        priorities: Optional[List[int]] = None,\n        json_metadatas: Optional[List[Union[dict, str]]] = None,\n        consensus_marks: Optional[List[float]] = None,\n        honeypot_marks: Optional[List[float]] = None,\n        to_be_labeled_by_array: Optional[List[List[str]]] = None,\n        contents: Optional[List[str]] = None,\n        json_contents: Optional[List[str]] = None,\n        status_array: Optional[List[str]] = None,\n        is_used_for_consensus_array: Optional[List[bool]] = None,\n        is_honeypot_array: Optional[List[bool]] = None,\n        project_id: Optional[str] = None,\n        resolution_array: Optional[List[Dict]] = None,\n        page_resolutions_array: Optional[\n            Union[List[List[dict]], List[List[PageResolution]]]\n        ] = None,\n    ) -&gt; List[Dict[Literal[\"id\"], str]]:\n        \"\"\"Update the properties of one or more assets.\n\n        Args:\n            asset_ids: The internal asset IDs to modify.\n            external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n            priorities: You can change the priority of the assets.\n                By default, all assets have a priority of 0.\n            json_metadatas: The metadata given to an asset should be stored\n                in a json like dict with keys `imageUrl`, `text`, `url`:\n                `json_metadata = {'imageUrl': '','text': '','url': ''}`\n            consensus_marks: Should be between 0 and 1.\n            honeypot_marks: Should be between 0 and 1.\n            to_be_labeled_by_array: If given, each element of the list should contain the emails of\n                the labelers authorized to label the asset.\n            contents: - For a NLP project, the content can be directly in text format.\n                - For an Image / Video / Pdf project, the content must be hosted on a web server,\n                and you point Kili to your data by giving the URLs.\n            json_contents: - For a NLP project, the `json_content`\n                is a text formatted using RichText.\n                - For a Video project, the`json_content` is a json containg urls pointing\n                    to each frame of the video.\n            status_array: DEPRECATED and does not have any effect.\n            is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not.\n            is_honeypot_array: Whether to use the asset for honeypot.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n            resolution_array: The resolution of each asset (for image and video assets).\n                Each resolution must be passed as a dictionary with keys `width` and `height`.\n            page_resolutions_array: The resolution of each page of the asset (for PDF assets).\n                Note that each element of the array should contain all the pages resolutions of the\n                corresponding asset. Each resolution can be passed as a\n                `kili.utils.assets.PageResolution` object, or as a dictionary with keys `width`,\n                `height`, `pageNumber` and optionally `rotation`.\n\n        Returns:\n            A list of dictionaries with the asset ids.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_properties_in_assets(\n                    asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                    consensus_marks=[1, 0.7],\n                    contents=[None, 'https://to/second/asset.png'],\n                    honeypot_marks=[0.8, 0.5],\n                    is_honeypot_array=[True, True],\n                    is_used_for_consensus_array=[True, False],\n                    priorities=[None, 2],\n                    to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None],\n                )\n\n                # The following call updates the pages resolutions of PDF assets.\n            &gt;&gt;&gt; kili.update_properties_in_assets(\n                    asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                    page_resolutions_array=[\n                        [\n                            PageResolution(width=480, height=640, page_number=1),\n                            PageResolution(width=480, height=640, page_number=2),\n                        ],[\n                            PageResolution(width=340, height=512, page_number=1),\n                            PageResolution(width=680, height=1024, page_number=2, rotation=90),\n                            PageResolution(width=680, height=1024, page_number=3),\n                        ]\n                    ],\n                )\n        \"\"\"\n        if is_empty_list_with_warning(\n            \"update_properties_in_assets\", \"asset_ids\", asset_ids\n        ) or is_empty_list_with_warning(\n            \"update_properties_in_assets\", \"external_ids\", external_ids\n        ):\n            return []\n\n        if status_array is not None:\n            warnings.warn(\n                \"status_array is deprecated and will not be sent in the call. Asset status is\"\n                \" automatically computed based on its labels and cannot be overwritten.\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n        if asset_ids is not None and external_ids is not None:\n            warnings.warn(\n                \"The use of `external_ids` argument has changed. It is now used to identify\"\n                \" which properties of which assets to update. Please use\"\n                \" `kili.change_asset_external_ids()` method instead to change asset external\"\n                \" IDs.\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n            raise MissingArgumentError(\"Please provide either `asset_ids` or `external_ids`.\")\n\n        if to_be_labeled_by_array is not None:\n            warnings.warn(\n                \"to_be_labeled_by_array is going to be deprecated. Please use\"\n                \" `kili.assign_assets_to_labelers()` method instead to assign assets\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n\n        resolved_asset_ids = self._resolve_asset_ids(asset_ids, external_ids, project_id)\n\n        properties_to_batch = process_update_properties_in_assets_parameters(\n            cast(List[str], resolved_asset_ids),\n            priorities=priorities,\n            json_metadatas=json_metadatas,\n            consensus_marks=consensus_marks,\n            honeypot_marks=honeypot_marks,\n            to_be_labeled_by_array=to_be_labeled_by_array,\n            contents=contents,\n            json_contents=json_contents,\n            is_used_for_consensus_array=is_used_for_consensus_array,\n            is_honeypot_array=is_honeypot_array,\n            resolution_array=resolution_array,\n            page_resolutions_array=page_resolutions_array,\n        )\n\n        def generate_variables(batch: Dict) -&gt; Dict:\n            asset_ids = batch.pop(\"assetId\")\n            data_array = [dict(zip(batch, t)) for t in zip(*batch.values())]  # type: ignore\n            return {\n                \"whereArray\": [{\"id\": asset_id} for asset_id in asset_ids],\n                \"dataArray\": data_array,\n            }\n\n        results = mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_UPDATE_PROPERTIES_IN_ASSETS,\n        )\n        formated_results = [self.format_result(\"data\", result, None) for result in results]\n        return [item for batch_list in formated_results for item in batch_list]\n\n    @typechecked\n    def add_metadata(\n        self,\n        json_metadata: List[Dict[str, Union[str, int, float]]],\n        project_id: str,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n    ) -&gt; List[Dict[Literal[\"id\"], str]]:\n        \"\"\"Add metadata to assets without overriding existing metadata.\n\n        Args:\n            json_metadata: List of metadata dictionaries to add to each asset.\n                Each dictionary contains key/value pairs to be added to the asset's metadata.\n            project_id: The project ID.\n            asset_ids: The asset IDs to modify.\n            external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n\n        Returns:\n            A list of dictionaries with the asset ids.\n\n        Examples:\n            &gt;&gt;&gt; kili.add_metadata(\n                    json_metadata=[\n                        {\"key1\": \"value1\", \"key2\": \"value2\"},\n                        {\"key3\": \"value3\"}\n                    ],\n                    project_id=\"cm92to3cx012u7l0w6kij9qvx\",\n                    asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"]\n                )\n\n                # Or using external IDs\n            &gt;&gt;&gt; kili.add_metadata(\n                    json_metadata=[\n                        {\"key1\": \"value1\", \"key2\": \"value2\"},\n                        {\"key3\": \"value3\"}\n                    ],\n                    project_id=\"cm92to3cx012u7l0w6kij9qvx\",\n                    external_ids=[\"asset1\", \"asset2\"]\n                )\n        \"\"\"\n        if is_empty_list_with_warning(\"add_metadata\", \"json_metadata\", json_metadata):\n            return []\n\n        if (asset_ids is not None and external_ids is not None) or (\n            asset_ids is None and external_ids is None\n        ):\n            raise MissingArgumentError(\"Please provide either `asset_ids` or `external_ids`.\")\n\n        assets = self.kili_api_gateway.list_assets(\n            AssetFilters(\n                project_id=ProjectId(project_id),\n                asset_id_in=cast(List[AssetId], asset_ids),\n                external_id_in=cast(List[AssetExternalId], external_ids),\n            ),\n            [\"id\", \"jsonMetadata\"],\n            QueryOptions(disable_tqdm=True),\n        )\n\n        resolved_asset_ids = []\n        json_metadatas = []\n        for i, asset in enumerate(assets):\n            current_metadata = asset.get(\"jsonMetadata\", {}) if asset.get(\"jsonMetadata\") else {}\n            new_metadata = json_metadata[i] if i &lt; len(json_metadata) else {}\n\n            current_metadata.update(new_metadata)\n\n            json_metadatas.append(current_metadata)\n            resolved_asset_ids.append(asset[\"id\"])\n\n        return self.update_properties_in_assets(\n            asset_ids=cast(List[str], resolved_asset_ids),\n            json_metadatas=json_metadatas,\n        )\n\n    @typechecked\n    def set_metadata(\n        self,\n        json_metadata: List[Dict[str, Union[str, int, float]]],\n        project_id: str,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n    ) -&gt; List[Dict[Literal[\"id\"], str]]:\n        \"\"\"Set metadata on assets, replacing any existing metadata.\n\n        Args:\n            json_metadata: List of metadata dictionaries to set on each asset.\n                Each dictionary contains key/value pairs to be set as the asset's metadata.\n            project_id: The project ID.\n            asset_ids: The asset IDs to modify (if `external_ids` is not already provided).\n            external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n\n        Returns:\n            A list of dictionaries with the asset ids.\n\n        Examples:\n            &gt;&gt;&gt; kili.set_metadata(\n                    json_metadata=[\n                        {\"key1\": \"value1\", \"key2\": \"value2\"},\n                        {\"key3\": \"value3\"}\n                    ],\n                    project_id=\"cm92to3cx012u7l0w6kij9qvx\"\n                    asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"]\n                )\n\n                # Or using external IDs\n            &gt;&gt;&gt; kili.set_metadata(\n                    json_metadata=[\n                        {\"key1\": \"value1\", \"key2\": \"value2\"},\n                        {\"key3\": \"value3\"}\n                    ],\n                    project_id=\"cm92to3cx012u7l0w6kij9qvx\",\n                    external_ids=[\"asset1\", \"asset2\"]\n                )\n        \"\"\"\n        if is_empty_list_with_warning(\"set_metadata\", \"json_metadata\", json_metadata):\n            return []\n\n        if (asset_ids is not None and external_ids is not None) or (\n            asset_ids is None and external_ids is None\n        ):\n            raise MissingArgumentError(\"Please provide either `asset_ids` or `external_ids`.\")\n\n        assets = self.kili_api_gateway.list_assets(\n            AssetFilters(\n                project_id=ProjectId(project_id),\n                asset_id_in=cast(List[AssetId], asset_ids),\n                external_id_in=cast(List[AssetExternalId], external_ids),\n            ),\n            [\"id\", \"jsonMetadata\"],\n            QueryOptions(disable_tqdm=True),\n        )\n\n        resolved_asset_ids = []\n        json_metadatas = []\n        for i, asset in enumerate(assets):\n            current_metadata = asset.get(\"jsonMetadata\", {}) if asset.get(\"jsonMetadata\") else {}\n            new_metadata = json_metadata[i] if i &lt; len(json_metadata) else {}\n\n            special_keys = [\"text\", \"imageUrl\", \"url\", \"processingParameters\"]\n            preserved_metadata = {\n                k: current_metadata[k] for k in special_keys if k in current_metadata\n            }\n\n            preserved_metadata.update(new_metadata)\n\n            json_metadatas.append(preserved_metadata)\n            resolved_asset_ids.append(asset[\"id\"])\n\n        return self.update_properties_in_assets(\n            asset_ids=cast(List[str], resolved_asset_ids),\n            json_metadatas=json_metadatas,\n        )\n\n    @typechecked\n    def change_asset_external_ids(\n        self,\n        new_external_ids: List[str],\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; List[Dict[Literal[\"id\"], str]]:\n        \"\"\"Update the external IDs of one or more assets.\n\n        Args:\n            new_external_ids: The new external IDs of the assets.\n            asset_ids: The asset IDs to modify.\n            external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A list of dictionaries with the asset ids.\n\n        Examples:\n            &gt;&gt;&gt; kili.change_asset_external_ids(\n                    new_external_ids=[\"asset1\", \"asset2\"],\n                    asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                )\n        \"\"\"\n        if is_empty_list_with_warning(\n            \"change_asset_external_ids\", \"new_external_ids\", new_external_ids\n        ):\n            return []\n\n        resolved_asset_ids = self._resolve_asset_ids(asset_ids, external_ids, project_id)\n\n        properties_to_batch = process_update_properties_in_assets_parameters(\n            asset_ids=cast(List[str], resolved_asset_ids),\n            external_ids=new_external_ids,\n        )\n\n        def generate_variables(batch: Dict) -&gt; Dict:\n            asset_ids = batch.pop(\"assetId\")\n            data_array = [dict(zip(batch, t)) for t in zip(*batch.values())]  # type: ignore\n            return {\n                \"whereArray\": [{\"id\": asset_id} for asset_id in asset_ids],\n                \"dataArray\": data_array,\n            }\n\n        results = mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_UPDATE_PROPERTIES_IN_ASSETS,\n        )\n        formated_results = [self.format_result(\"data\", result, None) for result in results]\n        return [item for batch_list in formated_results for item in batch_list]\n\n    @typechecked\n    def delete_many_from_dataset(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Optional[Dict[Literal[\"id\"], str]]:\n        \"\"\"Delete assets from a project.\n\n        Args:\n            asset_ids: The list of asset internal IDs to delete.\n            external_ids: The list of asset external IDs to delete.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A dict object with the project `id`.\n        \"\"\"\n        if is_empty_list_with_warning(\n            \"delete_many_from_dataset\", \"asset_ids\", asset_ids\n        ) or is_empty_list_with_warning(\"delete_many_from_dataset\", \"external_ids\", external_ids):\n            return None\n\n        resolved_asset_ids = self._resolve_asset_ids(asset_ids, external_ids, project_id)\n\n        properties_to_batch = {\"asset_ids\": resolved_asset_ids}\n\n        def generate_variables(batch):\n            return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n        @retry(\n            wait=wait_exponential(multiplier=1, min=1, max=8),\n            retry=retry_if_exception_type(MutationError),\n            reraise=True,\n        )\n        def verify_last_batch(last_batch: Dict, results: List) -&gt; None:\n            \"\"\"Check that all assets in the last batch have been deleted.\"\"\"\n            if project_id is not None:\n                project_id_ = project_id\n            # in some case the results is [{'data': None}]\n            elif isinstance(results[0][\"data\"], Dict) and results[0][\"data\"].get(\"id\"):\n                project_id_ = results[0][\"data\"].get(\"id\")\n            else:\n                return\n\n            asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n\n            nb_assets_in_kili = self.kili_api_gateway.count_assets(\n                AssetFilters(\n                    project_id=ProjectId(project_id_),\n                    asset_id_in=asset_ids,\n                )\n            )\n            if nb_assets_in_kili &gt; 0:\n                raise MutationError(\"Failed to delete some assets.\")\n\n        results = mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_DELETE_MANY_FROM_DATASET,\n            last_batch_callback=verify_last_batch,\n        )\n        return self.format_result(\"data\", results[0])\n\n    @typechecked\n    def add_to_review(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Add assets to review.\n\n        !!! warning\n            Assets without any label will be ignored.\n\n        Args:\n            asset_ids: The asset internal IDs to add to review.\n            external_ids: The asset external IDs to add to review.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A dict object with the project `id` and the `asset_ids` of assets moved to review.\n            `None` if no assets have changed status (already had `TO_REVIEW` status for example).\n            An error message if mutation failed.\n\n        Examples:\n            &gt;&gt;&gt; kili.add_to_review(\n                    asset_ids=[\n                        \"ckg22d81r0jrg0885unmuswj8\",\n                        \"ckg22d81s0jrh0885pdxfd03n\",\n                    ],\n                )\n        \"\"\"\n        if is_empty_list_with_warning(\n            \"add_to_review\", \"asset_ids\", asset_ids\n        ) or is_empty_list_with_warning(\"add_to_review\", \"external_ids\", external_ids):\n            return None\n\n        resolved_asset_ids = self._resolve_asset_ids(asset_ids, external_ids, project_id)\n\n        properties_to_batch = {\"asset_ids\": resolved_asset_ids}\n\n        def generate_variables(batch):\n            return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n        @retry(\n            wait=wait_exponential(multiplier=1, min=1, max=8),\n            retry=retry_if_exception_type(MutationError),\n            reraise=True,\n        )\n        def verify_last_batch(last_batch: Dict, results: List) -&gt; None:\n            \"\"\"Check that all assets in the last batch have been sent to review.\"\"\"\n            if project_id is not None:\n                project_id_ = project_id\n            # in some case the results is [{'data': None}]\n            elif isinstance(results[0][\"data\"], Dict) and results[0][\"data\"].get(\"id\"):\n                project_id_ = results[0][\"data\"].get(\"id\")\n            else:\n                return\n\n            asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n            nb_assets_in_review = self.kili_api_gateway.count_assets(\n                AssetFilters(\n                    project_id=ProjectId(project_id_),\n                    asset_id_in=asset_ids,\n                    status_in=[\"TO_REVIEW\"],\n                )\n            )\n            if len(asset_ids) != nb_assets_in_review:\n                raise MutationError(\"Failed to send some assets to review\")\n\n        results = mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW,\n            last_batch_callback=verify_last_batch,\n        )\n        result = self.format_result(\"data\", results[0])\n        # unlike send_back_to_queue, the add_to_review mutation doesn't always return the project ID\n        # it happens when no assets have been sent to review\n        if isinstance(result, dict) and \"id\" in result:\n            assets_in_review = self.kili_api_gateway.list_assets(\n                AssetFilters(\n                    project_id=result[\"id\"],\n                    asset_id_in=resolved_asset_ids,\n                    status_in=[\"TO_REVIEW\"],\n                ),\n                [\"id\"],\n                QueryOptions(disable_tqdm=True),\n            )\n            result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_review]\n        return result\n\n    @typechecked\n    def send_back_to_queue(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Send assets back to queue.\n\n        Args:\n            asset_ids: List of internal IDs of assets to send back to queue.\n            external_ids: List of external IDs of assets to send back to queue.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A dict object with the project `id` and the `asset_ids` of assets moved to queue.\n            An error message if mutation failed.\n\n        Examples:\n            &gt;&gt;&gt; kili.send_back_to_queue(\n                    asset_ids=[\n                        \"ckg22d81r0jrg0885unmuswj8\",\n                        \"ckg22d81s0jrh0885pdxfd03n\",\n                        ],\n                )\n        \"\"\"\n        if is_empty_list_with_warning(\n            \"send_back_to_queue\", \"asset_ids\", asset_ids\n        ) or is_empty_list_with_warning(\"send_back_to_queue\", \"external_ids\", external_ids):\n            return None\n\n        resolved_asset_ids = self._resolve_asset_ids(asset_ids, external_ids, project_id)\n\n        properties_to_batch = {\"asset_ids\": resolved_asset_ids}\n\n        def generate_variables(batch):\n            return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n        @retry(\n            wait=wait_exponential(multiplier=1, min=1, max=8),\n            retry=retry_if_exception_type(MutationError),\n            reraise=True,\n        )\n        def verify_last_batch(last_batch: Dict, results: List) -&gt; None:\n            \"\"\"Check that all assets in the last batch have been sent back to queue.\"\"\"\n            if project_id is not None:\n                project_id_ = project_id\n            # in some case the results is [{'data': None}]\n            elif isinstance(results[0][\"data\"], Dict) and results[0][\"data\"].get(\"id\"):\n                project_id_ = results[0][\"data\"].get(\"id\")\n            else:\n                return\n\n            asset_ids = last_batch[\"asset_ids\"][-1:]  # check lastest asset of the batch only\n            nb_assets_in_queue = self.kili_api_gateway.count_assets(\n                AssetFilters(\n                    project_id=ProjectId(project_id_),\n                    asset_id_in=asset_ids,\n                    status_in=[\"ONGOING\"],\n                )\n            )\n            if len(asset_ids) != nb_assets_in_queue:\n                raise MutationError(\"Failed to send some assets back to queue\")\n\n        results = mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_SEND_BACK_ASSETS_TO_QUEUE,\n            last_batch_callback=verify_last_batch,\n        )\n        result = self.format_result(\"data\", results[0])\n        if isinstance(result, dict) and \"id\" in result:\n            assets_in_queue = self.kili_api_gateway.list_assets(\n                AssetFilters(\n                    project_id=result[\"id\"],\n                    asset_id_in=resolved_asset_ids,\n                    status_in=[\"ONGOING\"],\n                ),\n                [\"id\"],\n                QueryOptions(disable_tqdm=True),\n            )\n            result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_queue]\n        return result\n\n    def skip_or_unskip(\n        self,\n        action: Literal[\"skip\", \"unskip\"],\n        asset_id: str,\n        project_id: str,\n        reason: Optional[str] = None,\n    ) -&gt; str:\n        \"\"\"Skip or unskip an asset.\n\n        Args:\n            action: The action you want to do. Either skip or unskip.\n            asset_id: ID of the asset you want to skip or unskip.\n            project_id: The project ID.\n            reason: The reason why you skip an asset. Only required if the action is `skip`.\n\n        Returns:\n            The asset ID of the asset modified. An error message if mutation failed.\n\n        Examples:\n            &gt;&gt;&gt; kili.skip_or_unskip(\n            action=\"skip\",\n            asset_id=\"ckg22d81s0jrh0885pdxfd03n\",\n            project_id=\"ckg22d81r0jrg0885unmuswj8\",\n            reason=\"Test\"\n            )\n        \"\"\"\n        if action == \"skip\":\n            if reason is None:\n                raise MissingArgumentError(\"You must provide a reason to skip an asset\")\n            payload = {\"reason\": reason, \"where\": {\"id\": asset_id, \"project\": {\"id\": project_id}}}\n            self.graphql_client.execute(GQL_SKIP_ASSET, payload)\n        else:\n            payload = {\"projectId\": project_id, \"assetId\": asset_id}\n            self.graphql_client.execute(GQL_UNSKIP_ASSET, payload)\n        return asset_id\n</code></pre>"},{"location":"sdk/asset/#kili.presentation.client.asset.AssetClientMethods.assets","title":"<code>assets(self, project_id, asset_id=None, skip=0, fields=None, asset_id_in=None, asset_id_not_in=None, consensus_mark_gt=None, consensus_mark_lt=None, disable_tqdm=None, external_id_contains=None, first=None, format=None, honeypot_mark_gt=None, honeypot_mark_lt=None, label_author_in=None, label_consensus_mark_gt=None, label_consensus_mark_lt=None, label_created_at=None, label_created_at_gt=None, label_created_at_lt=None, label_honeypot_mark_gt=None, label_honeypot_mark_lt=None, label_type_in=None, metadata_where=None, updated_at_gte=None, updated_at_lte=None, label_category_search=None, download_media=False, local_media_dir=None, created_at_gte=None, created_at_lte=None, honeypot_mark_gte=None, honeypot_mark_lte=None, consensus_mark_gte=None, consensus_mark_lte=None, inference_mark_gte=None, inference_mark_lte=None, label_labeler_in=None, label_labeler_not_in=None, label_reviewer_in=None, label_reviewer_not_in=None, assignee_in=None, assignee_not_in=None, label_consensus_mark_gte=None, label_consensus_mark_lte=None, label_created_at_gte=None, label_created_at_lte=None, label_honeypot_mark_gte=None, label_honeypot_mark_lte=None, issue_type=None, issue_status=None, external_id_strictly_in=None, external_id_in=None, label_output_format='dict', skipped=None, status_in=None, step_name_in=None, step_status_in=None, *, as_generator=False)</code>","text":"<p>Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset to retrieve.</p> <code>None</code> <code>asset_id_in</code> <code>Optional[List[str]]</code> <p>A list of the IDs of the assets to retrieve.</p> <code>None</code> <code>asset_id_not_in</code> <code>Optional[List[str]]</code> <p>A list of the IDs of the assets to exclude.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of assets to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the assets.     See the documentation for all possible fields.</p> <code>None</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of assets to return.</p> <code>None</code> <code>consensus_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>consensus_mark_gte</code> instead.</p> <code>None</code> <code>consensus_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>consensus_mark_lte</code> instead.</p> <code>None</code> <code>external_id_contains</code> <code>Optional[List[str]]</code> <p>Deprecated. Use <code>external_id_strictly_in</code> instead.</p> <code>None</code> <code>metadata_where</code> <code>Optional[dict]</code> <p>Filters by the values of the metadata of the asset.</p> <code>None</code> <code>honeypot_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>honeypot_mark_gte</code> instead.</p> <code>None</code> <code>honeypot_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>honeypot_mark_lte</code> instead.</p> <code>None</code> <code>label_type_in</code> <code>Optional[List[Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW']]]</code> <p>Returned assets should have a label whose type belongs to that list, if given.</p> <code>None</code> <code>label_author_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose author belongs to that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>label_consensus_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_consensus_mark_gte</code> instead.</p> <code>None</code> <code>label_consensus_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_consensus_mark_lte</code> instead.</p> <code>None</code> <code>label_created_at</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is equal to this date.</p> <code>None</code> <code>label_created_at_gt</code> <code>Optional[str]</code> <p>Deprecated. Use <code>label_created_at_gte</code> instead.</p> <code>None</code> <code>label_created_at_lt</code> <code>Optional[str]</code> <p>Deprecated. Use <code>label_created_at_lte</code> instead.</p> <code>None</code> <code>label_honeypot_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_honeypot_mark_gte</code> instead.</p> <code>None</code> <code>label_honeypot_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_honeypot_mark_lte</code> instead.</p> <code>None</code> <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have an update date that is greater or equal to this date. The update date represents the last time a modification has been done at the asset level.</p> <code>None</code> <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have an update date that is lower or equal to this date. The update date represents the last time a modification has been done at the asset level.</p> <code>None</code> <code>format</code> <code>Optional[str]</code> <p>If equal to 'pandas', returns a pandas DataFrame</p> <code>None</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>None</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the assets is returned.</p> <code>False</code> <code>label_category_search</code> <code>Optional[str]</code> <p>Returned assets should have a label that follows this category search query.</p> <code>None</code> <code>download_media</code> <code>bool</code> <p>Tell is the media have to be downloaded or not.</p> <code>False</code> <code>local_media_dir</code> <code>Optional[str]</code> <p>Directory where the media are downloaded if <code>download_media</code> is True.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have their import date greater or equal to this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have their import date lower or equal to this date.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Maximum amount of honeypot for the asset.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Minimum amount of honeypot for the asset.</p> <code>None</code> <code>consensus_mark_lte</code> <code>Optional[float]</code> <p>Maximum amount of consensus for the asset.</p> <code>None</code> <code>consensus_mark_gte</code> <code>Optional[float]</code> <p>Minimum amount of consensus for the asset.</p> <code>None</code> <code>inference_mark_gte</code> <code>Optional[float]</code> <p>Minimum amount of human/model IoU for the asset.</p> <code>None</code> <code>inference_mark_lte</code> <code>Optional[float]</code> <p>Maximum amount of human/model IoU for the asset.</p> <code>None</code> <code>label_labeler_in</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Returned assets should have a label whose labeler belongs to that list, if given.</p> <code>None</code> <code>label_labeler_not_in</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Returned assets should have a label whose labeler does not belong to that list, if given.</p> <code>None</code> <code>label_reviewer_in</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Returned assets should have a label whose reviewer belongs to that list, if given.</p> <code>None</code> <code>label_reviewer_not_in</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Returned assets should have a label whose reviewer does not belong to that list, if given.</p> <code>None</code> <code>assignee_in</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Returned assets should have an assigned user that belongs to that list, if given.</p> <code>None</code> <code>assignee_not_in</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Returned assets should have an assigned user that does not belong to that list, if given.</p> <code>None</code> <code>label_consensus_mark_gte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is greater or equal to this number.</p> <code>None</code> <code>label_consensus_mark_lte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is lower or equal to this number.</p> <code>None</code> <code>label_created_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is lower or equal to this date.</p> <code>None</code> <code>label_created_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is greater or equal to this date.</p> <code>None</code> <code>label_honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is greater or equal to this number.</p> <code>None</code> <code>label_honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is lower or equal to this number.</p> <code>None</code> <code>issue_type</code> <code>Optional[Literal['ISSUE', 'QUESTION']]</code> <p>Returned assets should have issues of type <code>QUESTION</code> or <code>ISSUE</code>.</p> <code>None</code> <code>issue_status</code> <code>Optional[Literal['CANCELLED', 'OPEN', 'SOLVED']]</code> <p>Returned assets should have issues of status <code>CANCELLED</code>, <code>OPEN</code> or <code>SOLVED</code>.</p> <code>None</code> <code>external_id_strictly_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have external ids that match exactly the ones in the list.</p> <code>None</code> <code>external_id_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have external ids that partially match the ones in the list. For example, with <code>external_id_in=['abc']</code>, any asset with an external id containing <code>'abc'</code> will be returned.</p> <code>None</code> <code>label_output_format</code> <code>Literal['dict', 'parsed_label']</code> <p>If <code>parsed_label</code>, the labels in the assets will be parsed. More information on parsed labels in the documentation.</p> <code>'dict'</code> <code>skipped</code> <code>Optional[bool]</code> <p>Returned assets should be skipped Only applicable if the project is in WorkflowV1 (legacy).</p> <code>None</code> <code>status_in</code> <code>Optional[List[Literal['TODO', 'ONGOING', 'LABELED', 'REVIEWED', 'TO_REVIEW']]]</code> <p>Returned assets should have a status that belongs to that list, if given. Possible choices: <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO_REVIEW</code> or <code>REVIEWED</code>. Only applicable if the project is in the WorkflowV1 (legacy).</p> <code>None</code> <code>step_name_in</code> <code>Optional[List[str]]</code> <p>Returned assets are in the step whose name belong to that list, if given. Only applicable if the project is in WorkflowV2.</p> <code>None</code> <code>step_status_in</code> <code>Optional[List[Literal['TO_DO', 'DOING', 'PARTIALLY_DONE', 'REDO', 'DONE', 'SKIPPED']]]</code> <p>Returned assets have the status in their step that belongs to that list, if given. Only applicable if the project is in WorkflowV2.</p> <code>None</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Filtering by label properties</p> <p>When the assets are filtered by label properties using any of <code>label_*</code> filter arguments, as soon as one label matches all the label property criteria, the asset is kept and returned by the method. If any of the <code>labels.*</code> or <code>latestLabel.*</code> subfields are queried, all the labels of the kept assets are returned together with the assets (and not only the ones matching the criteria)</p> <p>Returns:</p> Type Description <code>Union[Iterable[Dict], pd.DataFrame]</code> <p>An asset list, an asset generator or a pandas DataFrame that match a set of constraints.</p> <p>Examples:</p> <pre><code># returns the assets list of the project\n&gt;&gt;&gt; kili.assets(project_id)\n&gt;&gt;&gt; kili.assets(project_id, asset_id=asset_id)\n# returns a generator of the project assets\n&gt;&gt;&gt; kili.assets(project_id, as_generator=True)\n</code></pre> <p>How to filter based on Metadata</p> <ul> <li><code>metadata_where = {key1: \"value1\"}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\"</li> <li><code>metadata_where = {key1: [\"value1\", \"value2\"]}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\" or value \"value2</li> <li><code>metadata_where = {key2: [2, 10]}</code> to filter on assets whose metadata     have key \"key2\" with a value between 2 and 10.</li> </ul> <p>How to filter based on label categories</p> <p>The search query is composed of logical expressions following this format:</p> <pre><code>[job_name].[category_name].count [comparaison_operator] [value]\n</code></pre> <p>where:</p> <ul> <li><code>[job_name]</code> is the name of the job in the interface</li> <li><code>[category_name]</code> is the name of the category in the interface for this job</li> <li><code>[comparaison_operator]</code> can be one of: [<code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;</code>]</li> <li><code>[value]</code> is an integer that represents the count of such objects of the given category in the label</li> </ul> <p>These operations can be separated by OR and AND operators:     <pre><code>label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\nlabel_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\nlabel_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n</code></pre></p> Source code in <code>kili/presentation/client/asset.py</code> <pre><code>def assets(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    skip: int = 0,\n    fields: Optional[ListOrTuple[str]] = None,\n    asset_id_in: Optional[List[str]] = None,\n    asset_id_not_in: Optional[List[str]] = None,\n    consensus_mark_gt: Optional[float] = None,\n    consensus_mark_lt: Optional[float] = None,\n    disable_tqdm: Optional[bool] = None,\n    external_id_contains: Optional[List[str]] = None,\n    first: Optional[int] = None,\n    format: Optional[str] = None,\n    honeypot_mark_gt: Optional[float] = None,\n    honeypot_mark_lt: Optional[float] = None,\n    label_author_in: Optional[List[str]] = None,\n    label_consensus_mark_gt: Optional[float] = None,\n    label_consensus_mark_lt: Optional[float] = None,\n    label_created_at: Optional[str] = None,\n    label_created_at_gt: Optional[str] = None,\n    label_created_at_lt: Optional[str] = None,\n    label_honeypot_mark_gt: Optional[float] = None,\n    label_honeypot_mark_lt: Optional[float] = None,\n    label_type_in: Optional[List[LabelType]] = None,\n    metadata_where: Optional[dict] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n    label_category_search: Optional[str] = None,\n    download_media: bool = False,\n    local_media_dir: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    consensus_mark_gte: Optional[float] = None,\n    consensus_mark_lte: Optional[float] = None,\n    inference_mark_gte: Optional[float] = None,\n    inference_mark_lte: Optional[float] = None,\n    label_labeler_in: Optional[ListOrTuple[str]] = None,\n    label_labeler_not_in: Optional[ListOrTuple[str]] = None,\n    label_reviewer_in: Optional[ListOrTuple[str]] = None,\n    label_reviewer_not_in: Optional[ListOrTuple[str]] = None,\n    assignee_in: Optional[ListOrTuple[str]] = None,\n    assignee_not_in: Optional[ListOrTuple[str]] = None,\n    label_consensus_mark_gte: Optional[float] = None,\n    label_consensus_mark_lte: Optional[float] = None,\n    label_created_at_gte: Optional[str] = None,\n    label_created_at_lte: Optional[str] = None,\n    label_honeypot_mark_gte: Optional[float] = None,\n    label_honeypot_mark_lte: Optional[float] = None,\n    issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n    issue_status: Optional[Literal[\"CANCELLED\", \"OPEN\", \"SOLVED\"]] = None,\n    external_id_strictly_in: Optional[List[str]] = None,\n    external_id_in: Optional[List[str]] = None,\n    label_output_format: Literal[\"dict\", \"parsed_label\"] = \"dict\",\n    skipped: Optional[bool] = None,\n    status_in: Optional[List[AssetStatus]] = None,\n    step_name_in: Optional[List[str]] = None,\n    step_status_in: Optional[List[StatusInStep]] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Union[Iterable[Dict], \"pd.DataFrame\"]:\n    # pylint: disable=line-too-long\n    \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints.\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset to retrieve.\n        asset_id_in: A list of the IDs of the assets to retrieve.\n        asset_id_not_in: A list of the IDs of the assets to exclude.\n        skip: Number of assets to skip (they are ordered by their date of creation, first to last).\n        fields: All the fields to request among the possible fields for the assets.\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/asset) for all possible fields.\n        first: Maximum number of assets to return.\n        consensus_mark_gt: Deprecated. Use `consensus_mark_gte` instead.\n        consensus_mark_lt: Deprecated. Use `consensus_mark_lte` instead.\n        external_id_contains: Deprecated. Use `external_id_strictly_in` instead.\n        metadata_where: Filters by the values of the metadata of the asset.\n        honeypot_mark_gt: Deprecated. Use `honeypot_mark_gte` instead.\n        honeypot_mark_lt: Deprecated. Use `honeypot_mark_lte` instead.\n        label_type_in: Returned assets should have a label whose type belongs to that list, if given.\n        label_author_in: Returned assets should have a label whose author belongs to that list, if given. An author can be designated by the first name, the last name, or the first name + last name.\n        label_consensus_mark_gt: Deprecated. Use `label_consensus_mark_gte` instead.\n        label_consensus_mark_lt: Deprecated. Use `label_consensus_mark_lte` instead.\n        label_created_at: Returned assets should have a label whose creation date is equal to this date.\n        label_created_at_gt: Deprecated. Use `label_created_at_gte` instead.\n        label_created_at_lt: Deprecated. Use `label_created_at_lte` instead.\n        label_honeypot_mark_gt: Deprecated. Use `label_honeypot_mark_gte` instead.\n        label_honeypot_mark_lt: Deprecated. Use `label_honeypot_mark_lte` instead.\n        updated_at_gte: Returned assets should have an update date that is greater or equal to this date. The update date represents the last time a modification has been done at the asset level.\n        updated_at_lte: Returned assets should have an update date that is lower or equal to this date. The update date represents the last time a modification has been done at the asset level.\n        format: If equal to 'pandas', returns a pandas DataFrame\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the assets is returned.\n        label_category_search: Returned assets should have a label that follows this category search query.\n        download_media: Tell is the media have to be downloaded or not.\n        local_media_dir: Directory where the media are downloaded if `download_media` is True.\n        created_at_gte: Returned assets should have their import date greater or equal to this date.\n        created_at_lte: Returned assets should have their import date lower or equal to this date.\n        honeypot_mark_lte: Maximum amount of honeypot for the asset.\n        honeypot_mark_gte: Minimum amount of honeypot for the asset.\n        consensus_mark_lte: Maximum amount of consensus for the asset.\n        consensus_mark_gte: Minimum amount of consensus for the asset.\n        inference_mark_gte: Minimum amount of human/model IoU for the asset.\n        inference_mark_lte: Maximum amount of human/model IoU for the asset.\n        label_labeler_in: Returned assets should have a label whose labeler belongs to that list, if given.\n        label_labeler_not_in: Returned assets should have a label whose labeler does not belong to that list, if given.\n        label_reviewer_in: Returned assets should have a label whose reviewer belongs to that list, if given.\n        label_reviewer_not_in: Returned assets should have a label whose reviewer does not belong to that list, if given.\n        assignee_in: Returned assets should have an assigned user that belongs to that list, if given.\n        assignee_not_in: Returned assets should have an assigned user that does not belong to that list, if given.\n        label_consensus_mark_gte: Returned assets should have a label whose consensus is greater or equal to this number.\n        label_consensus_mark_lte: Returned assets should have a label whose consensus is lower or equal to this number.\n        label_created_at_lte: Returned assets should have a label whose creation date is lower or equal to this date.\n        label_created_at_gte: Returned assets should have a label whose creation date is greater or equal to this date.\n        label_honeypot_mark_gte: Returned assets should have a label whose honeypot is greater or equal to this number.\n        label_honeypot_mark_lte: Returned assets should have a label whose honeypot is lower or equal to this number.\n        issue_type: Returned assets should have issues of type `QUESTION` or `ISSUE`.\n        issue_status: Returned assets should have issues of status `CANCELLED`, `OPEN` or `SOLVED`.\n        external_id_strictly_in: Returned assets should have external ids that match exactly the ones in the list.\n        external_id_in: Returned assets should have external ids that partially match the ones in the list.\n            For example, with `external_id_in=['abc']`, any asset with an external id containing `'abc'` will be returned.\n        label_output_format: If `parsed_label`, the labels in the assets will be parsed. More information on parsed labels in the [documentation](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/label_parsing/).\n        skipped: Returned assets should be skipped\n            Only applicable if the project is in WorkflowV1 (legacy).\n        status_in: Returned assets should have a status that belongs to that list, if given.\n            Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED`.\n            Only applicable if the project is in the WorkflowV1 (legacy).\n        step_name_in: Returned assets are in the step whose name belong to that list, if given.\n            Only applicable if the project is in WorkflowV2.\n        step_status_in: Returned assets have the status in their step that belongs to that list, if given.\n            Only applicable if the project is in WorkflowV2.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    !!! info \"Filtering by label properties\"\n        When the assets are filtered by label properties using any of `label_*` filter arguments, as soon as **one**\n        label matches **all** the label property criteria, the asset is kept and returned by the method. If any of the\n        `labels.*` or `latestLabel.*` subfields are queried, **all** the labels of the kept assets are returned together\n        with the assets (and not only the ones matching the criteria)\n\n    Returns:\n        An asset list, an asset generator or a pandas DataFrame that match a set of constraints.\n\n    Example:\n        ```\n        # returns the assets list of the project\n        &gt;&gt;&gt; kili.assets(project_id)\n        &gt;&gt;&gt; kili.assets(project_id, asset_id=asset_id)\n        # returns a generator of the project assets\n        &gt;&gt;&gt; kili.assets(project_id, as_generator=True)\n        ```\n\n    !!! example \"How to filter based on Metadata\"\n        - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\"\n        - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\" or value \"value2\n        - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n            have key \"key2\" with a value between 2 and 10.\n\n    !!! example \"How to filter based on label categories\"\n        The search query is composed of logical expressions following this format:\n\n            [job_name].[category_name].count [comparaison_operator] [value]\n        where:\n\n        - `[job_name]` is the name of the job in the interface\n        - `[category_name]` is the name of the category in the interface for this job\n        - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n        - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n        These operations can be separated by OR and AND operators:\n            ```python\n            label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n            label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n            label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n            ```\n    \"\"\"\n    if format == \"pandas\" and as_generator:\n        raise ValueError(\n            'Argument values as_generator==True and format==\"pandas\" are not compatible.'\n        )\n\n    if external_id_contains is not None:\n        warnings.warn(\n            \"external_id_contains is deprecated, use external_id_strictly_in instead\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n\n    for arg_name, arg_value in zip(\n        (\n            \"consensus_mark_gt\",\n            \"consensus_mark_lt\",\n            \"honeypot_mark_gt\",\n            \"honeypot_mark_lt\",\n            \"label_consensus_mark_gt\",\n            \"label_consensus_mark_lt\",\n            \"label_created_at_gt\",\n            \"label_created_at_lt\",\n            \"label_honeypot_mark_gt\",\n            \"label_honeypot_mark_lt\",\n        ),\n        (\n            consensus_mark_gt,\n            consensus_mark_lt,\n            honeypot_mark_gt,\n            honeypot_mark_lt,\n            label_consensus_mark_gt,\n            label_consensus_mark_lt,\n            label_created_at_gt,\n            label_created_at_lt,\n            label_honeypot_mark_gt,\n            label_honeypot_mark_lt,\n        ),\n    ):\n        if arg_value:\n            warnings.warn(\n                f\"'{arg_name}' is deprecated, please use\"\n                f\" '{arg_name.replace('_gt', '_gte').replace('_lt', '_lte')}' instead.\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n\n    project_use_cases = ProjectUseCases(self.kili_api_gateway)\n    project_steps, project_workflow_version = project_use_cases.get_project_steps_and_version(\n        project_id\n    )\n    if fields is None:\n        fields = get_asset_default_fields(project_workflow_version=project_workflow_version)\n    elif project_workflow_version == \"V1\":\n        for invalid_field in filter(lambda f: f.startswith(\"currentStep.\"), fields):\n            warnings.warn(\n                f\"Field {invalid_field} requested : request 'status' field instead for this project\",\n                stacklevel=1,\n            )\n    elif \"status\" in fields:\n        warnings.warn(\n            \"Field status requested : request 'currentStep.name' and 'currentStep.status' fields instead for this project\",\n            stacklevel=1,\n        )\n\n    step_id_in = None\n    if (\n        step_name_in is not None\n        or step_status_in is not None\n        or status_in is not None\n        or skipped is not None\n    ):\n        check_asset_workflow_arguments(\n            project_workflow_version=project_workflow_version,\n            asset_workflow_filters={\n                \"skipped\": skipped,\n                \"status_in\": status_in,\n                \"step_name_in\": step_name_in,\n                \"step_status_in\": step_status_in,\n            },\n        )\n        if project_workflow_version == \"V2\" and step_name_in is not None:\n            step_id_in = extract_step_ids_from_project_steps(\n                project_steps=project_steps,\n                step_name_in=step_name_in,\n            )\n\n    asset_use_cases = AssetUseCases(self.kili_api_gateway)\n    filters = AssetFilters(\n        project_id=ProjectId(project_id),\n        asset_id=AssetId(asset_id) if asset_id else None,\n        asset_id_in=cast(List[AssetId], asset_id_in) if asset_id_in else None,\n        asset_id_not_in=cast(List[AssetId], asset_id_not_in) if asset_id_not_in else None,\n        consensus_mark_gte=consensus_mark_gt or consensus_mark_gte,\n        consensus_mark_lte=consensus_mark_lt or consensus_mark_lte,\n        external_id_strictly_in=(\n            cast(List[AssetExternalId], external_id_strictly_in or external_id_contains)\n            if external_id_strictly_in or external_id_contains\n            else None\n        ),\n        external_id_in=cast(List[AssetExternalId], external_id_in) if external_id_in else None,\n        honeypot_mark_gte=honeypot_mark_gt or honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lt or honeypot_mark_lte,\n        inference_mark_gte=inference_mark_gte,\n        inference_mark_lte=inference_mark_lte,\n        label_author_in=label_author_in,\n        label_consensus_mark_gte=label_consensus_mark_gt or label_consensus_mark_gte,\n        label_consensus_mark_lte=label_consensus_mark_lt or label_consensus_mark_lte,\n        label_created_at=label_created_at,\n        label_created_at_gte=label_created_at_gt or label_created_at_gte,\n        label_created_at_lte=label_created_at_lt or label_created_at_lte,\n        label_honeypot_mark_gte=label_honeypot_mark_gt or label_honeypot_mark_gte,\n        label_honeypot_mark_lte=label_honeypot_mark_lt or label_honeypot_mark_lte,\n        label_type_in=label_type_in,\n        metadata_where=metadata_where,\n        skipped=skipped,\n        status_in=status_in,\n        updated_at_gte=updated_at_gte,\n        updated_at_lte=updated_at_lte,\n        label_category_search=label_category_search,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        label_labeler_in=label_labeler_in,\n        label_labeler_not_in=label_labeler_not_in,\n        label_reviewer_in=label_reviewer_in,\n        label_reviewer_not_in=label_reviewer_not_in,\n        assignee_in=assignee_in,\n        assignee_not_in=assignee_not_in,\n        issue_status=issue_status,\n        issue_type=issue_type,\n        step_id_in=step_id_in,\n        step_status_in=step_status_in,\n    )\n    assets_gen = asset_use_cases.list_assets(\n        filters,\n        fields,\n        download_media=download_media,\n        local_media_dir=local_media_dir,\n        label_output_format=label_output_format,\n        options=QueryOptions(disable_tqdm=disable_tqdm, first=first, skip=skip),\n    )\n\n    if format == \"pandas\":\n        import pandas as pd  # pylint: disable=import-outside-toplevel\n\n        return pd.DataFrame(list(assets_gen))\n\n    if as_generator:\n        return assets_gen\n    return list(assets_gen)\n</code></pre>"},{"location":"sdk/asset/#kili.presentation.client.asset.AssetClientMethods.count_assets","title":"<code>count_assets(self, project_id, asset_id=None, asset_id_in=None, asset_id_not_in=None, external_id_contains=None, metadata_where=None, status_in=None, consensus_mark_gt=None, consensus_mark_lt=None, honeypot_mark_gt=None, honeypot_mark_lt=None, label_type_in=None, label_author_in=None, label_consensus_mark_gt=None, label_consensus_mark_lt=None, label_created_at=None, label_created_at_gt=None, label_created_at_lt=None, label_honeypot_mark_gt=None, label_honeypot_mark_lt=None, skipped=None, updated_at_gte=None, updated_at_lte=None, label_category_search=None, created_at_gte=None, created_at_lte=None, honeypot_mark_gte=None, honeypot_mark_lte=None, consensus_mark_gte=None, consensus_mark_lte=None, inference_mark_gte=None, inference_mark_lte=None, label_labeler_in=None, label_labeler_not_in=None, label_reviewer_in=None, label_reviewer_not_in=None, assignee_in=None, assignee_not_in=None, label_consensus_mark_gte=None, label_consensus_mark_lte=None, label_created_at_gte=None, label_created_at_lte=None, label_honeypot_mark_gte=None, label_honeypot_mark_lte=None, issue_type=None, issue_status=None, external_id_strictly_in=None, external_id_in=None, step_name_in=None, step_status_in=None)</code>","text":"<p>Count and return the number of assets with the given constraints.</p> <p>Parameters beginning with 'label_' apply to labels, others apply to assets.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>asset_id</code> <code>Optional[str]</code> <p>The unique id of the asset to retrieve.</p> <code>None</code> <code>asset_id_in</code> <code>Optional[List[str]]</code> <p>A list of the ids of the assets to retrieve.</p> <code>None</code> <code>asset_id_not_in</code> <code>Optional[List[str]]</code> <p>A list of the ids of the assets to exclude.</p> <code>None</code> <code>external_id_contains</code> <code>Optional[List[str]]</code> <p>Deprecated. Use <code>external_id_strictly_in</code> instead.</p> <code>None</code> <code>metadata_where</code> <code>Optional[dict]</code> <p>Filters by the values of the metadata of the asset.</p> <code>None</code> <code>status_in</code> <code>Optional[List[Literal['TODO', 'ONGOING', 'LABELED', 'REVIEWED', 'TO_REVIEW']]]</code> <p>Returned assets should have a status that belongs to that list, if given. Possible choices: <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO_REVIEW</code> or <code>REVIEWED</code>.</p> <code>None</code> <code>consensus_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>consensus_mark_gte</code> instead.</p> <code>None</code> <code>consensus_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>consensus_mark_lte</code> instead.</p> <code>None</code> <code>honeypot_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>honeypot_mark_gte</code> instead.</p> <code>None</code> <code>honeypot_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>honeypot_mark_lte</code> instead.</p> <code>None</code> <code>label_type_in</code> <code>Optional[List[Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW']]]</code> <p>Returned assets should have a label whose type belongs to that list, if given.</p> <code>None</code> <code>label_author_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose author belongs to that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>label_consensus_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_consensus_mark_gte</code> instead.</p> <code>None</code> <code>label_consensus_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_consensus_mark_lte</code> instead.</p> <code>None</code> <code>label_created_at</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is equal to this date.</p> <code>None</code> <code>label_created_at_gt</code> <code>Optional[str]</code> <p>Deprecated. Use <code>label_created_at_gte</code> instead.</p> <code>None</code> <code>label_created_at_lt</code> <code>Optional[str]</code> <p>Deprecated. Use <code>label_created_at_lte</code> instead.</p> <code>None</code> <code>label_honeypot_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_honeypot_mark_gte</code> instead.</p> <code>None</code> <code>label_honeypot_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_honeypot_mark_lte</code> instead.</p> <code>None</code> <code>skipped</code> <code>Optional[bool]</code> <p>Returned assets should be skipped.</p> <code>None</code> <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have an update date that is greated or equal to this date. The update date represents the last time a modification has been done at the asset level.</p> <code>None</code> <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have an update date that is lower or equal to this date. The update date represents the last time a modification has been done at the asset level.</p> <code>None</code> <code>label_category_search</code> <code>Optional[str]</code> <p>Returned assets should have a label that follows this category search query.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have their import date greater or equal to this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have their import date lower or equal to this date.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Maximum amount of honeypot for the asset.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Minimum amount of honeypot for the asset.</p> <code>None</code> <code>consensus_mark_lte</code> <code>Optional[float]</code> <p>Maximum amount of consensus for the asset.</p> <code>None</code> <code>consensus_mark_gte</code> <code>Optional[float]</code> <p>Minimum amount of consensus for the asset.</p> <code>None</code> <code>inference_mark_gte</code> <code>Optional[float]</code> <p>Minimum amount of human/model IoU for the asset.</p> <code>None</code> <code>inference_mark_lte</code> <code>Optional[float]</code> <p>Maximum amount of human/model IoU for the asset.</p> <code>None</code> <code>label_labeler_in</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Returned assets should have a label whose labeler belongs to that list, if given.</p> <code>None</code> <code>label_labeler_not_in</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Returned assets should have a label whose labeler does not belong to that list, if given.</p> <code>None</code> <code>label_reviewer_in</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Returned assets should have a label whose reviewer belongs to that list, if given.</p> <code>None</code> <code>label_reviewer_not_in</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Returned assets should have a label whose reviewer does not belong to that list, if given.</p> <code>None</code> <code>assignee_in</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Returned assets should have an assigned user that belongs to that list, if given.</p> <code>None</code> <code>assignee_not_in</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Returned assets should have an assigned user that does not belong to that list, if given.</p> <code>None</code> <code>label_consensus_mark_gte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is greater or equal to this number.</p> <code>None</code> <code>label_consensus_mark_lte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is lower or equal to this number.</p> <code>None</code> <code>label_created_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is lower or equal to this date.</p> <code>None</code> <code>label_created_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is greater or equal to this date.</p> <code>None</code> <code>label_honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is greater or equal to this number.</p> <code>None</code> <code>label_honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is lower or equal to this number.</p> <code>None</code> <code>issue_type</code> <code>Optional[Literal['ISSUE', 'QUESTION']]</code> <p>Returned assets should have issues of type <code>QUESTION</code> or <code>ISSUE</code>.</p> <code>None</code> <code>issue_status</code> <code>Optional[Literal['CANCELLED', 'OPEN', 'SOLVED']]</code> <p>Returned assets should have issues of status <code>OPEN</code> or <code>SOLVED</code>.</p> <code>None</code> <code>external_id_strictly_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have external ids that match exactly the ones in the list.</p> <code>None</code> <code>external_id_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have external ids that partially match the ones in the list. For example, with <code>external_id_in=['abc']</code>, any asset with an external id containing <code>'abc'</code> will be returned.</p> <code>None</code> <code>step_name_in</code> <code>Optional[List[str]]</code> <p>Returned assets are in a step whose name belong to that list, if given. Only applicable if the project is in WorkflowV2.</p> <code>None</code> <code>step_status_in</code> <code>Optional[List[Literal['TO_DO', 'DOING', 'PARTIALLY_DONE', 'REDO', 'DONE', 'SKIPPED']]]</code> <p>Returned assets have the status of their step that belongs to that list, if given. Possible choices: <code>TO_DO</code>, <code>DOING</code>, <code>PARTIALLY_DONE</code>, <code>REDO</code>, <code>DONE</code>, <code>SKIPPED</code>. Only applicable if the project is in WorkflowV2.</p> <code>None</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of assets that match the given constraints.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.count_assets(project_id=project_id)\n250\n&gt;&gt;&gt; kili.count_assets(asset_id=asset_id)\n1\n</code></pre> <p>How to filter based on Metadata</p> <ul> <li><code>metadata_where = {key1: \"value1\"}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\"</li> <li><code>metadata_where = {key1: [\"value1\", \"value2\"]}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\" or value \"value2</li> <li><code>metadata_where = {key2: [2, 10]}</code> to filter on assets whose metadata     have key \"key2\" with a value between 2 and 10.</li> </ul> Source code in <code>kili/presentation/client/asset.py</code> <pre><code>def count_assets(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_id_in: Optional[List[str]] = None,\n    asset_id_not_in: Optional[List[str]] = None,\n    external_id_contains: Optional[List[str]] = None,\n    metadata_where: Optional[dict] = None,\n    status_in: Optional[List[AssetStatus]] = None,\n    consensus_mark_gt: Optional[float] = None,\n    consensus_mark_lt: Optional[float] = None,\n    honeypot_mark_gt: Optional[float] = None,\n    honeypot_mark_lt: Optional[float] = None,\n    label_type_in: Optional[List[LabelType]] = None,\n    label_author_in: Optional[List[str]] = None,\n    label_consensus_mark_gt: Optional[float] = None,\n    label_consensus_mark_lt: Optional[float] = None,\n    label_created_at: Optional[str] = None,\n    label_created_at_gt: Optional[str] = None,\n    label_created_at_lt: Optional[str] = None,\n    label_honeypot_mark_gt: Optional[float] = None,\n    label_honeypot_mark_lt: Optional[float] = None,\n    skipped: Optional[bool] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n    label_category_search: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    consensus_mark_gte: Optional[float] = None,\n    consensus_mark_lte: Optional[float] = None,\n    inference_mark_gte: Optional[float] = None,\n    inference_mark_lte: Optional[float] = None,\n    label_labeler_in: Optional[ListOrTuple[str]] = None,\n    label_labeler_not_in: Optional[ListOrTuple[str]] = None,\n    label_reviewer_in: Optional[ListOrTuple[str]] = None,\n    label_reviewer_not_in: Optional[ListOrTuple[str]] = None,\n    assignee_in: Optional[ListOrTuple[str]] = None,\n    assignee_not_in: Optional[ListOrTuple[str]] = None,\n    label_consensus_mark_gte: Optional[float] = None,\n    label_consensus_mark_lte: Optional[float] = None,\n    label_created_at_gte: Optional[str] = None,\n    label_created_at_lte: Optional[str] = None,\n    label_honeypot_mark_gte: Optional[float] = None,\n    label_honeypot_mark_lte: Optional[float] = None,\n    issue_type: Optional[IssueType] = None,\n    issue_status: Optional[IssueStatus] = None,\n    external_id_strictly_in: Optional[List[str]] = None,\n    external_id_in: Optional[List[str]] = None,\n    step_name_in: Optional[List[str]] = None,\n    step_status_in: Optional[List[StatusInStep]] = None,\n) -&gt; int:\n    # pylint: disable=line-too-long\n    \"\"\"Count and return the number of assets with the given constraints.\n\n    Parameters beginning with 'label_' apply to labels, others apply to assets.\n\n    Args:\n        project_id: Identifier of the project\n        asset_id: The unique id of the asset to retrieve.\n        asset_id_in: A list of the ids of the assets to retrieve.\n        asset_id_not_in: A list of the ids of the assets to exclude.\n        external_id_contains: Deprecated. Use `external_id_strictly_in` instead.\n        metadata_where: Filters by the values of the metadata of the asset.\n        status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED`.\n        consensus_mark_gt: Deprecated. Use `consensus_mark_gte` instead.\n        consensus_mark_lt: Deprecated. Use `consensus_mark_lte` instead.\n        honeypot_mark_gt: Deprecated. Use `honeypot_mark_gte` instead.\n        honeypot_mark_lt: Deprecated. Use `honeypot_mark_lte` instead.\n        label_type_in: Returned assets should have a label whose type belongs to that list, if given.\n        label_author_in: Returned assets should have a label whose author belongs to that list, if given. An author can be designated by the first name, the last name, or the first name + last name.\n        label_consensus_mark_gt: Deprecated. Use `label_consensus_mark_gte` instead.\n        label_consensus_mark_lt: Deprecated. Use `label_consensus_mark_lte` instead.\n        label_created_at: Returned assets should have a label whose creation date is equal to this date.\n        label_created_at_gt: Deprecated. Use `label_created_at_gte` instead.\n        label_created_at_lt: Deprecated. Use `label_created_at_lte` instead.\n        label_honeypot_mark_gt: Deprecated. Use `label_honeypot_mark_gte` instead.\n        label_honeypot_mark_lt: Deprecated. Use `label_honeypot_mark_lte` instead.\n        skipped: Returned assets should be skipped.\n        updated_at_gte: Returned assets should have an update date that is greated or equal to this date. The update date represents the last time a modification has been done at the asset level.\n        updated_at_lte: Returned assets should have an update date that is lower or equal to this date. The update date represents the last time a modification has been done at the asset level.\n        label_category_search: Returned assets should have a label that follows this category search query.\n        created_at_gte: Returned assets should have their import date greater or equal to this date.\n        created_at_lte: Returned assets should have their import date lower or equal to this date.\n        honeypot_mark_lte: Maximum amount of honeypot for the asset.\n        honeypot_mark_gte: Minimum amount of honeypot for the asset.\n        consensus_mark_lte: Maximum amount of consensus for the asset.\n        consensus_mark_gte: Minimum amount of consensus for the asset.\n        inference_mark_gte: Minimum amount of human/model IoU for the asset.\n        inference_mark_lte: Maximum amount of human/model IoU for the asset.\n        label_labeler_in: Returned assets should have a label whose labeler belongs to that list, if given.\n        label_labeler_not_in: Returned assets should have a label whose labeler does not belong to that list, if given.\n        label_reviewer_in: Returned assets should have a label whose reviewer belongs to that list, if given.\n        label_reviewer_not_in: Returned assets should have a label whose reviewer does not belong to that list, if given.\n        assignee_in: Returned assets should have an assigned user that belongs to that list, if given.\n        assignee_not_in: Returned assets should have an assigned user that does not belong to that list, if given.\n        label_consensus_mark_gte: Returned assets should have a label whose consensus is greater or equal to this number.\n        label_consensus_mark_lte: Returned assets should have a label whose consensus is lower or equal to this number.\n        label_created_at_lte: Returned assets should have a label whose creation date is lower or equal to this date.\n        label_created_at_gte: Returned assets should have a label whose creation date is greater or equal to this date.\n        label_honeypot_mark_gte: Returned assets should have a label whose honeypot is greater or equal to this number.\n        label_honeypot_mark_lte: Returned assets should have a label whose honeypot is lower or equal to this number.\n        issue_type: Returned assets should have issues of type `QUESTION` or `ISSUE`.\n        issue_status: Returned assets should have issues of status `OPEN` or `SOLVED`.\n        external_id_strictly_in: Returned assets should have external ids that match exactly the ones in the list.\n        external_id_in: Returned assets should have external ids that partially match the ones in the list.\n            For example, with `external_id_in=['abc']`, any asset with an external id containing `'abc'` will be returned.\n        step_name_in: Returned assets are in a step whose name belong to that list, if given.\n            Only applicable if the project is in WorkflowV2.\n        step_status_in: Returned assets have the status of their step that belongs to that list, if given.\n            Possible choices: `TO_DO`, `DOING`, `PARTIALLY_DONE`, `REDO`, `DONE`, `SKIPPED`.\n            Only applicable if the project is in WorkflowV2.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        The number of assets that match the given constraints.\n\n    Examples:\n        &gt;&gt;&gt; kili.count_assets(project_id=project_id)\n        250\n        &gt;&gt;&gt; kili.count_assets(asset_id=asset_id)\n        1\n\n    !!! example \"How to filter based on Metadata\"\n        - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\"\n        - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\" or value \"value2\n        - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n            have key \"key2\" with a value between 2 and 10.\n    \"\"\"\n    if external_id_contains is not None:\n        warnings.warn(\n            \"external_id_contains is deprecated, use external_id_strictly_in instead\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n\n    for arg_name, arg_value in zip(\n        (\n            \"consensus_mark_gt\",\n            \"consensus_mark_lt\",\n            \"honeypot_mark_gt\",\n            \"honeypot_mark_lt\",\n            \"label_consensus_mark_gt\",\n            \"label_consensus_mark_lt\",\n            \"label_created_at_gt\",\n            \"label_created_at_lt\",\n            \"label_honeypot_mark_gt\",\n            \"label_honeypot_mark_lt\",\n        ),\n        (\n            consensus_mark_gt,\n            consensus_mark_lt,\n            honeypot_mark_gt,\n            honeypot_mark_lt,\n            label_consensus_mark_gt,\n            label_consensus_mark_lt,\n            label_created_at_gt,\n            label_created_at_lt,\n            label_honeypot_mark_gt,\n            label_honeypot_mark_lt,\n        ),\n    ):\n        if arg_value:\n            warnings.warn(\n                f\"'{arg_name}' is deprecated, please use\"\n                f\" '{arg_name.replace('_gt', '_gte').replace('_lt', '_lte')}' instead.\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n\n    step_id_in = None\n    if status_in is not None or step_name_in is not None or step_status_in is not None:\n        project_use_cases = ProjectUseCases(self.kili_api_gateway)\n        (\n            project_steps,\n            project_workflow_version,\n        ) = project_use_cases.get_project_steps_and_version(project_id)\n        check_asset_workflow_arguments(\n            project_workflow_version=project_workflow_version,\n            asset_workflow_filters={\n                \"skipped\": skipped,\n                \"step_name_in\": step_name_in,\n                \"step_status_in\": step_status_in,\n                \"status_in\": status_in,\n            },\n        )\n\n        if project_workflow_version == \"V2\" and step_name_in is not None:\n            step_id_in = extract_step_ids_from_project_steps(\n                project_steps=project_steps,\n                step_name_in=step_name_in,\n            )\n\n    filters = AssetFilters(\n        project_id=ProjectId(project_id),\n        asset_id=AssetId(asset_id) if asset_id else None,\n        asset_id_in=cast(List[AssetId], asset_id_in) if asset_id_in else None,\n        asset_id_not_in=cast(List[AssetId], asset_id_not_in) if asset_id_not_in else None,\n        consensus_mark_gte=consensus_mark_gt or consensus_mark_gte,\n        consensus_mark_lte=consensus_mark_lt or consensus_mark_lte,\n        external_id_strictly_in=(\n            cast(List[AssetExternalId], external_id_strictly_in or external_id_contains)\n            if external_id_strictly_in or external_id_contains\n            else None\n        ),\n        external_id_in=cast(List[AssetExternalId], external_id_in) if external_id_in else None,\n        honeypot_mark_gte=honeypot_mark_gt or honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lt or honeypot_mark_lte,\n        inference_mark_gte=inference_mark_gte,\n        inference_mark_lte=inference_mark_lte,\n        label_author_in=label_author_in,\n        label_labeler_in=label_labeler_in,\n        label_labeler_not_in=label_labeler_not_in,\n        label_reviewer_in=label_reviewer_in,\n        label_reviewer_not_in=label_reviewer_not_in,\n        assignee_in=assignee_in,\n        assignee_not_in=assignee_not_in,\n        label_consensus_mark_gte=label_consensus_mark_gt or label_consensus_mark_gte,\n        label_consensus_mark_lte=label_consensus_mark_lt or label_consensus_mark_lte,\n        label_created_at=label_created_at,\n        label_created_at_gte=label_created_at_gt or label_created_at_gte,\n        label_created_at_lte=label_created_at_lt or label_created_at_lte,\n        label_honeypot_mark_gte=label_honeypot_mark_gt or label_honeypot_mark_gte,\n        label_honeypot_mark_lte=label_honeypot_mark_lt or label_honeypot_mark_lte,\n        label_type_in=label_type_in,\n        metadata_where=metadata_where,\n        skipped=skipped,\n        status_in=status_in,\n        updated_at_gte=updated_at_gte,\n        updated_at_lte=updated_at_lte,\n        label_category_search=label_category_search,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        issue_status=issue_status,\n        issue_type=issue_type,\n        step_id_in=step_id_in,\n        step_status_in=step_status_in,\n    )\n    asset_use_cases = AssetUseCases(self.kili_api_gateway)\n    return asset_use_cases.count_assets(filters)\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.add_metadata","title":"<code>add_metadata(self, json_metadata, project_id, asset_ids=None, external_ids=None)</code>","text":"<p>Add metadata to assets without overriding existing metadata.</p> <p>Parameters:</p> Name Type Description Default <code>json_metadata</code> <code>List[Dict[str, Union[str, int, float]]]</code> <p>List of metadata dictionaries to add to each asset. Each dictionary contains key/value pairs to be added to the asset's metadata.</p> required <code>project_id</code> <code>str</code> <p>The project ID.</p> required <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The asset IDs to modify.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The external asset IDs to modify (if <code>asset_ids</code> is not already provided).</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[Literal['id'], str]]</code> <p>A list of dictionaries with the asset ids.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.add_metadata(\n        json_metadata=[\n            {\"key1\": \"value1\", \"key2\": \"value2\"},\n            {\"key3\": \"value3\"}\n        ],\n        project_id=\"cm92to3cx012u7l0w6kij9qvx\",\n        asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"]\n    )\n</code></pre> <pre><code># Or using external IDs\n</code></pre> <pre><code>&gt;&gt;&gt; kili.add_metadata(\n        json_metadata=[\n            {\"key1\": \"value1\", \"key2\": \"value2\"},\n            {\"key3\": \"value3\"}\n        ],\n        project_id=\"cm92to3cx012u7l0w6kij9qvx\",\n        external_ids=[\"asset1\", \"asset2\"]\n    )\n</code></pre> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>def add_metadata(\n    self,\n    json_metadata: List[Dict[str, Union[str, int, float]]],\n    project_id: str,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n) -&gt; List[Dict[Literal[\"id\"], str]]:\n    \"\"\"Add metadata to assets without overriding existing metadata.\n\n    Args:\n        json_metadata: List of metadata dictionaries to add to each asset.\n            Each dictionary contains key/value pairs to be added to the asset's metadata.\n        project_id: The project ID.\n        asset_ids: The asset IDs to modify.\n        external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n\n    Returns:\n        A list of dictionaries with the asset ids.\n\n    Examples:\n        &gt;&gt;&gt; kili.add_metadata(\n                json_metadata=[\n                    {\"key1\": \"value1\", \"key2\": \"value2\"},\n                    {\"key3\": \"value3\"}\n                ],\n                project_id=\"cm92to3cx012u7l0w6kij9qvx\",\n                asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"]\n            )\n\n            # Or using external IDs\n        &gt;&gt;&gt; kili.add_metadata(\n                json_metadata=[\n                    {\"key1\": \"value1\", \"key2\": \"value2\"},\n                    {\"key3\": \"value3\"}\n                ],\n                project_id=\"cm92to3cx012u7l0w6kij9qvx\",\n                external_ids=[\"asset1\", \"asset2\"]\n            )\n    \"\"\"\n    if is_empty_list_with_warning(\"add_metadata\", \"json_metadata\", json_metadata):\n        return []\n\n    if (asset_ids is not None and external_ids is not None) or (\n        asset_ids is None and external_ids is None\n    ):\n        raise MissingArgumentError(\"Please provide either `asset_ids` or `external_ids`.\")\n\n    assets = self.kili_api_gateway.list_assets(\n        AssetFilters(\n            project_id=ProjectId(project_id),\n            asset_id_in=cast(List[AssetId], asset_ids),\n            external_id_in=cast(List[AssetExternalId], external_ids),\n        ),\n        [\"id\", \"jsonMetadata\"],\n        QueryOptions(disable_tqdm=True),\n    )\n\n    resolved_asset_ids = []\n    json_metadatas = []\n    for i, asset in enumerate(assets):\n        current_metadata = asset.get(\"jsonMetadata\", {}) if asset.get(\"jsonMetadata\") else {}\n        new_metadata = json_metadata[i] if i &lt; len(json_metadata) else {}\n\n        current_metadata.update(new_metadata)\n\n        json_metadatas.append(current_metadata)\n        resolved_asset_ids.append(asset[\"id\"])\n\n    return self.update_properties_in_assets(\n        asset_ids=cast(List[str], resolved_asset_ids),\n        json_metadatas=json_metadatas,\n    )\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.add_to_review","title":"<code>add_to_review(self, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Add assets to review.</p> <p>Warning</p> <p>Assets without any label will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The asset internal IDs to add to review.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The asset external IDs to add to review.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>A dict object with the project <code>id</code> and the <code>asset_ids</code> of assets moved to review. <code>None</code> if no assets have changed status (already had <code>TO_REVIEW</code> status for example). An error message if mutation failed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.add_to_review(\n        asset_ids=[\n            \"ckg22d81r0jrg0885unmuswj8\",\n            \"ckg22d81s0jrh0885pdxfd03n\",\n        ],\n    )\n</code></pre> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>def add_to_review(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Add assets to review.\n\n    !!! warning\n        Assets without any label will be ignored.\n\n    Args:\n        asset_ids: The asset internal IDs to add to review.\n        external_ids: The asset external IDs to add to review.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A dict object with the project `id` and the `asset_ids` of assets moved to review.\n        `None` if no assets have changed status (already had `TO_REVIEW` status for example).\n        An error message if mutation failed.\n\n    Examples:\n        &gt;&gt;&gt; kili.add_to_review(\n                asset_ids=[\n                    \"ckg22d81r0jrg0885unmuswj8\",\n                    \"ckg22d81s0jrh0885pdxfd03n\",\n                ],\n            )\n    \"\"\"\n    if is_empty_list_with_warning(\n        \"add_to_review\", \"asset_ids\", asset_ids\n    ) or is_empty_list_with_warning(\"add_to_review\", \"external_ids\", external_ids):\n        return None\n\n    resolved_asset_ids = self._resolve_asset_ids(asset_ids, external_ids, project_id)\n\n    properties_to_batch = {\"asset_ids\": resolved_asset_ids}\n\n    def generate_variables(batch):\n        return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n    @retry(\n        wait=wait_exponential(multiplier=1, min=1, max=8),\n        retry=retry_if_exception_type(MutationError),\n        reraise=True,\n    )\n    def verify_last_batch(last_batch: Dict, results: List) -&gt; None:\n        \"\"\"Check that all assets in the last batch have been sent to review.\"\"\"\n        if project_id is not None:\n            project_id_ = project_id\n        # in some case the results is [{'data': None}]\n        elif isinstance(results[0][\"data\"], Dict) and results[0][\"data\"].get(\"id\"):\n            project_id_ = results[0][\"data\"].get(\"id\")\n        else:\n            return\n\n        asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n        nb_assets_in_review = self.kili_api_gateway.count_assets(\n            AssetFilters(\n                project_id=ProjectId(project_id_),\n                asset_id_in=asset_ids,\n                status_in=[\"TO_REVIEW\"],\n            )\n        )\n        if len(asset_ids) != nb_assets_in_review:\n            raise MutationError(\"Failed to send some assets to review\")\n\n    results = mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW,\n        last_batch_callback=verify_last_batch,\n    )\n    result = self.format_result(\"data\", results[0])\n    # unlike send_back_to_queue, the add_to_review mutation doesn't always return the project ID\n    # it happens when no assets have been sent to review\n    if isinstance(result, dict) and \"id\" in result:\n        assets_in_review = self.kili_api_gateway.list_assets(\n            AssetFilters(\n                project_id=result[\"id\"],\n                asset_id_in=resolved_asset_ids,\n                status_in=[\"TO_REVIEW\"],\n            ),\n            [\"id\"],\n            QueryOptions(disable_tqdm=True),\n        )\n        result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_review]\n    return result\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.append_many_to_dataset","title":"<code>append_many_to_dataset(self, project_id, content_array=None, multi_layer_content_array=None, external_id_array=None, id_array=None, is_honeypot_array=None, status_array=None, json_content_array=None, json_metadata_array=None, disable_tqdm=None, wait_until_availability=True, from_csv=None, csv_separator=',')</code>","text":"<p>Append assets to a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>content_array</code> <code>Union[List[str], List[dict], List[List[dict]]]</code> <p>List of elements added to the assets of the project Must not be None except if you provide multi_layer_content_array or json_content_array.</p> <ul> <li>For a <code>TEXT</code> project, the content can be either raw text, or URLs to TEXT assets.</li> <li>For an <code>IMAGE</code> / <code>PDF</code> project, the content can be either URLs or paths to existing     images/pdf on your computer.</li> <li>For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below.</li> <li>For an <code>VIDEO_LEGACY</code> project, the content can be only be URLs.</li> <li>For an <code>LLM_RLHF</code> project, the content can be dicts with the keys <code>prompt</code> and <code>completions</code>, paths to local json files or URLs to json files.</li> </ul> <code>None</code> <code>multi_layer_content_array</code> <code>Optional[List[List[dict]]]</code> <p>List containing multiple lists of paths. Each path correspond to a layer of a geospatial asset. Should be used only for <code>IMAGE</code> and <code>GEOSPATIAL</code> projects.</p> <code>None</code> <code>external_id_array</code> <code>Optional[List[str]]</code> <p>List of external ids given to identify the assets. If None, random identifiers are created.</p> <code>None</code> <code>id_array</code> <code>Optional[List[str]]</code> <p>Disabled parameter. Do not use.</p> <code>None</code> <code>is_honeypot_array</code> <code>Optional[List[bool]]</code> <p>Whether to use the asset for honeypot</p> <code>None</code> <code>status_array</code> <code>Optional[List[str]]</code> <p>DEPRECATED and does not have any effect.</p> <code>None</code> <code>json_content_array</code> <code>Optional[List[Optional[List[Union[dict, str]]]]]</code> <p>Useful for <code>VIDEO</code> or <code>TEXT</code> or <code>IMAGE</code> projects only.</p> <ul> <li>For <code>VIDEO</code> projects, each element is a sequence of frames, i.e. a     list of URLs to images or a list of paths to images.</li> <li>For <code>TEXT</code> projects, each element is a json_content dict,     formatted according to documentation on how to import rich-text assets.</li> <li>For <code>IMAGES</code> projects, it is used for satellite imagery each element is a list of json_content dicts     formatted according to documentation [on how to add multi-layer images]     (https://docs.kili-technology.com/docs/adding-assets-to-project#adding-multi-layer-images)</li> </ul> <code>None</code> <code>json_metadata_array</code> <code>Optional[List[dict]]</code> <p>The metadata given to each asset should be stored in a json like dict with keys.</p> <ul> <li>Add metadata visible on the asset     Example for one asset: <code>json_metadata_array = [{'imageUrl': '','text': '','url': '','key1': 'value1'}]</code>.</li> <li>For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30).     Example for one asset: <code>json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]</code>.</li> <li>In Image projects with geoTIFF assets, you can specify the epsg, the <code>minZoom</code> and <code>maxZoom</code> values for the <code>processingParameters</code> key.<ul> <li>The epsg is a number that defines the projection that will be used for the asset. Values that can be used are either 4326 or 3857, the 2 projections that we support. If this number is not set, by default we keep the initial projection of the asset if it is 4326 or 3857, either we reproject the asset to EPSG:3857 by default.</li> <li>The <code>minZoom</code> parameter defines the zoom level that users are not allowed to zoom out from. It also affects the zoom levels for which we generate the tiles when tiling the asset (for asset with size &gt; 30MB).</li> <li>The <code>maxZoom</code> value affects asset generation: the higher the value, the greater the level of details and the size of the asset. It also affects the zoom levels for which we generate the tiles when tiling the asset (for asset with size &gt; 30MB).</li> <li>Example for one asset: <code>json_metadata_array = [{'processingParameters': {'epsg': 3758, 'minZoom': 17, 'maxZoom': 19}}]</code>.</li> </ul> </li> </ul> <code>None</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>None</code> <code>wait_until_availability</code> <code>bool</code> <p>If <code>True</code>, the function will return once the assets are fully imported in Kili. If <code>False</code>, the function will return faster but the assets might not be fully processed by the server.</p> <code>True</code> <code>from_csv</code> <code>Optional[str]</code> <p>Path to a csv file containing the text assets to import. Only used for <code>TEXT</code> projects. If provided, <code>content_array</code> and <code>external_id_array</code> must be None. The csv file header must specify the columns <code>content</code> and <code>externalId</code>.</p> <code>None</code> <code>csv_separator</code> <code>str</code> <p>Separator used in the csv file. Only used if <code>from_csv</code> is provided.</p> <code>','</code> <p>Returns:</p> Type Description <code>A dictionary with two fields</code> <p><code>id</code> which is the project id and <code>asset_ids</code> which is a list of the created asset ids. In the case where assets are uploaded asynchronously (for video imported as frames or big images or tiff images), the method return an empty list of asset ids.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_many_to_dataset(\n        project_id=project_id,\n        content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png'])\n</code></pre> <p>Recipe</p> <ul> <li>For more detailed examples on how to import assets,     see the recipe.</li> <li>For more detailed examples on how to import text assets,     see the recipe.</li> </ul> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>def append_many_to_dataset(\n    self,\n    project_id: str,\n    content_array: Optional[Union[List[str], List[dict], List[List[dict]]]] = None,\n    multi_layer_content_array: Optional[List[List[dict]]] = None,\n    external_id_array: Optional[List[str]] = None,\n    id_array: Optional[List[str]] = None,\n    is_honeypot_array: Optional[List[bool]] = None,\n    status_array: Optional[List[str]] = None,\n    json_content_array: Optional[List[Union[List[Union[dict, str]], None]]] = None,\n    json_metadata_array: Optional[List[dict]] = None,\n    disable_tqdm: Optional[bool] = None,\n    wait_until_availability: bool = True,\n    from_csv: Optional[str] = None,\n    csv_separator: str = \",\",\n) -&gt; Dict[Literal[\"id\", \"asset_ids\"], Union[str, List[str]]]:\n    # pylint: disable=line-too-long\n    \"\"\"Append assets to a project.\n\n    Args:\n        project_id: Identifier of the project\n        content_array: List of elements added to the assets of the project\n            Must not be None except if you provide multi_layer_content_array or json_content_array.\n\n            - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets.\n            - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing\n                images/pdf on your computer.\n            - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to\n            existing video files on your computer. If you want to import video from frames, look at the json_content\n            section below.\n            - For an `VIDEO_LEGACY` project, the content can be only be URLs.\n            - For an `LLM_RLHF` project, the content can be dicts with the keys `prompt` and `completions`,\n            paths to local json files or URLs to json files.\n        multi_layer_content_array: List containing multiple lists of paths.\n            Each path correspond to a layer of a geospatial asset. Should be used only for `IMAGE` and `GEOSPATIAL` projects.\n        external_id_array: List of external ids given to identify the assets.\n            If None, random identifiers are created.\n        id_array: Disabled parameter. Do not use.\n        is_honeypot_array:  Whether to use the asset for honeypot\n        status_array: DEPRECATED and does not have any effect.\n        json_content_array: Useful for `VIDEO` or `TEXT` or `IMAGE` projects only.\n\n            - For `VIDEO` projects, each element is a sequence of frames, i.e. a\n                list of URLs to images or a list of paths to images.\n            - For `TEXT` projects, each element is a json_content dict,\n                formatted according to documentation [on how to import\n            rich-text assets](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/import_text_assets/).\n            - For `IMAGES` projects, it is used for satellite imagery each element is a list of json_content dicts\n                formatted according to documentation [on how to add multi-layer images]\n                (https://docs.kili-technology.com/docs/adding-assets-to-project#adding-multi-layer-images)\n\n        json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys.\n\n            - Add metadata visible on the asset\n                Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': '','key1': 'value1'}]`.\n            - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30).\n                Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`.\n            - In Image projects with geoTIFF assets, you can specify the epsg, the `minZoom` and `maxZoom` values for the `processingParameters` key.\n                - The epsg is a number that defines the projection that will be used for the asset. Values that can be used are either 4326 or 3857, the 2\n                projections that we support. If this number is not set, by default we keep the initial projection of the asset if it is 4326 or 3857, either\n                we reproject the asset to EPSG:3857 by default.\n                - The `minZoom` parameter defines the zoom level that users are not allowed to zoom out from. It also affects the zoom levels for which we\n                generate the tiles when tiling the asset (for asset with size &gt; 30MB).\n                - The `maxZoom` value affects asset generation: the higher the value, the greater the level of details and the size of the asset. It also affects\n                the zoom levels for which we generate the tiles when tiling the asset (for asset with size &gt; 30MB).\n                - Example for one asset: `json_metadata_array = [{'processingParameters': {'epsg': 3758, 'minZoom': 17, 'maxZoom': 19}}]`.\n        disable_tqdm: If `True`, the progress bar will be disabled\n        wait_until_availability: If `True`, the function will return once the assets are fully imported in Kili.\n            If `False`, the function will return faster but the assets might not be fully processed by the server.\n        from_csv: Path to a csv file containing the text assets to import.\n            Only used for `TEXT` projects.\n            If provided, `content_array` and `external_id_array` must be None.\n            The csv file header must specify the columns `content` and `externalId`.\n        csv_separator: Separator used in the csv file. Only used if `from_csv` is provided.\n\n\n    Returns:\n        A dictionary with two fields: `id` which is the project id and `asset_ids` which is a list of the created asset ids.\n        In the case where assets are uploaded asynchronously (for video imported as frames or big images or tiff images), the method return an empty list of asset ids.\n\n    Examples:\n        &gt;&gt;&gt; kili.append_many_to_dataset(\n                project_id=project_id,\n                content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png'])\n\n    !!! example \"Recipe\"\n        - For more detailed examples on how to import assets,\n            see [the recipe](https://docs.kili-technology.com/recipes/importing-data).\n        - For more detailed examples on how to import text assets,\n            see [the recipe](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/import_text_assets/).\n    \"\"\"\n    if from_csv is not None:\n        if content_array is not None or external_id_array is not None:\n            raise ValueError(\n                \"If from_csv is provided, content_array and external_id_array must not be\"\n                \" provided.\"\n            )\n        content_array, external_id_array = get_text_assets_from_csv(\n            from_csv=from_csv, csv_separator=csv_separator\n        )\n\n    if (\n        is_empty_list_with_warning(\"append_many_to_dataset\", \"content_array\", content_array)\n        or is_empty_list_with_warning(\n            \"append_many_to_dataset\", \"json_content_array\", json_content_array\n        )\n        or is_empty_list_with_warning(\n            \"append_many_to_dataset\", \"multi_layer_content_array\", multi_layer_content_array\n        )\n    ):\n        return {\"id\": project_id, \"asset_ids\": []}\n\n    if status_array is not None:\n        warnings.warn(\n            \"status_array is deprecated and will not be sent in the call. Asset status is\"\n            \" automatically computed based on its labels and cannot be overwritten.\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n\n    if (\n        content_array is None\n        and multi_layer_content_array is None\n        and json_content_array is None\n    ):\n        raise ValueError(\n            \"Variables content_array, multi_layer_content_array and json_content_array cannot be both None.\"\n        )\n\n    if content_array is not None and multi_layer_content_array is not None:\n        raise ValueError(\n            \"Variables content_array and multi_layer_content_array cannot be both provided.\"\n        )\n\n    nb_data = (\n        len(content_array)\n        if content_array is not None\n        else (\n            len(multi_layer_content_array)\n            if multi_layer_content_array is not None\n            else len(json_content_array)  # type:ignore\n        )\n    )\n\n    field_mapping = {\n        \"content\": content_array,\n        \"multi_layer_content\": multi_layer_content_array,\n        \"json_content\": json_content_array,\n        \"external_id\": external_id_array,\n        \"id\": id_array,\n        \"json_metadata\": json_metadata_array,\n        \"is_honeypot\": is_honeypot_array,\n    }\n    assets = [{}] * nb_data\n    for key, value in field_mapping.items():\n        if value is not None:\n            assets = [{**assets[i], key: value[i]} for i in range(nb_data)]\n    created_asset_ids = import_assets(\n        self,  # pyright: ignore[reportGeneralTypeIssues]\n        project_id=ProjectId(project_id),\n        assets=assets,\n        disable_tqdm=disable_tqdm,\n        verify=wait_until_availability,\n    )\n    return {\"id\": project_id, \"asset_ids\": created_asset_ids}\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.assign_assets_to_labelers","title":"<code>assign_assets_to_labelers(self, to_be_labeled_by_array, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Assign a list of assets to a list of labelers.</p> <p>Parameters:</p> Name Type Description Default <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The internal asset IDs to assign.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The external asset IDs to assign (if <code>asset_ids</code> is not already provided).</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <code>to_be_labeled_by_array</code> <code>List[List[str]]</code> <p>The array of list of labelers to assign per labelers (list of userIds).</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>A list of dictionaries with the asset ids.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.assign_assets_to_labelers(\n        asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n        to_be_labeled_by_array=[['cm3yja6kv0i698697gcil9rtk','cm3yja6kv0i000000gcil9rtk'],\n                                ['cm3yja6kv0i698697gcil9rtk']]\n    )\n</code></pre> <pre><code># The following call resets the assignees on the asset_ids given.\n</code></pre> <pre><code>&gt;&gt;&gt; kili.assign_assets_to_labelers(\n        asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n        to_be_labeled_by_array=[[], []]\n    )\n</code></pre> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>def assign_assets_to_labelers(\n    self,\n    to_be_labeled_by_array: List[List[str]],\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Assign a list of assets to a list of labelers.\n\n    Args:\n        asset_ids: The internal asset IDs to assign.\n        external_ids: The external asset IDs to assign (if `asset_ids` is not already provided).\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n        to_be_labeled_by_array: The array of list of labelers to assign per labelers (list of userIds).\n\n    Returns:\n        A list of dictionaries with the asset ids.\n\n    Examples:\n        &gt;&gt;&gt; kili.assign_assets_to_labelers(\n                asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                to_be_labeled_by_array=[['cm3yja6kv0i698697gcil9rtk','cm3yja6kv0i000000gcil9rtk'],\n                                        ['cm3yja6kv0i698697gcil9rtk']]\n            )\n\n            # The following call resets the assignees on the asset_ids given.\n        &gt;&gt;&gt; kili.assign_assets_to_labelers(\n                asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                to_be_labeled_by_array=[[], []]\n            )\n    \"\"\"\n    if is_empty_list_with_warning(\n        \"assign_assets_to_labelers\", \"asset_ids\", asset_ids\n    ) and is_empty_list_with_warning(\"assign_assets_to_labelers\", \"external_ids\", external_ids):\n        return []\n\n    if (asset_ids is not None and external_ids is not None) or (\n        asset_ids is None and external_ids is None\n    ):\n        raise MissingArgumentError(\"Please provide either `asset_ids` or `external_ids`.\")\n\n    resolved_asset_ids = self._resolve_asset_ids(asset_ids, external_ids, project_id)\n\n    if len(resolved_asset_ids) != len(to_be_labeled_by_array):\n        raise MutationError(\"There must be as many assets as there are lists of labelers.\")\n\n    formated_results = []\n    for asset_id, to_be_labeled_by in zip(resolved_asset_ids, to_be_labeled_by_array):\n        payload = {\"userIds\": to_be_labeled_by, \"where\": {\"id\": asset_id}}\n        results = self.graphql_client.execute(GQL_ASSIGN_ASSETS, payload)\n        formated_results.append(results)\n    return formated_results\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.change_asset_external_ids","title":"<code>change_asset_external_ids(self, new_external_ids, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Update the external IDs of one or more assets.</p> <p>Parameters:</p> Name Type Description Default <code>new_external_ids</code> <code>List[str]</code> <p>The new external IDs of the assets.</p> required <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The asset IDs to modify.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The external asset IDs to modify (if <code>asset_ids</code> is not already provided).</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[Literal['id'], str]]</code> <p>A list of dictionaries with the asset ids.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.change_asset_external_ids(\n        new_external_ids=[\"asset1\", \"asset2\"],\n        asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n    )\n</code></pre> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>def change_asset_external_ids(\n    self,\n    new_external_ids: List[str],\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; List[Dict[Literal[\"id\"], str]]:\n    \"\"\"Update the external IDs of one or more assets.\n\n    Args:\n        new_external_ids: The new external IDs of the assets.\n        asset_ids: The asset IDs to modify.\n        external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A list of dictionaries with the asset ids.\n\n    Examples:\n        &gt;&gt;&gt; kili.change_asset_external_ids(\n                new_external_ids=[\"asset1\", \"asset2\"],\n                asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n            )\n    \"\"\"\n    if is_empty_list_with_warning(\n        \"change_asset_external_ids\", \"new_external_ids\", new_external_ids\n    ):\n        return []\n\n    resolved_asset_ids = self._resolve_asset_ids(asset_ids, external_ids, project_id)\n\n    properties_to_batch = process_update_properties_in_assets_parameters(\n        asset_ids=cast(List[str], resolved_asset_ids),\n        external_ids=new_external_ids,\n    )\n\n    def generate_variables(batch: Dict) -&gt; Dict:\n        asset_ids = batch.pop(\"assetId\")\n        data_array = [dict(zip(batch, t)) for t in zip(*batch.values())]  # type: ignore\n        return {\n            \"whereArray\": [{\"id\": asset_id} for asset_id in asset_ids],\n            \"dataArray\": data_array,\n        }\n\n    results = mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_UPDATE_PROPERTIES_IN_ASSETS,\n    )\n    formated_results = [self.format_result(\"data\", result, None) for result in results]\n    return [item for batch_list in formated_results for item in batch_list]\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.delete_many_from_dataset","title":"<code>delete_many_from_dataset(self, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Delete assets from a project.</p> <p>Parameters:</p> Name Type Description Default <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The list of asset internal IDs to delete.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The list of asset external IDs to delete.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Dict[Literal['id'], str]]</code> <p>A dict object with the project <code>id</code>.</p> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>def delete_many_from_dataset(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; Optional[Dict[Literal[\"id\"], str]]:\n    \"\"\"Delete assets from a project.\n\n    Args:\n        asset_ids: The list of asset internal IDs to delete.\n        external_ids: The list of asset external IDs to delete.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A dict object with the project `id`.\n    \"\"\"\n    if is_empty_list_with_warning(\n        \"delete_many_from_dataset\", \"asset_ids\", asset_ids\n    ) or is_empty_list_with_warning(\"delete_many_from_dataset\", \"external_ids\", external_ids):\n        return None\n\n    resolved_asset_ids = self._resolve_asset_ids(asset_ids, external_ids, project_id)\n\n    properties_to_batch = {\"asset_ids\": resolved_asset_ids}\n\n    def generate_variables(batch):\n        return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n    @retry(\n        wait=wait_exponential(multiplier=1, min=1, max=8),\n        retry=retry_if_exception_type(MutationError),\n        reraise=True,\n    )\n    def verify_last_batch(last_batch: Dict, results: List) -&gt; None:\n        \"\"\"Check that all assets in the last batch have been deleted.\"\"\"\n        if project_id is not None:\n            project_id_ = project_id\n        # in some case the results is [{'data': None}]\n        elif isinstance(results[0][\"data\"], Dict) and results[0][\"data\"].get(\"id\"):\n            project_id_ = results[0][\"data\"].get(\"id\")\n        else:\n            return\n\n        asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n\n        nb_assets_in_kili = self.kili_api_gateway.count_assets(\n            AssetFilters(\n                project_id=ProjectId(project_id_),\n                asset_id_in=asset_ids,\n            )\n        )\n        if nb_assets_in_kili &gt; 0:\n            raise MutationError(\"Failed to delete some assets.\")\n\n    results = mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_DELETE_MANY_FROM_DATASET,\n        last_batch_callback=verify_last_batch,\n    )\n    return self.format_result(\"data\", results[0])\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.send_back_to_queue","title":"<code>send_back_to_queue(self, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Send assets back to queue.</p> <p>Parameters:</p> Name Type Description Default <code>asset_ids</code> <code>Optional[List[str]]</code> <p>List of internal IDs of assets to send back to queue.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>List of external IDs of assets to send back to queue.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>A dict object with the project <code>id</code> and the <code>asset_ids</code> of assets moved to queue. An error message if mutation failed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.send_back_to_queue(\n        asset_ids=[\n            \"ckg22d81r0jrg0885unmuswj8\",\n            \"ckg22d81s0jrh0885pdxfd03n\",\n            ],\n    )\n</code></pre> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>def send_back_to_queue(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Send assets back to queue.\n\n    Args:\n        asset_ids: List of internal IDs of assets to send back to queue.\n        external_ids: List of external IDs of assets to send back to queue.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A dict object with the project `id` and the `asset_ids` of assets moved to queue.\n        An error message if mutation failed.\n\n    Examples:\n        &gt;&gt;&gt; kili.send_back_to_queue(\n                asset_ids=[\n                    \"ckg22d81r0jrg0885unmuswj8\",\n                    \"ckg22d81s0jrh0885pdxfd03n\",\n                    ],\n            )\n    \"\"\"\n    if is_empty_list_with_warning(\n        \"send_back_to_queue\", \"asset_ids\", asset_ids\n    ) or is_empty_list_with_warning(\"send_back_to_queue\", \"external_ids\", external_ids):\n        return None\n\n    resolved_asset_ids = self._resolve_asset_ids(asset_ids, external_ids, project_id)\n\n    properties_to_batch = {\"asset_ids\": resolved_asset_ids}\n\n    def generate_variables(batch):\n        return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n    @retry(\n        wait=wait_exponential(multiplier=1, min=1, max=8),\n        retry=retry_if_exception_type(MutationError),\n        reraise=True,\n    )\n    def verify_last_batch(last_batch: Dict, results: List) -&gt; None:\n        \"\"\"Check that all assets in the last batch have been sent back to queue.\"\"\"\n        if project_id is not None:\n            project_id_ = project_id\n        # in some case the results is [{'data': None}]\n        elif isinstance(results[0][\"data\"], Dict) and results[0][\"data\"].get(\"id\"):\n            project_id_ = results[0][\"data\"].get(\"id\")\n        else:\n            return\n\n        asset_ids = last_batch[\"asset_ids\"][-1:]  # check lastest asset of the batch only\n        nb_assets_in_queue = self.kili_api_gateway.count_assets(\n            AssetFilters(\n                project_id=ProjectId(project_id_),\n                asset_id_in=asset_ids,\n                status_in=[\"ONGOING\"],\n            )\n        )\n        if len(asset_ids) != nb_assets_in_queue:\n            raise MutationError(\"Failed to send some assets back to queue\")\n\n    results = mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_SEND_BACK_ASSETS_TO_QUEUE,\n        last_batch_callback=verify_last_batch,\n    )\n    result = self.format_result(\"data\", results[0])\n    if isinstance(result, dict) and \"id\" in result:\n        assets_in_queue = self.kili_api_gateway.list_assets(\n            AssetFilters(\n                project_id=result[\"id\"],\n                asset_id_in=resolved_asset_ids,\n                status_in=[\"ONGOING\"],\n            ),\n            [\"id\"],\n            QueryOptions(disable_tqdm=True),\n        )\n        result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_queue]\n    return result\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.set_metadata","title":"<code>set_metadata(self, json_metadata, project_id, asset_ids=None, external_ids=None)</code>","text":"<p>Set metadata on assets, replacing any existing metadata.</p> <p>Parameters:</p> Name Type Description Default <code>json_metadata</code> <code>List[Dict[str, Union[str, int, float]]]</code> <p>List of metadata dictionaries to set on each asset. Each dictionary contains key/value pairs to be set as the asset's metadata.</p> required <code>project_id</code> <code>str</code> <p>The project ID.</p> required <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The asset IDs to modify (if <code>external_ids</code> is not already provided).</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The external asset IDs to modify (if <code>asset_ids</code> is not already provided).</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[Literal['id'], str]]</code> <p>A list of dictionaries with the asset ids.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.set_metadata(\n        json_metadata=[\n            {\"key1\": \"value1\", \"key2\": \"value2\"},\n            {\"key3\": \"value3\"}\n        ],\n        project_id=\"cm92to3cx012u7l0w6kij9qvx\"\n        asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"]\n    )\n</code></pre> <pre><code># Or using external IDs\n</code></pre> <pre><code>&gt;&gt;&gt; kili.set_metadata(\n        json_metadata=[\n            {\"key1\": \"value1\", \"key2\": \"value2\"},\n            {\"key3\": \"value3\"}\n        ],\n        project_id=\"cm92to3cx012u7l0w6kij9qvx\",\n        external_ids=[\"asset1\", \"asset2\"]\n    )\n</code></pre> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>def set_metadata(\n    self,\n    json_metadata: List[Dict[str, Union[str, int, float]]],\n    project_id: str,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n) -&gt; List[Dict[Literal[\"id\"], str]]:\n    \"\"\"Set metadata on assets, replacing any existing metadata.\n\n    Args:\n        json_metadata: List of metadata dictionaries to set on each asset.\n            Each dictionary contains key/value pairs to be set as the asset's metadata.\n        project_id: The project ID.\n        asset_ids: The asset IDs to modify (if `external_ids` is not already provided).\n        external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n\n    Returns:\n        A list of dictionaries with the asset ids.\n\n    Examples:\n        &gt;&gt;&gt; kili.set_metadata(\n                json_metadata=[\n                    {\"key1\": \"value1\", \"key2\": \"value2\"},\n                    {\"key3\": \"value3\"}\n                ],\n                project_id=\"cm92to3cx012u7l0w6kij9qvx\"\n                asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"]\n            )\n\n            # Or using external IDs\n        &gt;&gt;&gt; kili.set_metadata(\n                json_metadata=[\n                    {\"key1\": \"value1\", \"key2\": \"value2\"},\n                    {\"key3\": \"value3\"}\n                ],\n                project_id=\"cm92to3cx012u7l0w6kij9qvx\",\n                external_ids=[\"asset1\", \"asset2\"]\n            )\n    \"\"\"\n    if is_empty_list_with_warning(\"set_metadata\", \"json_metadata\", json_metadata):\n        return []\n\n    if (asset_ids is not None and external_ids is not None) or (\n        asset_ids is None and external_ids is None\n    ):\n        raise MissingArgumentError(\"Please provide either `asset_ids` or `external_ids`.\")\n\n    assets = self.kili_api_gateway.list_assets(\n        AssetFilters(\n            project_id=ProjectId(project_id),\n            asset_id_in=cast(List[AssetId], asset_ids),\n            external_id_in=cast(List[AssetExternalId], external_ids),\n        ),\n        [\"id\", \"jsonMetadata\"],\n        QueryOptions(disable_tqdm=True),\n    )\n\n    resolved_asset_ids = []\n    json_metadatas = []\n    for i, asset in enumerate(assets):\n        current_metadata = asset.get(\"jsonMetadata\", {}) if asset.get(\"jsonMetadata\") else {}\n        new_metadata = json_metadata[i] if i &lt; len(json_metadata) else {}\n\n        special_keys = [\"text\", \"imageUrl\", \"url\", \"processingParameters\"]\n        preserved_metadata = {\n            k: current_metadata[k] for k in special_keys if k in current_metadata\n        }\n\n        preserved_metadata.update(new_metadata)\n\n        json_metadatas.append(preserved_metadata)\n        resolved_asset_ids.append(asset[\"id\"])\n\n    return self.update_properties_in_assets(\n        asset_ids=cast(List[str], resolved_asset_ids),\n        json_metadatas=json_metadatas,\n    )\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.skip_or_unskip","title":"<code>skip_or_unskip(self, action, asset_id, project_id, reason=None)</code>","text":"<p>Skip or unskip an asset.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>Literal['skip', 'unskip']</code> <p>The action you want to do. Either skip or unskip.</p> required <code>asset_id</code> <code>str</code> <p>ID of the asset you want to skip or unskip.</p> required <code>project_id</code> <code>str</code> <p>The project ID.</p> required <code>reason</code> <code>Optional[str]</code> <p>The reason why you skip an asset. Only required if the action is <code>skip</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The asset ID of the asset modified. An error message if mutation failed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.skip_or_unskip(\naction=\"skip\",\nasset_id=\"ckg22d81s0jrh0885pdxfd03n\",\nproject_id=\"ckg22d81r0jrg0885unmuswj8\",\nreason=\"Test\"\n)\n</code></pre> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>def skip_or_unskip(\n    self,\n    action: Literal[\"skip\", \"unskip\"],\n    asset_id: str,\n    project_id: str,\n    reason: Optional[str] = None,\n) -&gt; str:\n    \"\"\"Skip or unskip an asset.\n\n    Args:\n        action: The action you want to do. Either skip or unskip.\n        asset_id: ID of the asset you want to skip or unskip.\n        project_id: The project ID.\n        reason: The reason why you skip an asset. Only required if the action is `skip`.\n\n    Returns:\n        The asset ID of the asset modified. An error message if mutation failed.\n\n    Examples:\n        &gt;&gt;&gt; kili.skip_or_unskip(\n        action=\"skip\",\n        asset_id=\"ckg22d81s0jrh0885pdxfd03n\",\n        project_id=\"ckg22d81r0jrg0885unmuswj8\",\n        reason=\"Test\"\n        )\n    \"\"\"\n    if action == \"skip\":\n        if reason is None:\n            raise MissingArgumentError(\"You must provide a reason to skip an asset\")\n        payload = {\"reason\": reason, \"where\": {\"id\": asset_id, \"project\": {\"id\": project_id}}}\n        self.graphql_client.execute(GQL_SKIP_ASSET, payload)\n    else:\n        payload = {\"projectId\": project_id, \"assetId\": asset_id}\n        self.graphql_client.execute(GQL_UNSKIP_ASSET, payload)\n    return asset_id\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.update_properties_in_assets","title":"<code>update_properties_in_assets(self, asset_ids=None, external_ids=None, priorities=None, json_metadatas=None, consensus_marks=None, honeypot_marks=None, to_be_labeled_by_array=None, contents=None, json_contents=None, status_array=None, is_used_for_consensus_array=None, is_honeypot_array=None, project_id=None, resolution_array=None, page_resolutions_array=None)</code>","text":"<p>Update the properties of one or more assets.</p> <p>Parameters:</p> Name Type Description Default <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The internal asset IDs to modify.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The external asset IDs to modify (if <code>asset_ids</code> is not already provided).</p> <code>None</code> <code>priorities</code> <code>Optional[List[int]]</code> <p>You can change the priority of the assets. By default, all assets have a priority of 0.</p> <code>None</code> <code>json_metadatas</code> <code>Optional[List[Union[dict, str]]]</code> <p>The metadata given to an asset should be stored in a json like dict with keys <code>imageUrl</code>, <code>text</code>, <code>url</code>: <code>json_metadata = {'imageUrl': '','text': '','url': ''}</code></p> <code>None</code> <code>consensus_marks</code> <code>Optional[List[float]]</code> <p>Should be between 0 and 1.</p> <code>None</code> <code>honeypot_marks</code> <code>Optional[List[float]]</code> <p>Should be between 0 and 1.</p> <code>None</code> <code>to_be_labeled_by_array</code> <code>Optional[List[List[str]]]</code> <p>If given, each element of the list should contain the emails of the labelers authorized to label the asset.</p> <code>None</code> <code>contents</code> <code>Optional[List[str]]</code> <ul> <li>For a NLP project, the content can be directly in text format.</li> <li>For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs.</li> </ul> <code>None</code> <code>json_contents</code> <code>Optional[List[str]]</code> <ul> <li>For a NLP project, the <code>json_content</code> is a text formatted using RichText.</li> <li>For a Video project, the<code>json_content</code> is a json containg urls pointing     to each frame of the video.</li> </ul> <code>None</code> <code>status_array</code> <code>Optional[List[str]]</code> <p>DEPRECATED and does not have any effect.</p> <code>None</code> <code>is_used_for_consensus_array</code> <code>Optional[List[bool]]</code> <p>Whether to use the asset to compute consensus kpis or not.</p> <code>None</code> <code>is_honeypot_array</code> <code>Optional[List[bool]]</code> <p>Whether to use the asset for honeypot.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <code>resolution_array</code> <code>Optional[List[Dict]]</code> <p>The resolution of each asset (for image and video assets). Each resolution must be passed as a dictionary with keys <code>width</code> and <code>height</code>.</p> <code>None</code> <code>page_resolutions_array</code> <code>Union[List[List[dict]], List[List[kili.utils.assets.PageResolution]]]</code> <p>The resolution of each page of the asset (for PDF assets). Note that each element of the array should contain all the pages resolutions of the corresponding asset. Each resolution can be passed as a <code>kili.utils.assets.PageResolution</code> object, or as a dictionary with keys <code>width</code>, <code>height</code>, <code>pageNumber</code> and optionally <code>rotation</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[Literal['id'], str]]</code> <p>A list of dictionaries with the asset ids.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_properties_in_assets(\n        asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n        consensus_marks=[1, 0.7],\n        contents=[None, 'https://to/second/asset.png'],\n        honeypot_marks=[0.8, 0.5],\n        is_honeypot_array=[True, True],\n        is_used_for_consensus_array=[True, False],\n        priorities=[None, 2],\n        to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None],\n    )\n</code></pre> <pre><code># The following call updates the pages resolutions of PDF assets.\n</code></pre> <pre><code>&gt;&gt;&gt; kili.update_properties_in_assets(\n        asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n        page_resolutions_array=[\n            [\n                PageResolution(width=480, height=640, page_number=1),\n                PageResolution(width=480, height=640, page_number=2),\n            ],[\n                PageResolution(width=340, height=512, page_number=1),\n                PageResolution(width=680, height=1024, page_number=2, rotation=90),\n                PageResolution(width=680, height=1024, page_number=3),\n            ]\n        ],\n    )\n</code></pre> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>def update_properties_in_assets(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    priorities: Optional[List[int]] = None,\n    json_metadatas: Optional[List[Union[dict, str]]] = None,\n    consensus_marks: Optional[List[float]] = None,\n    honeypot_marks: Optional[List[float]] = None,\n    to_be_labeled_by_array: Optional[List[List[str]]] = None,\n    contents: Optional[List[str]] = None,\n    json_contents: Optional[List[str]] = None,\n    status_array: Optional[List[str]] = None,\n    is_used_for_consensus_array: Optional[List[bool]] = None,\n    is_honeypot_array: Optional[List[bool]] = None,\n    project_id: Optional[str] = None,\n    resolution_array: Optional[List[Dict]] = None,\n    page_resolutions_array: Optional[\n        Union[List[List[dict]], List[List[PageResolution]]]\n    ] = None,\n) -&gt; List[Dict[Literal[\"id\"], str]]:\n    \"\"\"Update the properties of one or more assets.\n\n    Args:\n        asset_ids: The internal asset IDs to modify.\n        external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n        priorities: You can change the priority of the assets.\n            By default, all assets have a priority of 0.\n        json_metadatas: The metadata given to an asset should be stored\n            in a json like dict with keys `imageUrl`, `text`, `url`:\n            `json_metadata = {'imageUrl': '','text': '','url': ''}`\n        consensus_marks: Should be between 0 and 1.\n        honeypot_marks: Should be between 0 and 1.\n        to_be_labeled_by_array: If given, each element of the list should contain the emails of\n            the labelers authorized to label the asset.\n        contents: - For a NLP project, the content can be directly in text format.\n            - For an Image / Video / Pdf project, the content must be hosted on a web server,\n            and you point Kili to your data by giving the URLs.\n        json_contents: - For a NLP project, the `json_content`\n            is a text formatted using RichText.\n            - For a Video project, the`json_content` is a json containg urls pointing\n                to each frame of the video.\n        status_array: DEPRECATED and does not have any effect.\n        is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not.\n        is_honeypot_array: Whether to use the asset for honeypot.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n        resolution_array: The resolution of each asset (for image and video assets).\n            Each resolution must be passed as a dictionary with keys `width` and `height`.\n        page_resolutions_array: The resolution of each page of the asset (for PDF assets).\n            Note that each element of the array should contain all the pages resolutions of the\n            corresponding asset. Each resolution can be passed as a\n            `kili.utils.assets.PageResolution` object, or as a dictionary with keys `width`,\n            `height`, `pageNumber` and optionally `rotation`.\n\n    Returns:\n        A list of dictionaries with the asset ids.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_properties_in_assets(\n                asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                consensus_marks=[1, 0.7],\n                contents=[None, 'https://to/second/asset.png'],\n                honeypot_marks=[0.8, 0.5],\n                is_honeypot_array=[True, True],\n                is_used_for_consensus_array=[True, False],\n                priorities=[None, 2],\n                to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None],\n            )\n\n            # The following call updates the pages resolutions of PDF assets.\n        &gt;&gt;&gt; kili.update_properties_in_assets(\n                asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                page_resolutions_array=[\n                    [\n                        PageResolution(width=480, height=640, page_number=1),\n                        PageResolution(width=480, height=640, page_number=2),\n                    ],[\n                        PageResolution(width=340, height=512, page_number=1),\n                        PageResolution(width=680, height=1024, page_number=2, rotation=90),\n                        PageResolution(width=680, height=1024, page_number=3),\n                    ]\n                ],\n            )\n    \"\"\"\n    if is_empty_list_with_warning(\n        \"update_properties_in_assets\", \"asset_ids\", asset_ids\n    ) or is_empty_list_with_warning(\n        \"update_properties_in_assets\", \"external_ids\", external_ids\n    ):\n        return []\n\n    if status_array is not None:\n        warnings.warn(\n            \"status_array is deprecated and will not be sent in the call. Asset status is\"\n            \" automatically computed based on its labels and cannot be overwritten.\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n    if asset_ids is not None and external_ids is not None:\n        warnings.warn(\n            \"The use of `external_ids` argument has changed. It is now used to identify\"\n            \" which properties of which assets to update. Please use\"\n            \" `kili.change_asset_external_ids()` method instead to change asset external\"\n            \" IDs.\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n        raise MissingArgumentError(\"Please provide either `asset_ids` or `external_ids`.\")\n\n    if to_be_labeled_by_array is not None:\n        warnings.warn(\n            \"to_be_labeled_by_array is going to be deprecated. Please use\"\n            \" `kili.assign_assets_to_labelers()` method instead to assign assets\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n\n    resolved_asset_ids = self._resolve_asset_ids(asset_ids, external_ids, project_id)\n\n    properties_to_batch = process_update_properties_in_assets_parameters(\n        cast(List[str], resolved_asset_ids),\n        priorities=priorities,\n        json_metadatas=json_metadatas,\n        consensus_marks=consensus_marks,\n        honeypot_marks=honeypot_marks,\n        to_be_labeled_by_array=to_be_labeled_by_array,\n        contents=contents,\n        json_contents=json_contents,\n        is_used_for_consensus_array=is_used_for_consensus_array,\n        is_honeypot_array=is_honeypot_array,\n        resolution_array=resolution_array,\n        page_resolutions_array=page_resolutions_array,\n    )\n\n    def generate_variables(batch: Dict) -&gt; Dict:\n        asset_ids = batch.pop(\"assetId\")\n        data_array = [dict(zip(batch, t)) for t in zip(*batch.values())]  # type: ignore\n        return {\n            \"whereArray\": [{\"id\": asset_id} for asset_id in asset_ids],\n            \"dataArray\": data_array,\n        }\n\n    results = mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_UPDATE_PROPERTIES_IN_ASSETS,\n    )\n    formated_results = [self.format_result(\"data\", result, None) for result in results]\n    return [item for batch_list in formated_results for item in batch_list]\n</code></pre>"},{"location":"sdk/cloud_storage/","title":"Cloud storage module","text":"<p>Alpha feature</p> <p>The cloud storage feature is currently in alpha. It is still under active development: methods and behaviors can still evolve until the feature is complete.</p> <p>Cloud Storage Integration and Connection</p> <p>A cloud storage integration is a connection between a Kili organization and a cloud storage (AWS, GCP or Azure). Once a cloud storage integration is created, it can be used in any project of the organization. Adding a cloud storage integration from the SDK is currently not supported. More information about how to create a cloud storage integration can be found here.</p> <p>A cloud storage connection is a cloud storage integration used in a Kili project. It is used to import data from a cloud storage to a project. More information about how to use a cloud storage integration in a project can be found here.</p> <p>Azure</p> <p>It is recommended to install the Azure dependencies to use the Azure cloud storage integration and connection. <pre><code>pip install kili[azure]\n</code></pre></p> <p>Methods attached to the Kili client, to run actions on cloud storage.</p> Source code in <code>kili/presentation/client/cloud_storage.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass CloudStorageClientMethods(BaseClientMethods):\n    \"\"\"Methods attached to the Kili client, to run actions on cloud storage.\"\"\"\n\n    @overload\n    def cloud_storage_connections(\n        self,\n        cloud_storage_connection_id: Optional[str] = None,\n        cloud_storage_integration_id: Optional[str] = None,\n        project_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"id\",\n            \"lastCheck\",\n            \"numberOfAssets\",\n            \"selectedFolders\",\n            \"projectId\",\n        ),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def cloud_storage_connections(\n        self,\n        cloud_storage_connection_id: Optional[str] = None,\n        cloud_storage_integration_id: Optional[str] = None,\n        project_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"id\",\n            \"lastCheck\",\n            \"numberOfAssets\",\n            \"selectedFolders\",\n            \"projectId\",\n        ),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def cloud_storage_connections(\n        self,\n        cloud_storage_connection_id: Optional[str] = None,\n        cloud_storage_integration_id: Optional[str] = None,\n        project_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"id\",\n            \"lastCheck\",\n            \"numberOfAssets\",\n            \"selectedFolders\",\n            \"projectId\",\n        ),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a generator or a list of cloud storage connections that match a set of criteria.\n\n        Args:\n            cloud_storage_connection_id: ID of the cloud storage connection.\n            cloud_storage_integration_id: ID of the cloud storage integration.\n            project_id: ID of the project.\n            fields: All the fields to request among the possible fields for the cloud storage connections.\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/data-connection) for all possible fields.\n            first: Maximum number of cloud storage connections to return.\n            skip: Number of skipped cloud storage connections.\n            disable_tqdm: If `True`, the progress bar will be disabled.\n            as_generator: If `True`, a generator on the cloud storage connections is returned.\n\n        Returns:\n            A list or a generator of the cloud storage connections that match the criteria.\n\n        Examples:\n            &gt;&gt;&gt; kili.cloud_storage_connections(project_id=\"789465123\")\n            [{'id': '123456789', 'lastCheck': '2023-02-21T14:49:35.606Z', 'numberOfAssets': 42, 'selectedFolders': ['folder1', 'folder2'], 'projectId': '789465123'}]\n        \"\"\"\n        if (\n            cloud_storage_connection_id is None\n            and cloud_storage_integration_id is None\n            and project_id is None\n        ):\n            raise ValueError(\n                \"At least one of cloud_storage_connection_id, cloud_storage_integration_id or\"\n                \" project_id must be specified\"\n            )\n\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n\n        cloud_storage_use_cases = CloudStorageUseCases(self.kili_api_gateway)\n\n        if cloud_storage_connection_id is None:\n            data_connections_gen = cloud_storage_use_cases.list_data_connections(\n                data_connection_filters=DataConnectionFilters(\n                    project_id=ProjectId(project_id) if project_id is not None else None,\n                    integration_id=(\n                        DataIntegrationId(cloud_storage_integration_id)\n                        if cloud_storage_integration_id is not None\n                        else None\n                    ),\n                ),\n                fields=fields,\n                options=QueryOptions(disable_tqdm, first, skip),\n            )\n        else:\n            data_connections_gen = (\n                i\n                for i in [\n                    cloud_storage_use_cases.get_data_connection(\n                        DataConnectionId(cloud_storage_connection_id), fields=fields\n                    )\n                ]\n            )\n\n        if as_generator:\n            return data_connections_gen\n        return list(data_connections_gen)\n\n    @overload\n    def cloud_storage_integrations(\n        self,\n        cloud_storage_integration_id: Optional[str] = None,\n        name: Optional[str] = None,\n        platform: Optional[DataIntegrationPlatform] = None,\n        status: Optional[DataIntegrationStatus] = None,\n        organization_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\"name\", \"id\", \"platform\", \"status\"),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def cloud_storage_integrations(\n        self,\n        cloud_storage_integration_id: Optional[str] = None,\n        name: Optional[str] = None,\n        platform: Optional[DataIntegrationPlatform] = None,\n        status: Optional[DataIntegrationStatus] = None,\n        organization_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\"name\", \"id\", \"platform\", \"status\"),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def cloud_storage_integrations(\n        self,\n        cloud_storage_integration_id: Optional[str] = None,\n        name: Optional[str] = None,\n        platform: Optional[DataIntegrationPlatform] = None,\n        status: Optional[DataIntegrationStatus] = None,\n        organization_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\"name\", \"id\", \"platform\", \"status\"),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a generator or a list of cloud storage integrations that match a set of criteria.\n\n        Args:\n            cloud_storage_integration_id: ID of the cloud storage integration.\n            name: Name of the cloud storage integration.\n            platform: Platform of the cloud storage integration.\n            status: Status of the cloud storage integration.\n            organization_id: ID of the organization.\n            fields: All the fields to request among the possible fields for the cloud storage integrations.\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/data-integration) for all possible fields.\n            first: Maximum number of cloud storage integrations to return.\n            skip: Number of skipped cloud storage integrations.\n            disable_tqdm: If `True`, the progress bar will be disabled.\n            as_generator: If `True`, a generator on the cloud storage integrations is returned.\n\n        Returns:\n            A list or a generator of the cloud storage integrations that match the criteria.\n\n        Examples:\n            &gt;&gt;&gt; kili.cloud_storage_integrations()\n            [{'name': 'My bucket', 'id': '123456789', 'platform': 'AWS', 'status': 'CONNECTED'}]\n        \"\"\"\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        data_integrations_gen = CloudStorageUseCases(self.kili_api_gateway).list_data_integrations(\n            data_integration_filters=DataIntegrationFilters(\n                status=status,\n                id=(\n                    DataIntegrationId(cloud_storage_integration_id)\n                    if cloud_storage_integration_id is not None\n                    else None\n                ),\n                name=name,\n                platform=platform,\n                organization_id=(\n                    OrganizationId(organization_id) if organization_id is not None else None\n                ),\n            ),\n            fields=fields,\n            options=options,\n        )\n\n        if as_generator:\n            return data_integrations_gen\n        return list(data_integrations_gen)\n\n    @typechecked\n    def count_cloud_storage_integrations(\n        self,\n        cloud_storage_integration_id: Optional[str] = None,\n        name: Optional[str] = None,\n        platform: Optional[DataIntegrationPlatform] = None,\n        status: Optional[DataIntegrationStatus] = None,\n        organization_id: Optional[str] = None,\n    ) -&gt; int:\n        \"\"\"Count and return the number of cloud storage integrations that match a set of criteria.\n\n        Args:\n            cloud_storage_integration_id: ID of the cloud storage integration.\n            name: Name of the cloud storage integration.\n            platform: Platform of the cloud storage integration.\n            status: Status of the cloud storage integration.\n            organization_id: ID of the organization.\n\n        Returns:\n            The number of cloud storage integrations that match the criteria.\n        \"\"\"\n        return CloudStorageUseCases(self.kili_api_gateway).count_data_integrations(\n            DataIntegrationFilters(\n                status=status,\n                id=(\n                    DataIntegrationId(cloud_storage_integration_id)\n                    if cloud_storage_integration_id is not None\n                    else None\n                ),\n                name=name,\n                platform=platform,\n                organization_id=(\n                    OrganizationId(organization_id) if organization_id is not None else None\n                ),\n            )\n        )\n\n    @typechecked\n    def add_cloud_storage_connection(\n        self,\n        project_id: str,\n        cloud_storage_integration_id: str,\n        selected_folders: Optional[List[str]] = None,\n        prefix: Optional[str] = None,\n        include: Optional[List[str]] = None,\n        exclude: Optional[List[str]] = None,\n    ) -&gt; Dict:\n        \"\"\"Connect a cloud storage to a project. More details about parameters\n        can be found in the [documentation](https://docs.kili-technology.com/docs/filtering-assets-from-cloud-storage).\n\n        Args:\n            project_id: Id of the project.\n            cloud_storage_integration_id: Id of the cloud storage integration.\n            selected_folders: List of folders of the data integration to connect to the project.\n                If not provided, all folders of the data integration will be connected.\n                This option is deprecated and will be removed in the future.\n            prefix: Filter files to synchronize based on their base path.\n            include: List of pattern used to include files based on their path.\n            exclude: List of pattern used to exclude files based on their path.\n\n        Returns:\n            A dict with the DataConnection Id.\n        \"\"\"\n        if selected_folders is not None:\n            logger.warning(\n                \"The selected_folders argument is deprecated and will be removed in the future.\"\n            )\n\n        data_connection_id = CloudStorageUseCases(self.kili_api_gateway).add_data_connection(\n            project_id=ProjectId(project_id),\n            data_integration_id=DataIntegrationId(cloud_storage_integration_id),\n            selected_folders=selected_folders,\n            fields=(\"id\",),\n            prefix=prefix,\n            include=include,\n            exclude=exclude,\n        )[\"id\"]\n\n        return {\"id\": data_connection_id}\n\n    @typechecked\n    def synchronize_cloud_storage_connection(\n        self,\n        cloud_storage_connection_id: str,\n        delete_extraneous_files: bool = False,\n        dry_run: bool = False,\n    ) -&gt; Dict:\n        \"\"\"Synchronize a cloud storage connection.\n\n        This method will compute differences between the cloud storage connection and the project,\n            and then validate the differences.\n\n        If `delete_extraneous_files` is True, it will also delete files that are not in the\n            cloud storage integration anymore but that are still in the project.\n\n        Args:\n            cloud_storage_connection_id: Id of the cloud storage connection.\n            delete_extraneous_files: If True, delete extraneous files.\n            dry_run: If True, will not synchronize the data connection but only print the\n                differences. This is useful to check the differences before applying them to the\n                project.\n\n        Returns:\n            A dict with the cloud storage connection Id.\n        \"\"\"\n        data_connection_id = DataConnectionId(cloud_storage_connection_id)\n\n        cloud_storage_use_cases = CloudStorageUseCases(self.kili_api_gateway)\n\n        cloud_storage_use_cases.synchronize_data_connection(\n            data_connection_id=data_connection_id,\n            delete_extraneous_files=delete_extraneous_files,\n            dry_run=dry_run,\n            logger=logger,\n        )\n\n        return cloud_storage_use_cases.get_data_connection(\n            data_connection_id=data_connection_id, fields=(\"numberOfAssets\", \"projectId\")\n        )\n\n    @typechecked\n    def create_cloud_storage_integration(\n        self,\n        platform: DataIntegrationPlatform,\n        name: str,\n        fields: ListOrTuple[str] = (\n            \"id\",\n            \"name\",\n            \"status\",\n            \"platform\",\n            \"allowedPaths\",\n        ),\n        allowed_paths: Optional[List[str]] = None,\n        allowed_projects: Optional[List[str]] = None,\n        aws_access_point_arn: Optional[str] = None,\n        aws_role_arn: Optional[str] = None,\n        aws_role_external_id: Optional[str] = None,\n        azure_connection_url: Optional[str] = None,\n        azure_is_using_service_credentials: Optional[bool] = None,\n        azure_sas_token: Optional[str] = None,\n        azure_tenant_id: Optional[str] = None,\n        gcp_bucket_name: Optional[str] = None,\n        include_root_files: Optional[str] = None,\n        internal_processing_authorized: Optional[str] = None,\n        s3_access_key: Optional[str] = None,\n        s3_bucket_name: Optional[str] = None,\n        s3_endpoint: Optional[str] = None,\n        s3_region: Optional[str] = None,\n        s3_secret_key: Optional[str] = None,\n        s3_session_token: Optional[str] = None,\n    ) -&gt; Dict:\n        # pylint: disable=line-too-long\n        \"\"\"Create a cloud storage integration.\n\n        Args:\n            fields: All the fields to request among the possible fields for the cloud storage integration.\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/data-integration) for all possible fields.\n            allowed_paths: List of allowed paths.\n            allowed_projects: List of allowed projects.\n            aws_access_point_arn: AWS access point ARN.\n            aws_role_arn: AWS role ARN.\n            aws_role_external_id: AWS role external ID.\n            azure_connection_url: Azure connection URL.\n            azure_is_using_service_credentials: Whether Azure is using service credentials.\n            azure_sas_token: Azure SAS token.\n            azure_tenant_id: Azure tenant ID.\n            gcp_bucket_name: GCP bucket name.\n            include_root_files: Whether to include root files.\n            internal_processing_authorized: Whether internal processing is authorized.\n            name: Name of the cloud storage integration.\n            platform: Platform of the cloud storage integration.\n            s3_access_key: S3 access key.\n            s3_bucket_name: S3 bucket name.\n            s3_endpoint: S3 endpoint.\n            s3_region: S3 region.\n            s3_secret_key: S3 secret key.\n            s3_session_token: S3 session token.\n        \"\"\"\n        cloud_storage_use_cases = CloudStorageUseCases(self.kili_api_gateway)\n\n        return cloud_storage_use_cases.create_data_integration(\n            platform=platform,\n            name=name,\n            fields=fields,\n            allowed_paths=allowed_paths,\n            allowed_projects=allowed_projects,\n            aws_access_point_arn=aws_access_point_arn,\n            aws_role_arn=aws_role_arn,\n            aws_role_external_id=aws_role_external_id,\n            azure_connection_url=azure_connection_url,\n            azure_is_using_service_credentials=azure_is_using_service_credentials,\n            azure_sas_token=azure_sas_token,\n            azure_tenant_id=azure_tenant_id,\n            gcp_bucket_name=gcp_bucket_name,\n            include_root_files=include_root_files,\n            internal_processing_authorized=internal_processing_authorized,\n            s3_access_key=s3_access_key,\n            s3_bucket_name=s3_bucket_name,\n            s3_endpoint=s3_endpoint,\n            s3_region=s3_region,\n            s3_secret_key=s3_secret_key,\n            s3_session_token=s3_session_token,\n        )\n\n    @typechecked\n    def update_cloud_storage_integration(\n        self,\n        cloud_storage_integration_id: str,\n        allowed_paths: Optional[List[str]] = None,\n        allowed_projects: Optional[List[str]] = None,\n        aws_access_point_arn: Optional[str] = None,\n        aws_role_arn: Optional[str] = None,\n        aws_role_external_id: Optional[str] = None,\n        azure_connection_url: Optional[str] = None,\n        azure_is_using_service_credentials: Optional[bool] = None,\n        azure_sas_token: Optional[str] = None,\n        azure_tenant_id: Optional[str] = None,\n        gcp_bucket_name: Optional[str] = None,\n        include_root_files: Optional[str] = None,\n        internal_processing_authorized: Optional[str] = None,\n        name: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        platform: Optional[DataIntegrationPlatform] = None,\n        status: Optional[DataIntegrationStatus] = None,\n        s3_access_key: Optional[str] = None,\n        s3_bucket_name: Optional[str] = None,\n        s3_endpoint: Optional[str] = None,\n        s3_region: Optional[str] = None,\n        s3_secret_key: Optional[str] = None,\n        s3_session_token: Optional[str] = None,\n    ) -&gt; Dict:\n        \"\"\"Update cloud storage data integration.\n\n        Args:\n            allowed_paths: List of allowed paths.\n            allowed_projects: List of allowed projects.\n            aws_access_point_arn: AWS access point ARN.\n            aws_role_arn: AWS role ARN.\n            aws_role_external_id: AWS role external ID.\n            azure_connection_url: Azure connection URL.\n            azure_is_using_service_credentials: Whether Azure is using service credentials.\n            azure_sas_token: Azure SAS token.\n            azure_tenant_id: Azure tenant ID.\n            cloud_storage_integration_id: Data integration ID.\n            gcp_bucket_name: GCP bucket name.\n            include_root_files: Whether to include root files.\n            internal_processing_authorized: Whether internal processing is authorized.\n            organization_id: Organization ID.\n            name: Name of the cloud storage integration.\n            platform: Platform of the cloud storage integration.\n            status: Status of the cloud storage integration.\n            s3_access_key: S3 access key.\n            s3_bucket_name: S3 bucket name.\n            s3_endpoint: S3 endpoint.\n            s3_region: S3 region.\n            s3_secret_key: S3 secret key.\n            s3_session_token: S3 session token.\n        \"\"\"\n        return CloudStorageUseCases(self.kili_api_gateway).update_data_integration(\n            data_integration_id=DataIntegrationId(cloud_storage_integration_id),\n            name=name,\n            platform=platform,\n            allowed_paths=allowed_paths,\n            allowed_projects=allowed_projects,\n            aws_access_point_arn=aws_access_point_arn,\n            aws_role_arn=aws_role_arn,\n            aws_role_external_id=aws_role_external_id,\n            azure_connection_url=azure_connection_url,\n            azure_is_using_service_credentials=azure_is_using_service_credentials,\n            azure_sas_token=azure_sas_token,\n            azure_tenant_id=azure_tenant_id,\n            gcp_bucket_name=gcp_bucket_name,\n            include_root_files=include_root_files,\n            internal_processing_authorized=internal_processing_authorized,\n            organization_id=organization_id,\n            s3_access_key=s3_access_key,\n            s3_bucket_name=s3_bucket_name,\n            s3_endpoint=s3_endpoint,\n            s3_region=s3_region,\n            s3_secret_key=s3_secret_key,\n            s3_session_token=s3_session_token,\n            status=status,\n        )\n\n    @typechecked\n    def delete_cloud_storage_integration(self, cloud_storage_integration_id: str) -&gt; str:\n        \"\"\"Delete a cloud storage integration.\n\n        Args:\n            cloud_storage_integration_id: Id of the cloud storage integration.\n        \"\"\"\n        cloud_storage_integration_id = DataIntegrationId(cloud_storage_integration_id)\n\n        cloud_storage_use_cases = CloudStorageUseCases(self.kili_api_gateway)\n\n        return cloud_storage_use_cases.delete_data_integration(\n            data_integration_id=cloud_storage_integration_id\n        )\n</code></pre>"},{"location":"sdk/cloud_storage/#kili.presentation.client.cloud_storage.CloudStorageClientMethods.add_cloud_storage_connection","title":"<code>add_cloud_storage_connection(self, project_id, cloud_storage_integration_id, selected_folders=None, prefix=None, include=None, exclude=None)</code>","text":"<p>Connect a cloud storage to a project. More details about parameters can be found in the documentation.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Id of the project.</p> required <code>cloud_storage_integration_id</code> <code>str</code> <p>Id of the cloud storage integration.</p> required <code>selected_folders</code> <code>Optional[List[str]]</code> <p>List of folders of the data integration to connect to the project. If not provided, all folders of the data integration will be connected. This option is deprecated and will be removed in the future.</p> <code>None</code> <code>prefix</code> <code>Optional[str]</code> <p>Filter files to synchronize based on their base path.</p> <code>None</code> <code>include</code> <code>Optional[List[str]]</code> <p>List of pattern used to include files based on their path.</p> <code>None</code> <code>exclude</code> <code>Optional[List[str]]</code> <p>List of pattern used to exclude files based on their path.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dict with the DataConnection Id.</p> Source code in <code>kili/presentation/client/cloud_storage.py</code> <pre><code>def add_cloud_storage_connection(\n    self,\n    project_id: str,\n    cloud_storage_integration_id: str,\n    selected_folders: Optional[List[str]] = None,\n    prefix: Optional[str] = None,\n    include: Optional[List[str]] = None,\n    exclude: Optional[List[str]] = None,\n) -&gt; Dict:\n    \"\"\"Connect a cloud storage to a project. More details about parameters\n    can be found in the [documentation](https://docs.kili-technology.com/docs/filtering-assets-from-cloud-storage).\n\n    Args:\n        project_id: Id of the project.\n        cloud_storage_integration_id: Id of the cloud storage integration.\n        selected_folders: List of folders of the data integration to connect to the project.\n            If not provided, all folders of the data integration will be connected.\n            This option is deprecated and will be removed in the future.\n        prefix: Filter files to synchronize based on their base path.\n        include: List of pattern used to include files based on their path.\n        exclude: List of pattern used to exclude files based on their path.\n\n    Returns:\n        A dict with the DataConnection Id.\n    \"\"\"\n    if selected_folders is not None:\n        logger.warning(\n            \"The selected_folders argument is deprecated and will be removed in the future.\"\n        )\n\n    data_connection_id = CloudStorageUseCases(self.kili_api_gateway).add_data_connection(\n        project_id=ProjectId(project_id),\n        data_integration_id=DataIntegrationId(cloud_storage_integration_id),\n        selected_folders=selected_folders,\n        fields=(\"id\",),\n        prefix=prefix,\n        include=include,\n        exclude=exclude,\n    )[\"id\"]\n\n    return {\"id\": data_connection_id}\n</code></pre>"},{"location":"sdk/cloud_storage/#kili.presentation.client.cloud_storage.CloudStorageClientMethods.cloud_storage_connections","title":"<code>cloud_storage_connections(self, cloud_storage_connection_id=None, cloud_storage_integration_id=None, project_id=None, fields=('id', 'lastCheck', 'numberOfAssets', 'selectedFolders', 'projectId'), first=None, skip=0, disable_tqdm=None, *, as_generator=False)</code>","text":"<p>Get a generator or a list of cloud storage connections that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_storage_connection_id</code> <code>Optional[str]</code> <p>ID of the cloud storage connection.</p> <code>None</code> <code>cloud_storage_integration_id</code> <code>Optional[str]</code> <p>ID of the cloud storage integration.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>ID of the project.</p> <code>None</code> <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the cloud storage connections. See the documentation for all possible fields.</p> <code>('id', 'lastCheck', 'numberOfAssets', 'selectedFolders', 'projectId')</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of cloud storage connections to return.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of skipped cloud storage connections.</p> <code>0</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled.</p> <code>None</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the cloud storage connections is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A list or a generator of the cloud storage connections that match the criteria.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.cloud_storage_connections(project_id=\"789465123\")\n[{'id': '123456789', 'lastCheck': '2023-02-21T14:49:35.606Z', 'numberOfAssets': 42, 'selectedFolders': ['folder1', 'folder2'], 'projectId': '789465123'}]\n</code></pre> Source code in <code>kili/presentation/client/cloud_storage.py</code> <pre><code>def cloud_storage_connections(\n    self,\n    cloud_storage_connection_id: Optional[str] = None,\n    cloud_storage_integration_id: Optional[str] = None,\n    project_id: Optional[str] = None,\n    fields: ListOrTuple[str] = (\n        \"id\",\n        \"lastCheck\",\n        \"numberOfAssets\",\n        \"selectedFolders\",\n        \"projectId\",\n    ),\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: Optional[bool] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a generator or a list of cloud storage connections that match a set of criteria.\n\n    Args:\n        cloud_storage_connection_id: ID of the cloud storage connection.\n        cloud_storage_integration_id: ID of the cloud storage integration.\n        project_id: ID of the project.\n        fields: All the fields to request among the possible fields for the cloud storage connections.\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/data-connection) for all possible fields.\n        first: Maximum number of cloud storage connections to return.\n        skip: Number of skipped cloud storage connections.\n        disable_tqdm: If `True`, the progress bar will be disabled.\n        as_generator: If `True`, a generator on the cloud storage connections is returned.\n\n    Returns:\n        A list or a generator of the cloud storage connections that match the criteria.\n\n    Examples:\n        &gt;&gt;&gt; kili.cloud_storage_connections(project_id=\"789465123\")\n        [{'id': '123456789', 'lastCheck': '2023-02-21T14:49:35.606Z', 'numberOfAssets': 42, 'selectedFolders': ['folder1', 'folder2'], 'projectId': '789465123'}]\n    \"\"\"\n    if (\n        cloud_storage_connection_id is None\n        and cloud_storage_integration_id is None\n        and project_id is None\n    ):\n        raise ValueError(\n            \"At least one of cloud_storage_connection_id, cloud_storage_integration_id or\"\n            \" project_id must be specified\"\n        )\n\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n\n    cloud_storage_use_cases = CloudStorageUseCases(self.kili_api_gateway)\n\n    if cloud_storage_connection_id is None:\n        data_connections_gen = cloud_storage_use_cases.list_data_connections(\n            data_connection_filters=DataConnectionFilters(\n                project_id=ProjectId(project_id) if project_id is not None else None,\n                integration_id=(\n                    DataIntegrationId(cloud_storage_integration_id)\n                    if cloud_storage_integration_id is not None\n                    else None\n                ),\n            ),\n            fields=fields,\n            options=QueryOptions(disable_tqdm, first, skip),\n        )\n    else:\n        data_connections_gen = (\n            i\n            for i in [\n                cloud_storage_use_cases.get_data_connection(\n                    DataConnectionId(cloud_storage_connection_id), fields=fields\n                )\n            ]\n        )\n\n    if as_generator:\n        return data_connections_gen\n    return list(data_connections_gen)\n</code></pre>"},{"location":"sdk/cloud_storage/#kili.presentation.client.cloud_storage.CloudStorageClientMethods.cloud_storage_integrations","title":"<code>cloud_storage_integrations(self, cloud_storage_integration_id=None, name=None, platform=None, status=None, organization_id=None, fields=('name', 'id', 'platform', 'status'), first=None, skip=0, disable_tqdm=None, *, as_generator=False)</code>","text":"<p>Get a generator or a list of cloud storage integrations that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_storage_integration_id</code> <code>Optional[str]</code> <p>ID of the cloud storage integration.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Name of the cloud storage integration.</p> <code>None</code> <code>platform</code> <code>Optional[Literal['AWS', 'Azure', 'GCP', 'CustomS3']]</code> <p>Platform of the cloud storage integration.</p> <code>None</code> <code>status</code> <code>Optional[Literal['CONNECTED', 'DISCONNECTED', 'CHECKING']]</code> <p>Status of the cloud storage integration.</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>ID of the organization.</p> <code>None</code> <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the cloud storage integrations. See the documentation for all possible fields.</p> <code>('name', 'id', 'platform', 'status')</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of cloud storage integrations to return.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of skipped cloud storage integrations.</p> <code>0</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled.</p> <code>None</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the cloud storage integrations is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A list or a generator of the cloud storage integrations that match the criteria.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.cloud_storage_integrations()\n[{'name': 'My bucket', 'id': '123456789', 'platform': 'AWS', 'status': 'CONNECTED'}]\n</code></pre> Source code in <code>kili/presentation/client/cloud_storage.py</code> <pre><code>def cloud_storage_integrations(\n    self,\n    cloud_storage_integration_id: Optional[str] = None,\n    name: Optional[str] = None,\n    platform: Optional[DataIntegrationPlatform] = None,\n    status: Optional[DataIntegrationStatus] = None,\n    organization_id: Optional[str] = None,\n    fields: ListOrTuple[str] = (\"name\", \"id\", \"platform\", \"status\"),\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: Optional[bool] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a generator or a list of cloud storage integrations that match a set of criteria.\n\n    Args:\n        cloud_storage_integration_id: ID of the cloud storage integration.\n        name: Name of the cloud storage integration.\n        platform: Platform of the cloud storage integration.\n        status: Status of the cloud storage integration.\n        organization_id: ID of the organization.\n        fields: All the fields to request among the possible fields for the cloud storage integrations.\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/data-integration) for all possible fields.\n        first: Maximum number of cloud storage integrations to return.\n        skip: Number of skipped cloud storage integrations.\n        disable_tqdm: If `True`, the progress bar will be disabled.\n        as_generator: If `True`, a generator on the cloud storage integrations is returned.\n\n    Returns:\n        A list or a generator of the cloud storage integrations that match the criteria.\n\n    Examples:\n        &gt;&gt;&gt; kili.cloud_storage_integrations()\n        [{'name': 'My bucket', 'id': '123456789', 'platform': 'AWS', 'status': 'CONNECTED'}]\n    \"\"\"\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    data_integrations_gen = CloudStorageUseCases(self.kili_api_gateway).list_data_integrations(\n        data_integration_filters=DataIntegrationFilters(\n            status=status,\n            id=(\n                DataIntegrationId(cloud_storage_integration_id)\n                if cloud_storage_integration_id is not None\n                else None\n            ),\n            name=name,\n            platform=platform,\n            organization_id=(\n                OrganizationId(organization_id) if organization_id is not None else None\n            ),\n        ),\n        fields=fields,\n        options=options,\n    )\n\n    if as_generator:\n        return data_integrations_gen\n    return list(data_integrations_gen)\n</code></pre>"},{"location":"sdk/cloud_storage/#kili.presentation.client.cloud_storage.CloudStorageClientMethods.count_cloud_storage_integrations","title":"<code>count_cloud_storage_integrations(self, cloud_storage_integration_id=None, name=None, platform=None, status=None, organization_id=None)</code>","text":"<p>Count and return the number of cloud storage integrations that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_storage_integration_id</code> <code>Optional[str]</code> <p>ID of the cloud storage integration.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Name of the cloud storage integration.</p> <code>None</code> <code>platform</code> <code>Optional[Literal['AWS', 'Azure', 'GCP', 'CustomS3']]</code> <p>Platform of the cloud storage integration.</p> <code>None</code> <code>status</code> <code>Optional[Literal['CONNECTED', 'DISCONNECTED', 'CHECKING']]</code> <p>Status of the cloud storage integration.</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>ID of the organization.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of cloud storage integrations that match the criteria.</p> Source code in <code>kili/presentation/client/cloud_storage.py</code> <pre><code>def count_cloud_storage_integrations(\n    self,\n    cloud_storage_integration_id: Optional[str] = None,\n    name: Optional[str] = None,\n    platform: Optional[DataIntegrationPlatform] = None,\n    status: Optional[DataIntegrationStatus] = None,\n    organization_id: Optional[str] = None,\n) -&gt; int:\n    \"\"\"Count and return the number of cloud storage integrations that match a set of criteria.\n\n    Args:\n        cloud_storage_integration_id: ID of the cloud storage integration.\n        name: Name of the cloud storage integration.\n        platform: Platform of the cloud storage integration.\n        status: Status of the cloud storage integration.\n        organization_id: ID of the organization.\n\n    Returns:\n        The number of cloud storage integrations that match the criteria.\n    \"\"\"\n    return CloudStorageUseCases(self.kili_api_gateway).count_data_integrations(\n        DataIntegrationFilters(\n            status=status,\n            id=(\n                DataIntegrationId(cloud_storage_integration_id)\n                if cloud_storage_integration_id is not None\n                else None\n            ),\n            name=name,\n            platform=platform,\n            organization_id=(\n                OrganizationId(organization_id) if organization_id is not None else None\n            ),\n        )\n    )\n</code></pre>"},{"location":"sdk/cloud_storage/#kili.presentation.client.cloud_storage.CloudStorageClientMethods.create_cloud_storage_integration","title":"<code>create_cloud_storage_integration(self, platform, name, fields=('id', 'name', 'status', 'platform', 'allowedPaths'), allowed_paths=None, allowed_projects=None, aws_access_point_arn=None, aws_role_arn=None, aws_role_external_id=None, azure_connection_url=None, azure_is_using_service_credentials=None, azure_sas_token=None, azure_tenant_id=None, gcp_bucket_name=None, include_root_files=None, internal_processing_authorized=None, s3_access_key=None, s3_bucket_name=None, s3_endpoint=None, s3_region=None, s3_secret_key=None, s3_session_token=None)</code>","text":"<p>Create a cloud storage integration.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the cloud storage integration. See the documentation for all possible fields.</p> <code>('id', 'name', 'status', 'platform', 'allowedPaths')</code> <code>allowed_paths</code> <code>Optional[List[str]]</code> <p>List of allowed paths.</p> <code>None</code> <code>allowed_projects</code> <code>Optional[List[str]]</code> <p>List of allowed projects.</p> <code>None</code> <code>aws_access_point_arn</code> <code>Optional[str]</code> <p>AWS access point ARN.</p> <code>None</code> <code>aws_role_arn</code> <code>Optional[str]</code> <p>AWS role ARN.</p> <code>None</code> <code>aws_role_external_id</code> <code>Optional[str]</code> <p>AWS role external ID.</p> <code>None</code> <code>azure_connection_url</code> <code>Optional[str]</code> <p>Azure connection URL.</p> <code>None</code> <code>azure_is_using_service_credentials</code> <code>Optional[bool]</code> <p>Whether Azure is using service credentials.</p> <code>None</code> <code>azure_sas_token</code> <code>Optional[str]</code> <p>Azure SAS token.</p> <code>None</code> <code>azure_tenant_id</code> <code>Optional[str]</code> <p>Azure tenant ID.</p> <code>None</code> <code>gcp_bucket_name</code> <code>Optional[str]</code> <p>GCP bucket name.</p> <code>None</code> <code>include_root_files</code> <code>Optional[str]</code> <p>Whether to include root files.</p> <code>None</code> <code>internal_processing_authorized</code> <code>Optional[str]</code> <p>Whether internal processing is authorized.</p> <code>None</code> <code>name</code> <code>str</code> <p>Name of the cloud storage integration.</p> required <code>platform</code> <code>Literal['AWS', 'Azure', 'GCP', 'CustomS3']</code> <p>Platform of the cloud storage integration.</p> required <code>s3_access_key</code> <code>Optional[str]</code> <p>S3 access key.</p> <code>None</code> <code>s3_bucket_name</code> <code>Optional[str]</code> <p>S3 bucket name.</p> <code>None</code> <code>s3_endpoint</code> <code>Optional[str]</code> <p>S3 endpoint.</p> <code>None</code> <code>s3_region</code> <code>Optional[str]</code> <p>S3 region.</p> <code>None</code> <code>s3_secret_key</code> <code>Optional[str]</code> <p>S3 secret key.</p> <code>None</code> <code>s3_session_token</code> <code>Optional[str]</code> <p>S3 session token.</p> <code>None</code> Source code in <code>kili/presentation/client/cloud_storage.py</code> <pre><code>def create_cloud_storage_integration(\n    self,\n    platform: DataIntegrationPlatform,\n    name: str,\n    fields: ListOrTuple[str] = (\n        \"id\",\n        \"name\",\n        \"status\",\n        \"platform\",\n        \"allowedPaths\",\n    ),\n    allowed_paths: Optional[List[str]] = None,\n    allowed_projects: Optional[List[str]] = None,\n    aws_access_point_arn: Optional[str] = None,\n    aws_role_arn: Optional[str] = None,\n    aws_role_external_id: Optional[str] = None,\n    azure_connection_url: Optional[str] = None,\n    azure_is_using_service_credentials: Optional[bool] = None,\n    azure_sas_token: Optional[str] = None,\n    azure_tenant_id: Optional[str] = None,\n    gcp_bucket_name: Optional[str] = None,\n    include_root_files: Optional[str] = None,\n    internal_processing_authorized: Optional[str] = None,\n    s3_access_key: Optional[str] = None,\n    s3_bucket_name: Optional[str] = None,\n    s3_endpoint: Optional[str] = None,\n    s3_region: Optional[str] = None,\n    s3_secret_key: Optional[str] = None,\n    s3_session_token: Optional[str] = None,\n) -&gt; Dict:\n    # pylint: disable=line-too-long\n    \"\"\"Create a cloud storage integration.\n\n    Args:\n        fields: All the fields to request among the possible fields for the cloud storage integration.\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/data-integration) for all possible fields.\n        allowed_paths: List of allowed paths.\n        allowed_projects: List of allowed projects.\n        aws_access_point_arn: AWS access point ARN.\n        aws_role_arn: AWS role ARN.\n        aws_role_external_id: AWS role external ID.\n        azure_connection_url: Azure connection URL.\n        azure_is_using_service_credentials: Whether Azure is using service credentials.\n        azure_sas_token: Azure SAS token.\n        azure_tenant_id: Azure tenant ID.\n        gcp_bucket_name: GCP bucket name.\n        include_root_files: Whether to include root files.\n        internal_processing_authorized: Whether internal processing is authorized.\n        name: Name of the cloud storage integration.\n        platform: Platform of the cloud storage integration.\n        s3_access_key: S3 access key.\n        s3_bucket_name: S3 bucket name.\n        s3_endpoint: S3 endpoint.\n        s3_region: S3 region.\n        s3_secret_key: S3 secret key.\n        s3_session_token: S3 session token.\n    \"\"\"\n    cloud_storage_use_cases = CloudStorageUseCases(self.kili_api_gateway)\n\n    return cloud_storage_use_cases.create_data_integration(\n        platform=platform,\n        name=name,\n        fields=fields,\n        allowed_paths=allowed_paths,\n        allowed_projects=allowed_projects,\n        aws_access_point_arn=aws_access_point_arn,\n        aws_role_arn=aws_role_arn,\n        aws_role_external_id=aws_role_external_id,\n        azure_connection_url=azure_connection_url,\n        azure_is_using_service_credentials=azure_is_using_service_credentials,\n        azure_sas_token=azure_sas_token,\n        azure_tenant_id=azure_tenant_id,\n        gcp_bucket_name=gcp_bucket_name,\n        include_root_files=include_root_files,\n        internal_processing_authorized=internal_processing_authorized,\n        s3_access_key=s3_access_key,\n        s3_bucket_name=s3_bucket_name,\n        s3_endpoint=s3_endpoint,\n        s3_region=s3_region,\n        s3_secret_key=s3_secret_key,\n        s3_session_token=s3_session_token,\n    )\n</code></pre>"},{"location":"sdk/cloud_storage/#kili.presentation.client.cloud_storage.CloudStorageClientMethods.delete_cloud_storage_integration","title":"<code>delete_cloud_storage_integration(self, cloud_storage_integration_id)</code>","text":"<p>Delete a cloud storage integration.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_storage_integration_id</code> <code>str</code> <p>Id of the cloud storage integration.</p> required Source code in <code>kili/presentation/client/cloud_storage.py</code> <pre><code>def delete_cloud_storage_integration(self, cloud_storage_integration_id: str) -&gt; str:\n    \"\"\"Delete a cloud storage integration.\n\n    Args:\n        cloud_storage_integration_id: Id of the cloud storage integration.\n    \"\"\"\n    cloud_storage_integration_id = DataIntegrationId(cloud_storage_integration_id)\n\n    cloud_storage_use_cases = CloudStorageUseCases(self.kili_api_gateway)\n\n    return cloud_storage_use_cases.delete_data_integration(\n        data_integration_id=cloud_storage_integration_id\n    )\n</code></pre>"},{"location":"sdk/cloud_storage/#kili.presentation.client.cloud_storage.CloudStorageClientMethods.synchronize_cloud_storage_connection","title":"<code>synchronize_cloud_storage_connection(self, cloud_storage_connection_id, delete_extraneous_files=False, dry_run=False)</code>","text":"<p>Synchronize a cloud storage connection.</p> <p>This method will compute differences between the cloud storage connection and the project,     and then validate the differences.</p> <p>If <code>delete_extraneous_files</code> is True, it will also delete files that are not in the     cloud storage integration anymore but that are still in the project.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_storage_connection_id</code> <code>str</code> <p>Id of the cloud storage connection.</p> required <code>delete_extraneous_files</code> <code>bool</code> <p>If True, delete extraneous files.</p> <code>False</code> <code>dry_run</code> <code>bool</code> <p>If True, will not synchronize the data connection but only print the differences. This is useful to check the differences before applying them to the project.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dict with the cloud storage connection Id.</p> Source code in <code>kili/presentation/client/cloud_storage.py</code> <pre><code>def synchronize_cloud_storage_connection(\n    self,\n    cloud_storage_connection_id: str,\n    delete_extraneous_files: bool = False,\n    dry_run: bool = False,\n) -&gt; Dict:\n    \"\"\"Synchronize a cloud storage connection.\n\n    This method will compute differences between the cloud storage connection and the project,\n        and then validate the differences.\n\n    If `delete_extraneous_files` is True, it will also delete files that are not in the\n        cloud storage integration anymore but that are still in the project.\n\n    Args:\n        cloud_storage_connection_id: Id of the cloud storage connection.\n        delete_extraneous_files: If True, delete extraneous files.\n        dry_run: If True, will not synchronize the data connection but only print the\n            differences. This is useful to check the differences before applying them to the\n            project.\n\n    Returns:\n        A dict with the cloud storage connection Id.\n    \"\"\"\n    data_connection_id = DataConnectionId(cloud_storage_connection_id)\n\n    cloud_storage_use_cases = CloudStorageUseCases(self.kili_api_gateway)\n\n    cloud_storage_use_cases.synchronize_data_connection(\n        data_connection_id=data_connection_id,\n        delete_extraneous_files=delete_extraneous_files,\n        dry_run=dry_run,\n        logger=logger,\n    )\n\n    return cloud_storage_use_cases.get_data_connection(\n        data_connection_id=data_connection_id, fields=(\"numberOfAssets\", \"projectId\")\n    )\n</code></pre>"},{"location":"sdk/cloud_storage/#kili.presentation.client.cloud_storage.CloudStorageClientMethods.update_cloud_storage_integration","title":"<code>update_cloud_storage_integration(self, cloud_storage_integration_id, allowed_paths=None, allowed_projects=None, aws_access_point_arn=None, aws_role_arn=None, aws_role_external_id=None, azure_connection_url=None, azure_is_using_service_credentials=None, azure_sas_token=None, azure_tenant_id=None, gcp_bucket_name=None, include_root_files=None, internal_processing_authorized=None, name=None, organization_id=None, platform=None, status=None, s3_access_key=None, s3_bucket_name=None, s3_endpoint=None, s3_region=None, s3_secret_key=None, s3_session_token=None)</code>","text":"<p>Update cloud storage data integration.</p> <p>Parameters:</p> Name Type Description Default <code>allowed_paths</code> <code>Optional[List[str]]</code> <p>List of allowed paths.</p> <code>None</code> <code>allowed_projects</code> <code>Optional[List[str]]</code> <p>List of allowed projects.</p> <code>None</code> <code>aws_access_point_arn</code> <code>Optional[str]</code> <p>AWS access point ARN.</p> <code>None</code> <code>aws_role_arn</code> <code>Optional[str]</code> <p>AWS role ARN.</p> <code>None</code> <code>aws_role_external_id</code> <code>Optional[str]</code> <p>AWS role external ID.</p> <code>None</code> <code>azure_connection_url</code> <code>Optional[str]</code> <p>Azure connection URL.</p> <code>None</code> <code>azure_is_using_service_credentials</code> <code>Optional[bool]</code> <p>Whether Azure is using service credentials.</p> <code>None</code> <code>azure_sas_token</code> <code>Optional[str]</code> <p>Azure SAS token.</p> <code>None</code> <code>azure_tenant_id</code> <code>Optional[str]</code> <p>Azure tenant ID.</p> <code>None</code> <code>cloud_storage_integration_id</code> <code>str</code> <p>Data integration ID.</p> required <code>gcp_bucket_name</code> <code>Optional[str]</code> <p>GCP bucket name.</p> <code>None</code> <code>include_root_files</code> <code>Optional[str]</code> <p>Whether to include root files.</p> <code>None</code> <code>internal_processing_authorized</code> <code>Optional[str]</code> <p>Whether internal processing is authorized.</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Organization ID.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Name of the cloud storage integration.</p> <code>None</code> <code>platform</code> <code>Optional[Literal['AWS', 'Azure', 'GCP', 'CustomS3']]</code> <p>Platform of the cloud storage integration.</p> <code>None</code> <code>status</code> <code>Optional[Literal['CONNECTED', 'DISCONNECTED', 'CHECKING']]</code> <p>Status of the cloud storage integration.</p> <code>None</code> <code>s3_access_key</code> <code>Optional[str]</code> <p>S3 access key.</p> <code>None</code> <code>s3_bucket_name</code> <code>Optional[str]</code> <p>S3 bucket name.</p> <code>None</code> <code>s3_endpoint</code> <code>Optional[str]</code> <p>S3 endpoint.</p> <code>None</code> <code>s3_region</code> <code>Optional[str]</code> <p>S3 region.</p> <code>None</code> <code>s3_secret_key</code> <code>Optional[str]</code> <p>S3 secret key.</p> <code>None</code> <code>s3_session_token</code> <code>Optional[str]</code> <p>S3 session token.</p> <code>None</code> Source code in <code>kili/presentation/client/cloud_storage.py</code> <pre><code>def update_cloud_storage_integration(\n    self,\n    cloud_storage_integration_id: str,\n    allowed_paths: Optional[List[str]] = None,\n    allowed_projects: Optional[List[str]] = None,\n    aws_access_point_arn: Optional[str] = None,\n    aws_role_arn: Optional[str] = None,\n    aws_role_external_id: Optional[str] = None,\n    azure_connection_url: Optional[str] = None,\n    azure_is_using_service_credentials: Optional[bool] = None,\n    azure_sas_token: Optional[str] = None,\n    azure_tenant_id: Optional[str] = None,\n    gcp_bucket_name: Optional[str] = None,\n    include_root_files: Optional[str] = None,\n    internal_processing_authorized: Optional[str] = None,\n    name: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    platform: Optional[DataIntegrationPlatform] = None,\n    status: Optional[DataIntegrationStatus] = None,\n    s3_access_key: Optional[str] = None,\n    s3_bucket_name: Optional[str] = None,\n    s3_endpoint: Optional[str] = None,\n    s3_region: Optional[str] = None,\n    s3_secret_key: Optional[str] = None,\n    s3_session_token: Optional[str] = None,\n) -&gt; Dict:\n    \"\"\"Update cloud storage data integration.\n\n    Args:\n        allowed_paths: List of allowed paths.\n        allowed_projects: List of allowed projects.\n        aws_access_point_arn: AWS access point ARN.\n        aws_role_arn: AWS role ARN.\n        aws_role_external_id: AWS role external ID.\n        azure_connection_url: Azure connection URL.\n        azure_is_using_service_credentials: Whether Azure is using service credentials.\n        azure_sas_token: Azure SAS token.\n        azure_tenant_id: Azure tenant ID.\n        cloud_storage_integration_id: Data integration ID.\n        gcp_bucket_name: GCP bucket name.\n        include_root_files: Whether to include root files.\n        internal_processing_authorized: Whether internal processing is authorized.\n        organization_id: Organization ID.\n        name: Name of the cloud storage integration.\n        platform: Platform of the cloud storage integration.\n        status: Status of the cloud storage integration.\n        s3_access_key: S3 access key.\n        s3_bucket_name: S3 bucket name.\n        s3_endpoint: S3 endpoint.\n        s3_region: S3 region.\n        s3_secret_key: S3 secret key.\n        s3_session_token: S3 session token.\n    \"\"\"\n    return CloudStorageUseCases(self.kili_api_gateway).update_data_integration(\n        data_integration_id=DataIntegrationId(cloud_storage_integration_id),\n        name=name,\n        platform=platform,\n        allowed_paths=allowed_paths,\n        allowed_projects=allowed_projects,\n        aws_access_point_arn=aws_access_point_arn,\n        aws_role_arn=aws_role_arn,\n        aws_role_external_id=aws_role_external_id,\n        azure_connection_url=azure_connection_url,\n        azure_is_using_service_credentials=azure_is_using_service_credentials,\n        azure_sas_token=azure_sas_token,\n        azure_tenant_id=azure_tenant_id,\n        gcp_bucket_name=gcp_bucket_name,\n        include_root_files=include_root_files,\n        internal_processing_authorized=internal_processing_authorized,\n        organization_id=organization_id,\n        s3_access_key=s3_access_key,\n        s3_bucket_name=s3_bucket_name,\n        s3_endpoint=s3_endpoint,\n        s3_region=s3_region,\n        s3_secret_key=s3_secret_key,\n        s3_session_token=s3_session_token,\n        status=status,\n    )\n</code></pre>"},{"location":"sdk/event/","title":"Event module","text":"Source code in <code>kili/event/presentation/client/event.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass EventClientMethods:\n    def __init__(self, kili_api_gateway: KiliAPIGateway):\n        self.kili_api_gateway = kili_api_gateway\n\n    def list(\n        self,\n        project_id: str,\n        fields: Optional[List[str]] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        user_id: Optional[str] = None,\n        event: Optional[str] = None,\n        skip: int = 0,\n        from_event_id: Optional[str] = None,\n        until_event_id: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        order: Optional[OrderType] = \"asc\",\n    ) -&gt; List[EventDict]:\n        \"\"\"List events of my project.\n\n        Args:\n            project_id: Identifier of the project.\n            fields: All the fields to request among the possible fields for the events.\n                Defaults is [\"createdAt\", \"event\", \"id\", \"organizationId\", \"payload\", \"projectId\", \"userId\"].\n            created_at_gte: Filter events created after this date.\n            created_at_lte: Filter events created before this date.\n            user_id: Filter events by user id.\n            event: Filter events by event type.\n            skip: Number of events to skip.\n            from_event_id: Filter events from this event id.\n            until_event_id: Filter events until this event id.\n            order: Order of the events. Can be \"asc\" or \"desc\".\n\n        Returns:\n            A list of events.\n\n        Examples:\n            &gt;&gt;&gt; kili.events.list(project_id=\"your_project_id\")\n        \"\"\"\n        converted_filters = EventFilters(\n            project_id=ProjectId(project_id),\n            organization_id=organization_id,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            user_id=UserId(user_id) if user_id else None,\n            event=event,\n        )\n        options = QueryOptions(\n            skip=skip,\n            from_event_id=from_event_id,\n            until_event_id=until_event_id,\n            order=order,\n        )\n\n        return list(\n            self.kili_api_gateway.list_events(\n                filters=converted_filters, options=options, fields=fields\n            )\n        )\n</code></pre>"},{"location":"sdk/event/#kili.event.presentation.client.event.EventClientMethods.list","title":"<code>list(self, project_id, fields=None, created_at_gte=None, created_at_lte=None, user_id=None, event=None, skip=0, from_event_id=None, until_event_id=None, organization_id=None, order='asc')</code>","text":"<p>List events of my project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>fields</code> <code>Optional[List[str]]</code> <p>All the fields to request among the possible fields for the events. Defaults is [\"createdAt\", \"event\", \"id\", \"organizationId\", \"payload\", \"projectId\", \"userId\"].</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Filter events created after this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Filter events created before this date.</p> <code>None</code> <code>user_id</code> <code>Optional[str]</code> <p>Filter events by user id.</p> <code>None</code> <code>event</code> <code>Optional[str]</code> <p>Filter events by event type.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of events to skip.</p> <code>0</code> <code>from_event_id</code> <code>Optional[str]</code> <p>Filter events from this event id.</p> <code>None</code> <code>until_event_id</code> <code>Optional[str]</code> <p>Filter events until this event id.</p> <code>None</code> <code>order</code> <code>Optional[Literal['asc', 'desc']]</code> <p>Order of the events. Can be \"asc\" or \"desc\".</p> <code>'asc'</code> <p>Returns:</p> Type Description <code>List[kili.domain.event.EventDict]</code> <p>A list of events.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.events.list(project_id=\"your_project_id\")\n</code></pre> Source code in <code>kili/event/presentation/client/event.py</code> <pre><code>def list(\n    self,\n    project_id: str,\n    fields: Optional[List[str]] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    user_id: Optional[str] = None,\n    event: Optional[str] = None,\n    skip: int = 0,\n    from_event_id: Optional[str] = None,\n    until_event_id: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    order: Optional[OrderType] = \"asc\",\n) -&gt; List[EventDict]:\n    \"\"\"List events of my project.\n\n    Args:\n        project_id: Identifier of the project.\n        fields: All the fields to request among the possible fields for the events.\n            Defaults is [\"createdAt\", \"event\", \"id\", \"organizationId\", \"payload\", \"projectId\", \"userId\"].\n        created_at_gte: Filter events created after this date.\n        created_at_lte: Filter events created before this date.\n        user_id: Filter events by user id.\n        event: Filter events by event type.\n        skip: Number of events to skip.\n        from_event_id: Filter events from this event id.\n        until_event_id: Filter events until this event id.\n        order: Order of the events. Can be \"asc\" or \"desc\".\n\n    Returns:\n        A list of events.\n\n    Examples:\n        &gt;&gt;&gt; kili.events.list(project_id=\"your_project_id\")\n    \"\"\"\n    converted_filters = EventFilters(\n        project_id=ProjectId(project_id),\n        organization_id=organization_id,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        user_id=UserId(user_id) if user_id else None,\n        event=event,\n    )\n    options = QueryOptions(\n        skip=skip,\n        from_event_id=from_event_id,\n        until_event_id=until_event_id,\n        order=order,\n    )\n\n    return list(\n        self.kili_api_gateway.list_events(\n            filters=converted_filters, options=options, fields=fields\n        )\n    )\n</code></pre>"},{"location":"sdk/issue/","title":"Issue module","text":"<p>Methods attached to the Kili client, to run actions on issues.</p> Source code in <code>kili/presentation/client/issue.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass IssueClientMethods(BaseClientMethods):\n    \"\"\"Methods attached to the Kili client, to run actions on issues.\"\"\"\n\n    @typechecked\n    def create_issues(\n        self,\n        project_id: str,\n        label_id_array: List[str],\n        object_mid_array: Optional[List[Optional[str]]] = None,\n        text_array: Optional[List[Optional[str]]] = None,\n    ) -&gt; List[Dict[Literal[\"id\"], str]]:\n        \"\"\"Create an issue.\n\n        Args:\n            project_id: Id of the project.\n            label_id_array: List of Ids of the labels to add an issue to.\n            object_mid_array: List of mids of the objects in the labels to associate the issues to.\n            text_array: List of texts to associate to the issues.\n\n        Returns:\n            A list of dictionaries with the `id` key of the created issues.\n        \"\"\"\n        assert_all_arrays_have_same_size([label_id_array, object_mid_array, text_array])\n        issues = [\n            IssueToCreateUseCaseInput(label_id=LabelId(label_id), object_mid=object_mid, text=text)\n            for (label_id, object_mid, text) in zip(\n                label_id_array,\n                object_mid_array or repeat(None),\n                text_array or repeat(None),\n            )\n        ]\n        issue_service = IssueUseCases(self.kili_api_gateway)\n        issue_ids = issue_service.create_issues(project_id=ProjectId(project_id), issues=issues)\n        return [{\"id\": issue_id} for issue_id in issue_ids]\n\n    @typechecked\n    def count_issues(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_id_in: Optional[List[str]] = None,\n        issue_type: Optional[IssueType] = None,\n        status: Optional[IssueStatus] = None,\n    ) -&gt; int:\n        \"\"\"Count and return the number of issues with the given constraints.\n\n        Args:\n            project_id: Project ID the issue belongs to.\n            asset_id: Asset id whose returned issues are associated to.\n            asset_id_in: List of asset ids whose returned issues are associated to.\n            issue_type: Type of the issue to return. An issue object both\n                represents issues and questions in the app.\n            status: Status of the issues to return.\n\n        Returns:\n            The number of issues that match the given constraints.\n        \"\"\"\n        if asset_id and asset_id_in:\n            raise ValueError(\n                \"You cannot provide both `asset_id` and `asset_id_in` at the same time.\"\n            )\n        return IssueUseCases(self.kili_api_gateway).count_issues(\n            IssueFilters(\n                project_id=ProjectId(project_id),\n                asset_id=asset_id,\n                asset_id_in=asset_id_in,\n                issue_type=issue_type,\n                status=status,\n            )\n        )\n\n    @overload\n    def issues(\n        self,\n        project_id: str,\n        fields: ListOrTuple[str] = (\n            \"id\",\n            \"createdAt\",\n            \"status\",\n            \"type\",\n            \"assetId\",\n        ),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        asset_id: Optional[str] = None,\n        asset_id_in: Optional[List[str]] = None,\n        issue_type: Optional[IssueType] = None,\n        status: Optional[IssueStatus] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def issues(\n        self,\n        project_id: str,\n        fields: ListOrTuple[str] = (\n            \"id\",\n            \"createdAt\",\n            \"status\",\n            \"type\",\n            \"assetId\",\n        ),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        asset_id: Optional[str] = None,\n        asset_id_in: Optional[List[str]] = None,\n        issue_type: Optional[IssueType] = None,\n        status: Optional[IssueStatus] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def issues(\n        self,\n        project_id: str,\n        fields: ListOrTuple[str] = (\n            \"id\",\n            \"createdAt\",\n            \"status\",\n            \"type\",\n            \"assetId\",\n        ),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        asset_id: Optional[str] = None,\n        asset_id_in: Optional[List[str]] = None,\n        issue_type: Optional[IssueType] = None,\n        status: Optional[IssueStatus] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a generator or a list of issues that match a set of criteria.\n\n        !!! Info \"Issues or Questions\"\n            An `Issue` object both represent an issue and a question in the app.\n            To create them, two different methods are provided: `create_issues` and `create_questions`.\n            However to query issues and questions, we currently provide this unique method that retrieves both of them.\n\n        Args:\n            project_id: Project ID the issue belongs to.\n            asset_id: Id of the asset whose returned issues are associated to.\n            asset_id_in: List of Ids of assets whose returned issues are associated to.\n            issue_type: Type of the issue to return. An issue object both represents issues and questions in the app.\n            status: Status of the issues to return.\n            fields: All the fields to request among the possible fields for the assets.\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/issue) for all possible fields.\n            first: Maximum number of issues to return.\n            skip: Number of issues to skip (they are ordered by their date of creation, first to last).\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the issues is returned.\n\n        Returns:\n            An iterable of issues objects represented as `dict`.\n\n        Examples:\n            &gt;&gt;&gt; kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors\n        \"\"\"\n        if asset_id and asset_id_in:\n            raise ValueError(\n                \"You cannot provide both `asset_id` and `asset_id_in` at the same time.\"\n            )\n\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm=disable_tqdm, first=first, skip=skip)\n        issues_gen = IssueUseCases(self.kili_api_gateway).list_issues(\n            IssueFilters(\n                project_id=ProjectId(project_id),\n                asset_id=asset_id,\n                asset_id_in=asset_id_in,\n                issue_type=issue_type,\n                status=status,\n            ),\n            fields=fields,\n            options=options,\n        )\n        if as_generator:\n            return issues_gen\n        return list(issues_gen)\n\n    def update_issue_status(self, issue_id: str, status: IssueStatus) -&gt; Dict[str, Any]:\n        \"\"\"Update the status of an issue.\n\n        Args:\n            issue_id: Identifier of the issue.\n            status: New status of the issue. \"CANCELLED\", \"OPEN\" or \"SOLVED\"\n\n        Returns:\n            A dict with the changed properties which indicates if the mutation was successful,\n                else an error message.\n        \"\"\"\n        return IssueUseCases(self.kili_api_gateway).update_issue_status(IssueId(issue_id), status)\n</code></pre>"},{"location":"sdk/issue/#kili.presentation.client.issue.IssueClientMethods.count_issues","title":"<code>count_issues(self, project_id, asset_id=None, asset_id_in=None, issue_type=None, status=None)</code>","text":"<p>Count and return the number of issues with the given constraints.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project ID the issue belongs to.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Asset id whose returned issues are associated to.</p> <code>None</code> <code>asset_id_in</code> <code>Optional[List[str]]</code> <p>List of asset ids whose returned issues are associated to.</p> <code>None</code> <code>issue_type</code> <code>Optional[Literal['ISSUE', 'QUESTION']]</code> <p>Type of the issue to return. An issue object both represents issues and questions in the app.</p> <code>None</code> <code>status</code> <code>Optional[Literal['CANCELLED', 'OPEN', 'SOLVED']]</code> <p>Status of the issues to return.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of issues that match the given constraints.</p> Source code in <code>kili/presentation/client/issue.py</code> <pre><code>def count_issues(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_id_in: Optional[List[str]] = None,\n    issue_type: Optional[IssueType] = None,\n    status: Optional[IssueStatus] = None,\n) -&gt; int:\n    \"\"\"Count and return the number of issues with the given constraints.\n\n    Args:\n        project_id: Project ID the issue belongs to.\n        asset_id: Asset id whose returned issues are associated to.\n        asset_id_in: List of asset ids whose returned issues are associated to.\n        issue_type: Type of the issue to return. An issue object both\n            represents issues and questions in the app.\n        status: Status of the issues to return.\n\n    Returns:\n        The number of issues that match the given constraints.\n    \"\"\"\n    if asset_id and asset_id_in:\n        raise ValueError(\n            \"You cannot provide both `asset_id` and `asset_id_in` at the same time.\"\n        )\n    return IssueUseCases(self.kili_api_gateway).count_issues(\n        IssueFilters(\n            project_id=ProjectId(project_id),\n            asset_id=asset_id,\n            asset_id_in=asset_id_in,\n            issue_type=issue_type,\n            status=status,\n        )\n    )\n</code></pre>"},{"location":"sdk/issue/#kili.presentation.client.issue.IssueClientMethods.create_issues","title":"<code>create_issues(self, project_id, label_id_array, object_mid_array=None, text_array=None)</code>","text":"<p>Create an issue.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Id of the project.</p> required <code>label_id_array</code> <code>List[str]</code> <p>List of Ids of the labels to add an issue to.</p> required <code>object_mid_array</code> <code>Optional[List[Optional[str]]]</code> <p>List of mids of the objects in the labels to associate the issues to.</p> <code>None</code> <code>text_array</code> <code>Optional[List[Optional[str]]]</code> <p>List of texts to associate to the issues.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[Literal['id'], str]]</code> <p>A list of dictionaries with the <code>id</code> key of the created issues.</p> Source code in <code>kili/presentation/client/issue.py</code> <pre><code>def create_issues(\n    self,\n    project_id: str,\n    label_id_array: List[str],\n    object_mid_array: Optional[List[Optional[str]]] = None,\n    text_array: Optional[List[Optional[str]]] = None,\n) -&gt; List[Dict[Literal[\"id\"], str]]:\n    \"\"\"Create an issue.\n\n    Args:\n        project_id: Id of the project.\n        label_id_array: List of Ids of the labels to add an issue to.\n        object_mid_array: List of mids of the objects in the labels to associate the issues to.\n        text_array: List of texts to associate to the issues.\n\n    Returns:\n        A list of dictionaries with the `id` key of the created issues.\n    \"\"\"\n    assert_all_arrays_have_same_size([label_id_array, object_mid_array, text_array])\n    issues = [\n        IssueToCreateUseCaseInput(label_id=LabelId(label_id), object_mid=object_mid, text=text)\n        for (label_id, object_mid, text) in zip(\n            label_id_array,\n            object_mid_array or repeat(None),\n            text_array or repeat(None),\n        )\n    ]\n    issue_service = IssueUseCases(self.kili_api_gateway)\n    issue_ids = issue_service.create_issues(project_id=ProjectId(project_id), issues=issues)\n    return [{\"id\": issue_id} for issue_id in issue_ids]\n</code></pre>"},{"location":"sdk/issue/#kili.presentation.client.issue.IssueClientMethods.issues","title":"<code>issues(self, project_id, fields=('id', 'createdAt', 'status', 'type', 'assetId'), first=None, skip=0, disable_tqdm=None, asset_id=None, asset_id_in=None, issue_type=None, status=None, *, as_generator=False)</code>","text":"<p>Get a generator or a list of issues that match a set of criteria.</p> <p>Issues or Questions</p> <p>An <code>Issue</code> object both represent an issue and a question in the app. To create them, two different methods are provided: <code>create_issues</code> and <code>create_questions</code>. However to query issues and questions, we currently provide this unique method that retrieves both of them.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project ID the issue belongs to.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Id of the asset whose returned issues are associated to.</p> <code>None</code> <code>asset_id_in</code> <code>Optional[List[str]]</code> <p>List of Ids of assets whose returned issues are associated to.</p> <code>None</code> <code>issue_type</code> <code>Optional[Literal['ISSUE', 'QUESTION']]</code> <p>Type of the issue to return. An issue object both represents issues and questions in the app.</p> <code>None</code> <code>status</code> <code>Optional[Literal['CANCELLED', 'OPEN', 'SOLVED']]</code> <p>Status of the issues to return.</p> <code>None</code> <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the assets. See the documentation for all possible fields.</p> <code>('id', 'createdAt', 'status', 'type', 'assetId')</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of issues to return.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of issues to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>None</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the issues is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>An iterable of issues objects represented as <code>dict</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors\n</code></pre> Source code in <code>kili/presentation/client/issue.py</code> <pre><code>def issues(\n    self,\n    project_id: str,\n    fields: ListOrTuple[str] = (\n        \"id\",\n        \"createdAt\",\n        \"status\",\n        \"type\",\n        \"assetId\",\n    ),\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: Optional[bool] = None,\n    asset_id: Optional[str] = None,\n    asset_id_in: Optional[List[str]] = None,\n    issue_type: Optional[IssueType] = None,\n    status: Optional[IssueStatus] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a generator or a list of issues that match a set of criteria.\n\n    !!! Info \"Issues or Questions\"\n        An `Issue` object both represent an issue and a question in the app.\n        To create them, two different methods are provided: `create_issues` and `create_questions`.\n        However to query issues and questions, we currently provide this unique method that retrieves both of them.\n\n    Args:\n        project_id: Project ID the issue belongs to.\n        asset_id: Id of the asset whose returned issues are associated to.\n        asset_id_in: List of Ids of assets whose returned issues are associated to.\n        issue_type: Type of the issue to return. An issue object both represents issues and questions in the app.\n        status: Status of the issues to return.\n        fields: All the fields to request among the possible fields for the assets.\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/issue) for all possible fields.\n        first: Maximum number of issues to return.\n        skip: Number of issues to skip (they are ordered by their date of creation, first to last).\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the issues is returned.\n\n    Returns:\n        An iterable of issues objects represented as `dict`.\n\n    Examples:\n        &gt;&gt;&gt; kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors\n    \"\"\"\n    if asset_id and asset_id_in:\n        raise ValueError(\n            \"You cannot provide both `asset_id` and `asset_id_in` at the same time.\"\n        )\n\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm=disable_tqdm, first=first, skip=skip)\n    issues_gen = IssueUseCases(self.kili_api_gateway).list_issues(\n        IssueFilters(\n            project_id=ProjectId(project_id),\n            asset_id=asset_id,\n            asset_id_in=asset_id_in,\n            issue_type=issue_type,\n            status=status,\n        ),\n        fields=fields,\n        options=options,\n    )\n    if as_generator:\n        return issues_gen\n    return list(issues_gen)\n</code></pre>"},{"location":"sdk/issue/#kili.presentation.client.issue.IssueClientMethods.update_issue_status","title":"<code>update_issue_status(self, issue_id, status)</code>","text":"<p>Update the status of an issue.</p> <p>Parameters:</p> Name Type Description Default <code>issue_id</code> <code>str</code> <p>Identifier of the issue.</p> required <code>status</code> <code>Literal['CANCELLED', 'OPEN', 'SOLVED']</code> <p>New status of the issue. \"CANCELLED\", \"OPEN\" or \"SOLVED\"</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dict with the changed properties which indicates if the mutation was successful,     else an error message.</p> Source code in <code>kili/presentation/client/issue.py</code> <pre><code>def update_issue_status(self, issue_id: str, status: IssueStatus) -&gt; Dict[str, Any]:\n    \"\"\"Update the status of an issue.\n\n    Args:\n        issue_id: Identifier of the issue.\n        status: New status of the issue. \"CANCELLED\", \"OPEN\" or \"SOLVED\"\n\n    Returns:\n        A dict with the changed properties which indicates if the mutation was successful,\n            else an error message.\n    \"\"\"\n    return IssueUseCases(self.kili_api_gateway).update_issue_status(IssueId(issue_id), status)\n</code></pre>"},{"location":"sdk/label/","title":"Label module","text":"<p>Methods attached to the Kili client, to run actions on labels.</p> Source code in <code>kili/presentation/client/label.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass LabelClientMethods(BaseClientMethods):\n    \"\"\"Methods attached to the Kili client, to run actions on labels.\"\"\"\n\n    @typechecked\n    def count_labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[AssetStatus]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        asset_external_id_strictly_in: Optional[List[str]] = None,\n        asset_step_name_in: Optional[List[str]] = None,\n        asset_step_status_in: Optional[List[StatusInStep]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        label_id: Optional[str] = None,\n        type_in: Optional[List[LabelType]] = None,\n        user_id: Optional[str] = None,\n        category_search: Optional[str] = None,\n        id_contains: Optional[List[str]] = None,\n    ) -&gt; int:\n        # pylint: disable=line-too-long\n        \"\"\"Get the number of labels for the given parameters.\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset.\n            asset_status_in: Returned labels should have a status that belongs to that list, if given.\n                Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED`\n            asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n            asset_external_id_strictly_in: Returned labels should have an external id that exactly matches one of the ids in that list, if given.\n            asset_step_name_in: Returned assets are in a step whose name belong to that list, if given.\n                Only applicable if the project is in WorkflowV2.\n            asset_step_status_in: Returned assets have the status of their step that belongs to that list, if given.\n                Possible choices: `TO_DO`, `DOING`, `PARTIALLY_DONE`, `REDO`, `DONE`, `SKIPPED`.\n                Only applicable if the project is in WorkflowV2.\n            author_in: Returned labels should have been made by authors in that list, if given.\n                An author can be designated by the first name, the last name, or the first name + last name.\n            created_at: Returned labels should have a label whose creation date is equal to this date.\n            created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n            created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n            honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n            honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n            label_id: Identifier of the label.\n            type_in: Returned labels should have a label whose type belongs to that list, if given.\n            user_id: Identifier of the user.\n            category_search: Query to filter labels based on the content of their jsonResponse\n            id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            The number of labels with the parameters provided\n        \"\"\"\n        if category_search:\n            validate_category_search_query(category_search)\n\n        asset_step_id_in = None\n        if (\n            asset_status_in is not None\n            or asset_step_name_in is not None\n            or asset_step_status_in is not None\n        ):\n            project_use_cases = ProjectUseCases(self.kili_api_gateway)\n            (\n                project_steps,\n                project_workflow_version,\n            ) = project_use_cases.get_project_steps_and_version(project_id)\n            check_asset_workflow_arguments(\n                project_workflow_version=project_workflow_version,\n                asset_workflow_filters={\n                    \"skipped\": None,\n                    \"step_name_in\": asset_step_name_in,\n                    \"step_status_in\": asset_step_status_in,\n                    \"status_in\": asset_status_in,\n                },\n            )\n            if project_workflow_version == \"V2\" and asset_step_name_in is not None:\n                asset_step_id_in = extract_step_ids_from_project_steps(\n                    project_steps=project_steps,\n                    step_name_in=asset_step_name_in,\n                )\n\n        filters = LabelFilters(\n            project_id=ProjectId(project_id),\n            asset=AssetFilters(\n                project_id=ProjectId(project_id),\n                asset_id=AssetId(asset_id) if asset_id else None,\n                status_in=asset_status_in,\n                external_id_in=(\n                    cast(ListOrTuple[AssetExternalId], asset_external_id_in)\n                    if asset_external_id_in\n                    else None\n                ),\n                external_id_strictly_in=(\n                    cast(ListOrTuple[AssetExternalId], asset_external_id_strictly_in)\n                    if asset_external_id_strictly_in\n                    else None\n                ),\n                step_id_in=asset_step_id_in,\n                step_status_in=asset_step_status_in,\n            ),\n            author_in=author_in,\n            created_at=created_at,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            honeypot_mark_gte=honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lte,\n            id_in=cast(List[LabelId], id_contains) if id_contains else None,\n            id=LabelId(label_id) if label_id else None,\n            type_in=type_in,\n            user=UserFilter(id=UserId(user_id)) if user_id else None,\n            search=category_search,\n            consensus_mark_gte=None,\n            consensus_mark_lte=None,\n            labeler_in=None,\n            reviewer_in=None,\n        )\n\n        return LabelUseCases(self.kili_api_gateway).count_labels(filters=filters)\n\n    @overload\n    def labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[ListOrTuple[AssetStatus]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        asset_external_id_strictly_in: Optional[List[str]] = None,\n        asset_step_name_in: Optional[List[str]] = None,\n        asset_step_status_in: Optional[List[StatusInStep]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"secondsToLabel\",\n            \"isLatestLabelForUser\",\n            \"assetId\",\n        ),\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        type_in: Optional[List[LabelType]] = None,\n        user_id: Optional[str] = None,\n        disable_tqdm: Optional[bool] = None,\n        category_search: Optional[str] = None,\n        output_format: Literal[\"dict\"] = \"dict\",\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[ListOrTuple[AssetStatus]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        asset_external_id_strictly_in: Optional[List[str]] = None,\n        asset_step_name_in: Optional[List[str]] = None,\n        asset_step_status_in: Optional[List[StatusInStep]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"secondsToLabel\",\n            \"isLatestLabelForUser\",\n            \"assetId\",\n        ),\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        type_in: Optional[List[LabelType]] = None,\n        user_id: Optional[str] = None,\n        disable_tqdm: Optional[bool] = None,\n        category_search: Optional[str] = None,\n        output_format: Literal[\"dict\"] = \"dict\",\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @overload\n    def labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[ListOrTuple[AssetStatus]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        asset_external_id_strictly_in: Optional[List[str]] = None,\n        asset_step_name_in: Optional[List[str]] = None,\n        asset_step_status_in: Optional[List[StatusInStep]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"secondsToLabel\",\n            \"isLatestLabelForUser\",\n            \"assetId\",\n        ),\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        type_in: Optional[List[LabelType]] = None,\n        user_id: Optional[str] = None,\n        disable_tqdm: Optional[bool] = None,\n        category_search: Optional[str] = None,\n        output_format: Literal[\"parsed_label\"] = \"parsed_label\",\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[ParsedLabel]:\n        ...\n\n    @overload\n    def labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[ListOrTuple[AssetStatus]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        asset_external_id_strictly_in: Optional[List[str]] = None,\n        asset_step_name_in: Optional[List[str]] = None,\n        asset_step_status_in: Optional[List[StatusInStep]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"secondsToLabel\",\n            \"isLatestLabelForUser\",\n            \"assetId\",\n        ),\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        type_in: Optional[List[LabelType]] = None,\n        user_id: Optional[str] = None,\n        disable_tqdm: Optional[bool] = None,\n        category_search: Optional[str] = None,\n        output_format: Literal[\"parsed_label\"] = \"parsed_label\",\n        *,\n        as_generator: Literal[True] = True,\n    ) -&gt; Generator[ParsedLabel, None, None]:\n        ...\n\n    @typechecked\n    def labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[ListOrTuple[AssetStatus]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        asset_external_id_strictly_in: Optional[List[str]] = None,\n        asset_step_name_in: Optional[List[str]] = None,\n        asset_step_status_in: Optional[List[StatusInStep]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"secondsToLabel\",\n            \"isLatestLabelForUser\",\n            \"assetId\",\n        ),\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        type_in: Optional[List[LabelType]] = None,\n        user_id: Optional[str] = None,\n        disable_tqdm: Optional[bool] = None,\n        category_search: Optional[str] = None,\n        output_format: Literal[\"dict\", \"parsed_label\"] = \"dict\",\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Union[Dict, ParsedLabel]]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a label list or a label generator from a project based on a set of criteria.\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset.\n            asset_status_in: Returned labels should have a status that belongs to that list, if given.\n                Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`.\n            asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n            asset_external_id_strictly_in: Returned labels should have an external id that exactly matches one of the ids in that list, if given.\n            asset_step_name_in: Returned assets are in a step whose name belong to that list, if given.\n                Only applicable if the project is in WorkflowV2.\n            asset_step_status_in: Returned assets have the status of their step that belongs to that list, if given.\n                Possible choices: `TO_DO`, `DOING`, `PARTIALLY_DONE`, `REDO`, `DONE`, `SKIPPED`.\n                Only applicable if the project is in WorkflowV2.\n            author_in: Returned labels should have been made by authors in that list, if given.\n                An author can be designated by the first name, the last name, or the first name + last name.\n            created_at: Returned labels should have their creation date equal to this date.\n            created_at_gte: Returned labels should have their creation date greater or equal to this date.\n            created_at_lte: Returned labels should have their creation date lower or equal to this date.\n            fields: All the fields to request among the possible fields for the labels.\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/label) for all possible fields.\n            first: Maximum number of labels to return.\n            honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n            honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n            id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n            label_id: Identifier of the label.\n            skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n            type_in: Returned labels should have a label whose type belongs to that list, if given.\n            user_id: Identifier of the user.\n            disable_tqdm: If `True`, the progress bar will be disabled.\n            as_generator: If `True`, a generator on the labels is returned.\n            category_search: Query to filter labels based on the content of their jsonResponse.\n            output_format: If `dict`, the output is an iterable of Python dictionaries.\n                If `parsed_label`, the output is an iterable of parsed labels objects. More information on parsed labels in the [documentation](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/label_parsing/).\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            An iterable of labels.\n\n        Examples:\n            &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID\n            &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project\n\n        !!! example \"How to filter based on label categories\"\n            The search query is composed of logical expressions following this format:\n\n                [job_name].[category_name].count [comparaison_operator] [value]\n            where:\n\n            - `[job_name]` is the name of the job in the interface\n            - `[category_name]` is the name of the category in the interface for this job\n            - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n            - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n            These operations can be separated by OR and AND operators\n\n        Example:\n                category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n                category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n                category_search = `(JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n        \"\"\"\n        if category_search:\n            validate_category_search_query(category_search)\n\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n\n        asset_step_id_in = None\n        if (\n            asset_status_in is not None\n            or asset_step_name_in is not None\n            or asset_step_status_in is not None\n        ):\n            project_use_cases = ProjectUseCases(self.kili_api_gateway)\n            (\n                project_steps,\n                project_workflow_version,\n            ) = project_use_cases.get_project_steps_and_version(project_id)\n            check_asset_workflow_arguments(\n                project_workflow_version=project_workflow_version,\n                asset_workflow_filters={\n                    \"skipped\": None,\n                    \"step_name_in\": asset_step_name_in,\n                    \"step_status_in\": asset_step_status_in,\n                    \"status_in\": asset_status_in,\n                },\n            )\n            if project_workflow_version == \"V2\" and asset_step_name_in is not None:\n                asset_step_id_in = extract_step_ids_from_project_steps(\n                    project_steps=project_steps,\n                    step_name_in=asset_step_name_in,\n                )\n\n        filters = LabelFilters(\n            project_id=ProjectId(project_id),\n            asset=AssetFilters(\n                project_id=ProjectId(project_id),\n                asset_id=AssetId(asset_id) if asset_id else None,\n                status_in=asset_status_in,\n                external_id_in=(\n                    cast(ListOrTuple[AssetExternalId], asset_external_id_in)\n                    if asset_external_id_in\n                    else None\n                ),\n                external_id_strictly_in=(\n                    cast(ListOrTuple[AssetExternalId], asset_external_id_strictly_in)\n                    if asset_external_id_strictly_in\n                    else None\n                ),\n                step_id_in=asset_step_id_in,\n                step_status_in=asset_step_status_in,\n            ),\n            author_in=author_in,\n            created_at=created_at,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            honeypot_mark_gte=honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lte,\n            id_in=cast(List[LabelId], id_contains) if id_contains else None,\n            id=LabelId(label_id) if label_id else None,\n            type_in=type_in,\n            user=UserFilter(id=UserId(user_id)) if user_id else None,\n            search=category_search,\n            consensus_mark_gte=None,\n            consensus_mark_lte=None,\n            labeler_in=None,\n            reviewer_in=None,\n        )\n\n        labels_gen = LabelUseCases(self.kili_api_gateway).list_labels(\n            filters=filters,\n            options=options,\n            fields=fields,\n            output_format=output_format,\n            project_id=ProjectId(project_id),\n        )\n\n        if as_generator:\n            return labels_gen\n        return list(labels_gen)\n\n    @overload\n    def predictions(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[ListOrTuple[AssetStatus]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        asset_step_name_in: Optional[List[str]] = None,\n        asset_step_status_in: Optional[List[StatusInStep]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"modelName\",\n        ),\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: Optional[bool] = None,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def predictions(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[ListOrTuple[AssetStatus]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        asset_step_name_in: Optional[List[str]] = None,\n        asset_step_status_in: Optional[List[StatusInStep]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"modelName\",\n        ),\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: Optional[bool] = None,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def predictions(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[ListOrTuple[AssetStatus]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        asset_step_name_in: Optional[List[str]] = None,\n        asset_step_status_in: Optional[List[StatusInStep]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"modelName\",\n        ),\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: Optional[bool] = None,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n        \"\"\"Get prediction labels from a project based on a set of criteria.\n\n        This method is equivalent to the `kili.labels()` method, but it only returns label of type \"PREDICTION\".\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset.\n            asset_status_in: Returned labels should have a status that belongs to that list, if given.\n                Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n            asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n            asset_step_name_in: Returned assets are in a step whose name belong to that list, if given.\n                Only applicable if the project is in WorkflowV2.\n            asset_step_status_in: Returned assets have the status of their step that belongs to that list, if given.\n                Possible choices: `TO_DO`, `DOING`, `PARTIALLY_DONE`, `REDO`, `DONE`, `SKIPPED`.\n                Only applicable if the project is in WorkflowV2.\n            author_in: Returned labels should have been made by authors in that list, if given.\n                An author can be designated by the first name, the last name, or the first name + last name.\n            created_at: Returned labels should have a label whose creation date is equal to this date.\n            created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n            created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n            fields: All the fields to request among the possible fields for the labels.\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/label) for all possible fields.\n            first: Maximum number of labels to return.\n            honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n            honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n            id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n            label_id: Identifier of the label.\n            skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n            user_id: Identifier of the user.\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the labels is returned.\n            category_search: Query to filter labels based on the content of their jsonResponse\n\n        Returns:\n            An iterable of labels.\n\n        Examples:\n            &gt;&gt;&gt; kili.predictions(project_id=project_id) # returns a list of prediction labels of a project\n        \"\"\"\n        return self.labels(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_status_in=asset_status_in,\n            asset_external_id_in=asset_external_id_in,\n            asset_step_name_in=asset_step_name_in,\n            asset_step_status_in=asset_step_status_in,\n            author_in=author_in,\n            created_at=created_at,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            fields=fields,\n            first=first,\n            honeypot_mark_gte=honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lte,\n            id_contains=id_contains,\n            label_id=label_id,\n            skip=skip,\n            type_in=[\"PREDICTION\"],\n            user_id=user_id,\n            disable_tqdm=disable_tqdm,\n            category_search=category_search,\n            as_generator=as_generator,  # pyright: ignore[reportGeneralTypeIssues]\n        )\n\n    @overload\n    def inferences(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[ListOrTuple[AssetStatus]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        asset_step_name_in: Optional[List[str]] = None,\n        asset_step_status_in: Optional[List[StatusInStep]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"modelName\",\n        ),\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: Optional[bool] = None,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def inferences(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[ListOrTuple[AssetStatus]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        asset_step_name_in: Optional[List[str]] = None,\n        asset_step_status_in: Optional[List[StatusInStep]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"modelName\",\n        ),\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: Optional[bool] = None,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def inferences(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[ListOrTuple[AssetStatus]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        asset_step_name_in: Optional[List[str]] = None,\n        asset_step_status_in: Optional[List[StatusInStep]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"modelName\",\n        ),\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: Optional[bool] = None,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n        \"\"\"Get inference labels from a project based on a set of criteria.\n\n        This method is equivalent to the `kili.labels()` method, but it only returns label of type \"INFERENCE\".\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset.\n            asset_status_in: Returned labels should have a status that belongs to that list, if given.\n                Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n            asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n            asset_step_name_in: Returned assets are in a step whose name belong to that list, if given.\n                Only applicable if the project is in WorkflowV2.\n            asset_step_status_in: Returned assets have the status of their step that belongs to that list, if given.\n                Possible choices: `TO_DO`, `DOING`, `PARTIALLY_DONE`, `REDO`, `DONE`, `SKIPPED`.\n                Only applicable if the project is in WorkflowV2.\n            author_in: Returned labels should have been made by authors in that list, if given.\n                An author can be designated by the first name, the last name, or the first name + last name.\n            created_at: Returned labels should have a label whose creation date is equal to this date.\n            created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n            created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n            fields: All the fields to request among the possible fields for the labels.\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/label) for all possible fields.\n            first: Maximum number of labels to return.\n            honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n            honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n            id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n            label_id: Identifier of the label.\n            skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n            user_id: Identifier of the user.\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the labels is returned.\n            category_search: Query to filter labels based on the content of their jsonResponse\n\n        Returns:\n            An iterable of inference labels.\n\n        Examples:\n            &gt;&gt;&gt; kili.inferences(project_id=project_id) # returns a list of inference labels of a project\n        \"\"\"\n        return self.labels(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_status_in=asset_status_in,\n            asset_external_id_in=asset_external_id_in,\n            asset_step_name_in=asset_step_name_in,\n            asset_step_status_in=asset_step_status_in,\n            author_in=author_in,\n            created_at=created_at,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            fields=fields,\n            first=first,\n            honeypot_mark_gte=honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lte,\n            id_contains=id_contains,\n            label_id=label_id,\n            skip=skip,\n            type_in=[\"INFERENCE\"],\n            user_id=user_id,\n            disable_tqdm=disable_tqdm,\n            category_search=category_search,\n            as_generator=as_generator,  # pyright: ignore[reportGeneralTypeIssues]\n        )\n\n    @typechecked\n    def delete_labels(\n        self,\n        ids: ListOrTuple[str],\n        disable_tqdm: Optional[bool] = None,\n    ) -&gt; List[str]:\n        \"\"\"Delete labels.\n\n        Currently, only `PREDICTION` and `INFERENCE` labels can be deleted.\n\n        Args:\n            ids: List of label ids to delete.\n            disable_tqdm: If `True`, the progress bar will be disabled.\n\n        Returns:\n            The deleted label ids.\n        \"\"\"\n        if is_empty_list_with_warning(\"delete_labels\", \"ids\", ids):\n            return []\n\n        deleted_label_ids = LabelUseCases(self.kili_api_gateway).delete_labels(\n            ids=cast(ListOrTuple[LabelId], ids),\n            disable_tqdm=disable_tqdm,\n        )\n        return cast(List[str], deleted_label_ids)\n\n    @typechecked\n    def append_labels(\n        self,\n        asset_id_array: Optional[List[str]] = None,\n        json_response_array: ListOrTuple[Dict] = (),\n        author_id_array: Optional[List[str]] = None,\n        seconds_to_label_array: Optional[List[int]] = None,\n        model_name: Optional[str] = None,\n        label_type: LabelType = \"DEFAULT\",\n        project_id: Optional[str] = None,\n        asset_external_id_array: Optional[List[str]] = None,\n        disable_tqdm: Optional[bool] = None,\n        overwrite: bool = False,\n        step_name: Optional[str] = None,\n        reviewed_label_id_array: Optional[List[str]] = None,\n    ) -&gt; List[Dict[Literal[\"id\"], str]]:\n        \"\"\"Append labels to assets.\n\n        Args:\n            asset_id_array: list of asset internal ids to append labels on.\n            json_response_array: list of labels to append.\n            author_id_array: list of the author id of the labels.\n            seconds_to_label_array: list of times taken to produce the label, in seconds.\n            model_name: Name of the model that generated the labels.\n                Only useful when uploading PREDICTION or INFERENCE labels.\n            label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`.\n            project_id: Identifier of the project.\n            asset_external_id_array: list of asset external ids to append labels on.\n            disable_tqdm: Disable tqdm progress bar.\n            overwrite: when uploading prediction or inference labels, if True,\n                it will overwrite existing labels with the same model name\n                and of the same label type, on the targeted assets.\n            reviewed_label_id_array: list of IDs of labels being reviewed.\n                Only useful when uploading REVIEW labels.\n            step_name: Name of the step to which the labels belong.\n                The label_type must match accordingly.\n\n        Returns:\n            A list of dictionaries with the label ids.\n\n        Examples:\n            &gt;&gt;&gt; kili.append_labels(\n                    asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'],\n                    json_response_array=[{...}, {...}]\n                )\n        \"\"\"\n        if len(json_response_array) == 0:\n            raise ValueError(\n                \"json_response_array is empty, you must provide at least one label to upload\"\n            )\n\n        check_asset_identifier_arguments(\n            ProjectId(project_id) if project_id else None,\n            cast(ListOrTuple[AssetId], asset_id_array) if asset_id_array else None,\n            (\n                cast(ListOrTuple[AssetExternalId], asset_external_id_array)\n                if asset_external_id_array\n                else None\n            ),\n        )\n\n        assert_all_arrays_have_same_size(\n            [\n                seconds_to_label_array,\n                author_id_array,\n                json_response_array,\n                asset_external_id_array,\n                asset_id_array,\n                reviewed_label_id_array,\n            ]\n        )\n\n        labels = [\n            LabelToCreateUseCaseInput(\n                asset_id=AssetId(asset_id) if asset_id else None,\n                asset_external_id=AssetExternalId(asset_external_id) if asset_external_id else None,\n                json_response=json_response,\n                seconds_to_label=seconds_to_label,\n                author_id=UserId(author_id) if author_id else None,\n                label_type=label_type,\n                model_name=model_name,\n                referenced_label_id=reviewed_label_id,\n            )\n            for (\n                asset_id,\n                asset_external_id,\n                json_response,\n                seconds_to_label,\n                author_id,\n                reviewed_label_id,\n            ) in zip(\n                asset_id_array or repeat(None),\n                asset_external_id_array or repeat(None),\n                json_response_array,\n                seconds_to_label_array or repeat(None),\n                author_id_array or repeat(None),\n                reviewed_label_id_array or repeat(None),\n            )\n        ]\n\n        return LabelUseCases(self.kili_api_gateway).append_labels(\n            fields=(\"id\",),\n            disable_tqdm=disable_tqdm,\n            label_type=label_type,\n            step_name=step_name,\n            labels=labels,\n            overwrite=overwrite,\n            project_id=ProjectId(project_id) if project_id else None,\n        )\n\n    @typechecked\n    def create_predictions(\n        self,\n        project_id: str,\n        external_id_array: Optional[List[str]] = None,\n        model_name_array: Optional[List[str]] = None,\n        json_response_array: Optional[List[dict]] = None,\n        model_name: Optional[str] = None,\n        asset_id_array: Optional[List[str]] = None,\n        disable_tqdm: Optional[bool] = None,\n        overwrite: bool = False,\n    ) -&gt; Dict[Literal[\"id\"], str]:\n        # pylint: disable=line-too-long\n        \"\"\"Create predictions for specific assets.\n\n        Args:\n            project_id: Identifier of the project.\n            external_id_array: The external IDs of the assets for which we want to add predictions.\n            model_name_array: Deprecated, use `model_name` instead.\n            json_response_array: The predictions are given here. For examples,\n                see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n            model_name: The name of the model that generated the predictions\n            asset_id_array: The internal IDs of the assets for which we want to add predictions.\n            disable_tqdm: Disable tqdm progress bar.\n            overwrite: if True, it will overwrite existing predictions of\n                the same model name on the targeted assets.\n\n        Returns:\n            A dictionary with the project `id`.\n\n        !!! example \"Recipe\"\n            For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n\n        !!! warning \"model name\"\n            The use of `model_name_array` is deprecated. Creating predictions from different\n            models is not supported anymore. Please use `model_name` argument instead to\n            provide the predictions model name.\n        \"\"\"\n        if json_response_array is None or len(json_response_array) == 0:\n            raise ValueError(\n                \"json_response_array is empty, you must provide at least one prediction to upload\"\n            )\n\n        assert_all_arrays_have_same_size(\n            [external_id_array, json_response_array, model_name_array, asset_id_array]\n        )\n        nb_labels_to_add = len(json_response_array)\n\n        if model_name is None:\n            if model_name_array is None:\n                raise ValueError(\"You must provide a model name with the `model_name` argument.\")\n\n            if len(set(model_name_array)) &gt; 1:\n                raise ValueError(\n                    \"Creating predictions from different models is not supported anymore. Separate\"\n                    \" your calls by models.\"\n                )\n\n            warnings.warn(\n                \"The use of `model_name_array` is deprecated. Creating predictions from\"\n                \" different models is not supported anymore. Please use `model_name` argument\"\n                \" instead to provide the predictions model name.\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n            model_name = model_name_array[0]\n\n        labels = [\n            LabelToCreateUseCaseInput(\n                asset_id=AssetId(asset_id) if asset_id else None,\n                asset_external_id=AssetExternalId(asset_external_id) if asset_external_id else None,\n                json_response=json_response,\n                label_type=\"PREDICTION\",\n                model_name=model_name,\n                seconds_to_label=None,\n                author_id=None,\n                referenced_label_id=None,\n            )\n            for (asset_id, asset_external_id, json_response) in zip(\n                asset_id_array or repeat(None, nb_labels_to_add),\n                external_id_array or repeat(None, nb_labels_to_add),\n                json_response_array,\n            )\n        ]\n\n        LabelUseCases(self.kili_api_gateway).append_labels(\n            fields=(\"id\",),\n            disable_tqdm=disable_tqdm,\n            label_type=\"PREDICTION\",\n            labels=labels,\n            overwrite=overwrite,\n            project_id=ProjectId(project_id) if project_id else None,\n        )\n        return {\"id\": project_id}\n\n    @typechecked\n    def create_honeypot(\n        self,\n        json_response: dict,\n        asset_external_id: Optional[str] = None,\n        asset_id: Optional[str] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Dict:\n        \"\"\"Create honeypot for an asset.\n\n        !!! info\n            Uses the given `json_response` to create a `REVIEW` label.\n            This enables Kili to compute a`honeypotMark`,\n            which measures the similarity between this label and other labels.\n\n        Args:\n            json_response: The JSON response of the honeypot label of the asset.\n            asset_id: Identifier of the asset.\n                Either provide `asset_id` or `asset_external_id` and `project_id`.\n            asset_external_id: External identifier of the asset.\n                Either provide `asset_id` or `asset_external_id` and `project_id`.\n            project_id: Identifier of the project.\n                Either provide `asset_id` or `asset_external_id` and `project_id`.\n\n        Returns:\n            A dictionary-like object representing the created label.\n        \"\"\"\n        return LabelUseCases(self.kili_api_gateway).create_honeypot_label(\n            json_response=json_response,\n            asset_id=AssetId(asset_id) if asset_id else None,\n            asset_external_id=AssetExternalId(asset_external_id) if asset_external_id else None,\n            project_id=ProjectId(project_id) if project_id else None,\n            fields=(\"id\",),\n        )\n\n    @deprecate(\n        msg=(\n            \"append_to_labels method is deprecated. Please use append_labels instead. This new\"\n            \" function allows to import several labels 10 times faster.\"\n        )\n    )\n    @typechecked\n    def append_to_labels(\n        self,\n        json_response: dict,\n        author_id: Optional[str] = None,\n        label_asset_external_id: Optional[str] = None,\n        label_asset_id: Optional[str] = None,\n        label_type: LabelType = \"DEFAULT\",\n        project_id: Optional[str] = None,\n        seconds_to_label: Optional[int] = 0,\n    ) -&gt; Dict[Literal[\"id\"], str]:\n        \"\"\"!!! danger \"[DEPRECATED]\".\n\n        append_to_labels method is deprecated. Please use append_labels instead.\n            This new function allows to import several labels 10 times faster.\n\n        Append a label to an asset.\n\n        Args:\n            json_response: Label is given here.\n            author_id: ID of the author of the label.\n            label_asset_external_id: External identifier of the asset.\n            label_asset_id: Identifier of the asset.\n            project_id: Identifier of the project.\n            label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`.\n            seconds_to_label: Time to create the label.\n\n        !!! warning\n            Either provide `label_asset_id` or `label_asset_external_id` and `project_id`\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.append_to_labels(label_asset_id=asset_id, json_response={...})\n        \"\"\"\n        check_asset_identifier_arguments(\n            ProjectId(project_id) if project_id else None,\n            cast(ListOrTuple[AssetId], [label_asset_id]) if label_asset_id else None,\n            (\n                cast(ListOrTuple[AssetExternalId], [label_asset_external_id])\n                if label_asset_external_id\n                else None\n            ),\n        )\n\n        if (\n            label_asset_id is None\n            and label_asset_external_id is not None\n            and project_id is not None\n        ):\n            label_asset_id = AssetUseCasesUtils(self.kili_api_gateway).infer_ids_from_external_ids(\n                cast(List[AssetExternalId], [label_asset_external_id]), ProjectId(project_id)\n            )[AssetExternalId(label_asset_external_id)]\n\n        return LabelUseCases(self.kili_api_gateway).append_to_labels(\n            author_id=UserId(author_id) if author_id else None,\n            json_response=json_response,\n            label_type=label_type,\n            asset_id=AssetId(label_asset_id),  # pyright: ignore[reportGeneralTypeIssues]\n            seconds_to_label=seconds_to_label,\n            fields=(\"id\",),\n        )\n\n    @typechecked\n    def export_labels_as_df(\n        self,\n        project_id: str,\n        fields: ListOrTuple[str] = (\"author.email\", \"author.id\", \"createdAt\", \"id\", \"labelType\"),\n        asset_fields: ListOrTuple[str] = (\"externalId\",),\n    ) -&gt; \"pd.DataFrame\":\n        # pylint: disable=line-too-long\n        \"\"\"Get the labels of a project as a pandas DataFrame.\n\n        Args:\n            project_id: Identifier of the project\n            fields: All the fields to request among the possible fields for the labels.\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/label) for all possible fields.\n            asset_fields: All the fields to request among the possible fields for the assets.\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/asset) for all possible fields.\n\n        Returns:\n            A pandas DataFrame containing the labels.\n        \"\"\"\n        return LabelUseCases(self.kili_api_gateway).export_labels_as_df(\n            project_id=ProjectId(project_id), label_fields=fields, asset_fields=asset_fields\n        )\n\n    def export_labels(\n        self,\n        project_id: str,\n        filename: Optional[str],\n        fmt: LabelFormat,\n        asset_ids: Optional[List[str]] = None,\n        layout: SplitOption = \"split\",\n        single_file: bool = False,\n        disable_tqdm: Optional[bool] = None,\n        with_assets: bool = True,\n        external_ids: Optional[List[str]] = None,\n        annotation_modifier: Optional[CocoAnnotationModifier] = None,\n        asset_filter_kwargs: Optional[Dict[str, Any]] = None,\n        normalized_coordinates: Optional[bool] = None,\n        label_type_in: Optional[List[str]] = None,\n        include_sent_back_labels: Optional[bool] = None,\n    ) -&gt; Optional[List[Dict[str, Union[List[str], str]]]]:\n        # pylint: disable=line-too-long\n        \"\"\"Export the project labels with the requested format into the requested output path.\n\n        Args:\n            project_id: Identifier of the project.\n            filename: Relative or full path of the archive that will contain\n                the exported data.\n            fmt: Format of the exported labels.\n            asset_ids: Optional list of the assets internal IDs from which to export the labels.\n            layout: Layout of the exported files. \"split\" means there is one folder\n                per job, \"merged\" that there is one folder with every labels.\n            single_file: Layout of the exported labels. Single file mode is\n                only available for some specific formats (COCO and Kili).\n            disable_tqdm: Disable the progress bar if True.\n            with_assets: Download the assets in the export.\n            external_ids: Optional list of the assets external IDs from which to export the labels.\n            annotation_modifier: (For COCO export only) function that takes the COCO annotation, the\n                COCO image, and the Kili annotation, and should return an updated COCO annotation.\n                This can be used if you want to add a new attribute to the COCO annotation. For\n                example, you can add a method that computes if the annotation is a rectangle or not\n                and add it to the COCO annotation (see example).\n            asset_filter_kwargs: Optional dictionary of arguments to pass to `kili.assets()` in order to filter the assets the labels are exported from. The supported arguments are:\n\n                - `consensus_mark_gte`\n                - `consensus_mark_lte`\n                - `external_id_strictly_in`\n                - `external_id_in`\n                - `honeypot_mark_gte`\n                - `honeypot_mark_lte`\n                - `label_author_in`\n                - `label_labeler_in`\n                - `label_labeler_not_in`\n                - `label_reviewer_in`\n                - `label_reviewer_not_in`\n                - `assignee_in`\n                - `assignee_not_in`\n                - `skipped`: only applicable if the project is in the WorkflowV1 (legacy).\n                - `status_in`: only applicable if the project is in the WorkflowV1 (legacy).\n                - `label_category_search`\n                - `created_at_gte`\n                - `created_at_lte`\n                - `issue_type`\n                - `issue_status`\n                - `inference_mark_gte`\n                - `inference_mark_lte`\n                - `metadata_where`\n                - `step_name_in`: : only applicable if the project is in the WorkflowV2.\n                - `step_status_in`: only applicable if the project is in the WorkflowV2.\n\n                See the documentation of [`kili.assets()`](https://python-sdk-docs.kili-technology.com/latest/sdk/asset/#kili.queries.asset.__init__.QueriesAsset.assets) for more information.\n            normalized_coordinates: This parameter is only effective on the Kili (a.k.a raw) format.\n                If True, the coordinates of the `(x, y)` vertices are normalized between 0 and 1.\n                If False, the json response will contain additional fields with coordinates in absolute values, that is, in pixels.\n            label_type_in: Optional list of label type. Exported assets should have a label whose type belongs to that list.\n                By default, only `DEFAULT` and `REVIEW` labels are exported.\n            include_sent_back_labels: If True, the export will include the labels that have been sent back.\n\n        !!! Info\n            The supported formats are:\n\n            - Yolo V4, V5, V7, V8 for object detection tasks.\n            - Kili (a.k.a raw) for all tasks.\n            - COCO for object detection tasks (bounding box and semantic segmentation).\n            - Pascal VOC for object detection tasks (bounding box).\n\n        !!! warning \"Cloud storage\"\n            Export with asset download (`with_assets=True`) is not allowed for projects connected to a cloud storage.\n\n        !!! Example\n            ```python\n            kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\")\n            ```\n\n        !!! Example\n            ```python\n            def is_rectangle(coco_annotation, coco_image, kili_annotation):\n                is_rectangle = ...\n                return {**coco_annotation, \"attributes\": {\"is_rectangle\": is_rectangle}}\n\n            kili.export_labels(\n                \"your_project_id\",\n                \"export.zip\",\n                \"coco\",\n                annotation_modifier=add_is_rectangle\n            )\n            ```\n        \"\"\"\n        if external_ids is not None and asset_ids is None:\n            id_map = AssetUseCasesUtils(self.kili_api_gateway).infer_ids_from_external_ids(\n                asset_external_ids=cast(List[AssetExternalId], external_ids),\n                project_id=ProjectId(project_id),\n            )\n            resolved_asset_ids = [id_map[AssetExternalId(i)] for i in external_ids]\n        else:\n            resolved_asset_ids = cast(List[AssetId], asset_ids)\n\n        if asset_filter_kwargs and (\n            asset_filter_kwargs.get(\"step_name_in\") is not None\n            or asset_filter_kwargs.get(\"step_status_in\") is not None\n            or asset_filter_kwargs.get(\"status_in\") is not None\n            or asset_filter_kwargs.get(\"skipped\") is not None\n        ):\n            skipped = asset_filter_kwargs.get(\"skipped\")\n            status_in = asset_filter_kwargs.get(\"status_in\")\n            step_name_in = asset_filter_kwargs.get(\"step_name_in\")\n            step_status_in = asset_filter_kwargs.get(\"step_status_in\")\n\n            project_use_cases = ProjectUseCases(self.kili_api_gateway)\n            (\n                project_steps,\n                project_workflow_version,\n            ) = project_use_cases.get_project_steps_and_version(project_id)\n\n            check_asset_workflow_arguments(\n                project_workflow_version=project_workflow_version,\n                asset_workflow_filters={\n                    \"skipped\": skipped,\n                    \"status_in\": status_in,\n                    \"step_name_in\": step_name_in,\n                    \"step_status_in\": step_status_in,\n                },\n            )\n\n            if project_workflow_version == \"V2\" and step_name_in is not None:\n                step_id_in = extract_step_ids_from_project_steps(\n                    project_steps=project_steps,\n                    step_name_in=step_name_in,\n                )\n                asset_filter_kwargs.pop(\"step_name_in\", None)\n                asset_filter_kwargs[\"step_id_in\"] = step_id_in\n\n        try:\n            return export_labels(\n                self,  # pyright: ignore[reportGeneralTypeIssues]\n                asset_ids=resolved_asset_ids,\n                project_id=ProjectId(project_id),\n                export_type=\"latest\",\n                label_format=fmt,\n                split_option=layout,\n                single_file=single_file,\n                output_file=filename,\n                disable_tqdm=disable_tqdm,\n                log_level=\"WARNING\",\n                with_assets=with_assets,\n                annotation_modifier=annotation_modifier,\n                asset_filter_kwargs=asset_filter_kwargs,\n                normalized_coordinates=normalized_coordinates,\n                label_type_in=label_type_in,\n                include_sent_back_labels=include_sent_back_labels,\n            )\n        except NoCompatibleJobError as excp:\n            warnings.warn(str(excp), stacklevel=2)\n            return None\n\n    @typechecked\n    def append_labels_from_shapefiles(\n        self,\n        project_id: str,\n        asset_external_id: str,\n        shapefile_paths: List[str],\n        job_names: List[str],\n        category_names: List[str],\n        from_epsgs: Optional[List[int]] = None,\n        label_type: LabelType = \"DEFAULT\",\n        step_name: Optional[str] = None,\n        model_name: Optional[str] = None,\n    ):\n        \"\"\"Import and convert shapefiles into annotations for a specific asset in a Kili project.\n\n        This method processes shapefile geometries (points, polylines, and polygons), converts them\n        to the appropriate Kili annotation format, and appends them as labels to the specified asset.\n        Each shapefile's geometries are associated with a job and category name in the Kili project.\n\n        Args:\n            project_id: The ID of the Kili project to add the labels to.\n            asset_external_id: The external ID of the asset to label.\n            shapefile_paths: List of file paths to the shapefiles to be processed.\n            job_names: List of job names in the Kili project, corresponding to each shapefile.\n                      Each job name must match an existing job in the project.\n            category_names: List of category names corresponding to each shapefile.\n                           Each category name must exist in the corresponding job's ontology.\n            from_epsgs: Optional list of EPSG codes specifying the coordinate reference systems\n                       of the shapefiles. If not provided, EPSG:4326 (WGS84) is assumed for all files.\n                       All geometries will be transformed to EPSG:4326 before being added to Kili.\n            label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`.\n            step_name: Name of the step to which the labels belong.\n                The label_type must match accordingly.\n            model_name: Name of the model that generated the labels.\n                Only useful when uploading PREDICTION or INFERENCE labels.\n\n        Note:\n            This function requires the 'gis' extra dependencies.\n            Install them with: pip install kili[gis] or pip install 'kili[gis]'\n        \"\"\"\n        json_interface = self.kili_api_gateway.get_project(\n            ProjectId(project_id), (\"jsonInterface\",)\n        )[\"jsonInterface\"]\n\n        json_response = get_json_response_from_shapefiles(\n            shapefile_paths=shapefile_paths,\n            job_names=job_names,\n            category_names=category_names,\n            json_interface=json_interface,\n            from_epsgs=from_epsgs,\n        )\n\n        self.append_labels(\n            project_id=project_id,\n            json_response_array=[json_response],\n            asset_external_id_array=[asset_external_id],\n            label_type=label_type,\n            step_name=step_name,\n            model_name=model_name,\n        )\n\n    # pylint: disable=too-many-branches\n    @typechecked\n    def append_labels_from_geojson_files(\n        self,\n        project_id: str,\n        asset_external_id: str,\n        geojson_file_paths: List[str],\n        job_names: Optional[List[str]] = None,\n        category_names: Optional[List[str]] = None,\n        label_type: LabelType = \"DEFAULT\",\n        step_name: Optional[str] = None,\n        model_name: Optional[str] = None,\n    ):\n        \"\"\"Import and convert GeoJSON files into annotations for a specific asset in a Kili project.\n\n        This method processes GeoJSON feature collections, converts them to the appropriate\n        Kili annotation format, and appends them as labels to the specified asset.\n\n        Three modes of import are supported:\n\n        1. **With `kili` properties**: GeoJSON features contain 'kili' metadata in their properties\n           with job, type, and category information.\n\n        2. **With specific job/category names**: Provide `job_names` and `category_names` to map\n           all compatible geometries from each file to the specified job and category.\n\n        3. **Automatic mapping**: When no 'kili' properties or specific names are provided,\n           geometries are automatically mapped based on type and available jobs.\n\n        Args:\n            project_id: The ID of the Kili project to add the labels to.\n            asset_external_id: The external ID of the asset to label.\n            geojson_file_paths: List of file paths to the GeoJSON files to be processed.\n                Each file should contain a FeatureCollection with features.\n            job_names: Optional list of job names in the Kili project, one for each GeoJSON file.\n                When provided, all compatible geometries from the corresponding file will be\n                mapped to this job. Must have the same length as `geojson_file_paths`.\n            category_names: Optional list of category names, one for each GeoJSON file.\n                When provided, all geometries from the corresponding file will be assigned\n                to this category. Must have the same length as `geojson_file_paths`.\n                Each category must exist in the corresponding job's ontology.\n            label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`.\n            step_name: Name of the step to which the labels belong.\n                The label_type must match accordingly.\n            model_name: Name of the model that generated the labels.\n                Only useful when uploading PREDICTION or INFERENCE labels.\n\n\n        Note:\n            **Geometry-to-job compatibility:**\n            - Point geometries \u2192 jobs with 'marker' tool\n            - LineString geometries \u2192 jobs with 'polyline' tool\n            - Polygon geometries \u2192 jobs with 'polygon' or 'semantic' tool\n            - MultiPolygon geometries \u2192 jobs with 'semantic' tool\n\n            **GeoJSON 'kili' properties structure (Mode 1):**\n            ```json\n            {\n                \"properties\": {\n                    \"kili\": {\n                        \"job\": \"job_name\",\n                        \"type\": \"marker|polyline|polygon|semantic\",\n                        \"categories\": [{\"name\": \"category_name\"}]\n                    }\n                }\n            }\n            ```\n\n            **Automatic mapping priority (Mode 3):**\n            - Point \u2192 first available 'marker' job\n            - LineString \u2192 first available 'polyline' job\n            - Polygon \u2192 first available 'polygon' job, fallback to 'semantic'\n            - MultiPolygon \u2192 first available 'semantic' job\n\n        Examples:\n            Mode 1 - With kili properties in GeoJSON:\n            &gt;&gt;&gt; kili.append_labels_from_geojson_files(\n                    project_id=\"project_id\",\n                    asset_external_id=\"asset_1\",\n                    geojson_file_paths=[\"annotations.geojson\"]\n                )\n\n            Mode 2 - With specific job/category mapping:\n            &gt;&gt;&gt; kili.append_labels_from_geojson_files(\n                    project_id=\"project_id\",\n                    asset_external_id=\"asset_1\",\n                    geojson_file_paths=[\"points.geojson\", \"polygons.geojson\"],\n                    job_names=[\"MARKERS\", \"POLYGONS\"],\n                    category_names=[\"BUILDING\", \"ROAD\"]\n                )\n\n            Mode 3 - Automatic mapping:\n            &gt;&gt;&gt; kili.append_labels_from_geojson_files(\n                    project_id=\"project_id\",\n                    asset_external_id=\"asset_1\",\n                    geojson_file_paths=[\"mixed_geometries.geojson\"]\n                )\n        \"\"\"\n        if job_names is not None and category_names is not None:\n            if len(job_names) != len(geojson_file_paths):\n                raise ValueError(\"job_names must have the same length as geojson_file_paths\")\n            if len(category_names) != len(geojson_file_paths):\n                raise ValueError(\"category_names must have the same length as geojson_file_paths\")\n            if len(job_names) != len(category_names):\n                raise ValueError(\"job_names and category_names must have the same length\")\n        elif job_names is not None or category_names is not None:\n            raise ValueError(\n                \"Both job_names and category_names must be provided together, or both must be None\"\n            )\n\n        json_interface = self.kili_api_gateway.get_project(\n            ProjectId(project_id), (\"jsonInterface\",)\n        )[\"jsonInterface\"]\n\n        merged_json_response = {}\n\n        for file_index, file_path in enumerate(geojson_file_paths):\n            with open(file_path, encoding=\"utf-8\") as file:\n                feature_collection = json.load(file)\n\n            if job_names is not None and category_names is not None:\n                enriched_feature_collection = enrich_geojson_with_specific_mapping(\n                    feature_collection,\n                    json_interface,\n                    job_names[file_index],\n                    category_names[file_index],\n                )\n            else:\n                enriched_feature_collection = enrich_geojson_with_kili_properties(\n                    feature_collection, json_interface\n                )\n\n            json_response = geojson_feature_collection_to_kili_json_response(\n                enriched_feature_collection\n            )\n\n            for job_name, job_data in json_response.items():\n                if job_name not in merged_json_response:\n                    merged_json_response[job_name] = job_data\n                else:\n                    for key, value in job_data.items():\n                        if key == \"annotations\":\n                            merged_json_response[job_name].setdefault(\"annotations\", []).extend(\n                                value\n                            )\n                        else:\n                            merged_json_response[job_name][key] = value\n\n        self.append_labels(\n            project_id=project_id,\n            json_response_array=[merged_json_response],\n            asset_external_id_array=[asset_external_id],\n            label_type=label_type,\n            step_name=step_name,\n            model_name=model_name,\n        )\n</code></pre> <p>Set of Label subscriptions.</p> Source code in <code>kili/entrypoints/subscriptions/label/__init__.py</code> <pre><code>class SubscriptionsLabel:\n    \"\"\"Set of Label subscriptions.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    @typechecked\n    def label_created_or_updated(\n        self, project_id: str, callback: Callable[[str, str], None]\n    ) -&gt; SubscriptionGraphQLClient:\n        # pylint: disable=line-too-long\n        \"\"\"Subscribe a callback to a project, which is executed when a label is created or updated.\n\n        Args:\n            project_id: Identifier of the project\n            callback: This function takes as input the id of the asset and its content.\n\n        Returns:\n            A subscription client.\n\n        !!! example \"Recipe\"\n            For more detailed examples on how to use Webhooks,\n            See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/main/recipes/webhooks_example.ipynb)\n        \"\"\"\n        ws_endpoint = self.graphql_client.endpoint.replace(\"http\", \"ws\")\n        websocket = SubscriptionGraphQLClient(ws_endpoint)\n        headers = {\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"}\n        authorization = f\"X-API-Key: {self.api_key}\"  # type: ignore  # pylint: disable=no-member\n        headers[\"Authorization\"] = authorization\n        variables = {\"projectID\": project_id}\n        websocket.subscribe(\n            GQL_LABEL_CREATED_OR_UPDATED,\n            variables=variables,\n            callback=callback,\n            headers=headers,\n            authorization=authorization,\n        )\n        return websocket\n</code></pre>"},{"location":"sdk/label/#kili.presentation.client.label.LabelClientMethods.append_labels","title":"<code>append_labels(self, asset_id_array=None, json_response_array=(), author_id_array=None, seconds_to_label_array=None, model_name=None, label_type='DEFAULT', project_id=None, asset_external_id_array=None, disable_tqdm=None, overwrite=False, step_name=None, reviewed_label_id_array=None)</code>","text":"<p>Append labels to assets.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id_array</code> <code>Optional[List[str]]</code> <p>list of asset internal ids to append labels on.</p> <code>None</code> <code>json_response_array</code> <code>Union[List[Dict], Tuple[Dict, ...]]</code> <p>list of labels to append.</p> <code>()</code> <code>author_id_array</code> <code>Optional[List[str]]</code> <p>list of the author id of the labels.</p> <code>None</code> <code>seconds_to_label_array</code> <code>Optional[List[int]]</code> <p>list of times taken to produce the label, in seconds.</p> <code>None</code> <code>model_name</code> <code>Optional[str]</code> <p>Name of the model that generated the labels. Only useful when uploading PREDICTION or INFERENCE labels.</p> <code>None</code> <code>label_type</code> <code>Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW']</code> <p>Can be one of <code>AUTOSAVE</code>, <code>DEFAULT</code>, <code>PREDICTION</code>, <code>REVIEW</code> or <code>INFERENCE</code>.</p> <code>'DEFAULT'</code> <code>project_id</code> <code>Optional[str]</code> <p>Identifier of the project.</p> <code>None</code> <code>asset_external_id_array</code> <code>Optional[List[str]]</code> <p>list of asset external ids to append labels on.</p> <code>None</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>Disable tqdm progress bar.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>when uploading prediction or inference labels, if True, it will overwrite existing labels with the same model name and of the same label type, on the targeted assets.</p> <code>False</code> <code>reviewed_label_id_array</code> <code>Optional[List[str]]</code> <p>list of IDs of labels being reviewed. Only useful when uploading REVIEW labels.</p> <code>None</code> <code>step_name</code> <code>Optional[str]</code> <p>Name of the step to which the labels belong. The label_type must match accordingly.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[Literal['id'], str]]</code> <p>A list of dictionaries with the label ids.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_labels(\n        asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'],\n        json_response_array=[{...}, {...}]\n    )\n</code></pre> Source code in <code>kili/presentation/client/label.py</code> <pre><code>def append_labels(\n    self,\n    asset_id_array: Optional[List[str]] = None,\n    json_response_array: ListOrTuple[Dict] = (),\n    author_id_array: Optional[List[str]] = None,\n    seconds_to_label_array: Optional[List[int]] = None,\n    model_name: Optional[str] = None,\n    label_type: LabelType = \"DEFAULT\",\n    project_id: Optional[str] = None,\n    asset_external_id_array: Optional[List[str]] = None,\n    disable_tqdm: Optional[bool] = None,\n    overwrite: bool = False,\n    step_name: Optional[str] = None,\n    reviewed_label_id_array: Optional[List[str]] = None,\n) -&gt; List[Dict[Literal[\"id\"], str]]:\n    \"\"\"Append labels to assets.\n\n    Args:\n        asset_id_array: list of asset internal ids to append labels on.\n        json_response_array: list of labels to append.\n        author_id_array: list of the author id of the labels.\n        seconds_to_label_array: list of times taken to produce the label, in seconds.\n        model_name: Name of the model that generated the labels.\n            Only useful when uploading PREDICTION or INFERENCE labels.\n        label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`.\n        project_id: Identifier of the project.\n        asset_external_id_array: list of asset external ids to append labels on.\n        disable_tqdm: Disable tqdm progress bar.\n        overwrite: when uploading prediction or inference labels, if True,\n            it will overwrite existing labels with the same model name\n            and of the same label type, on the targeted assets.\n        reviewed_label_id_array: list of IDs of labels being reviewed.\n            Only useful when uploading REVIEW labels.\n        step_name: Name of the step to which the labels belong.\n            The label_type must match accordingly.\n\n    Returns:\n        A list of dictionaries with the label ids.\n\n    Examples:\n        &gt;&gt;&gt; kili.append_labels(\n                asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'],\n                json_response_array=[{...}, {...}]\n            )\n    \"\"\"\n    if len(json_response_array) == 0:\n        raise ValueError(\n            \"json_response_array is empty, you must provide at least one label to upload\"\n        )\n\n    check_asset_identifier_arguments(\n        ProjectId(project_id) if project_id else None,\n        cast(ListOrTuple[AssetId], asset_id_array) if asset_id_array else None,\n        (\n            cast(ListOrTuple[AssetExternalId], asset_external_id_array)\n            if asset_external_id_array\n            else None\n        ),\n    )\n\n    assert_all_arrays_have_same_size(\n        [\n            seconds_to_label_array,\n            author_id_array,\n            json_response_array,\n            asset_external_id_array,\n            asset_id_array,\n            reviewed_label_id_array,\n        ]\n    )\n\n    labels = [\n        LabelToCreateUseCaseInput(\n            asset_id=AssetId(asset_id) if asset_id else None,\n            asset_external_id=AssetExternalId(asset_external_id) if asset_external_id else None,\n            json_response=json_response,\n            seconds_to_label=seconds_to_label,\n            author_id=UserId(author_id) if author_id else None,\n            label_type=label_type,\n            model_name=model_name,\n            referenced_label_id=reviewed_label_id,\n        )\n        for (\n            asset_id,\n            asset_external_id,\n            json_response,\n            seconds_to_label,\n            author_id,\n            reviewed_label_id,\n        ) in zip(\n            asset_id_array or repeat(None),\n            asset_external_id_array or repeat(None),\n            json_response_array,\n            seconds_to_label_array or repeat(None),\n            author_id_array or repeat(None),\n            reviewed_label_id_array or repeat(None),\n        )\n    ]\n\n    return LabelUseCases(self.kili_api_gateway).append_labels(\n        fields=(\"id\",),\n        disable_tqdm=disable_tqdm,\n        label_type=label_type,\n        step_name=step_name,\n        labels=labels,\n        overwrite=overwrite,\n        project_id=ProjectId(project_id) if project_id else None,\n    )\n</code></pre>"},{"location":"sdk/label/#kili.presentation.client.label.LabelClientMethods.append_labels_from_geojson_files","title":"<code>append_labels_from_geojson_files(self, project_id, asset_external_id, geojson_file_paths, job_names=None, category_names=None, label_type='DEFAULT', step_name=None, model_name=None)</code>","text":"<p>Import and convert GeoJSON files into annotations for a specific asset in a Kili project.</p> <p>This method processes GeoJSON feature collections, converts them to the appropriate Kili annotation format, and appends them as labels to the specified asset.</p> <p>Three modes of import are supported:</p> <ol> <li> <p>With <code>kili</code> properties: GeoJSON features contain 'kili' metadata in their properties    with job, type, and category information.</p> </li> <li> <p>With specific job/category names: Provide <code>job_names</code> and <code>category_names</code> to map    all compatible geometries from each file to the specified job and category.</p> </li> <li> <p>Automatic mapping: When no 'kili' properties or specific names are provided,    geometries are automatically mapped based on type and available jobs.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the Kili project to add the labels to.</p> required <code>asset_external_id</code> <code>str</code> <p>The external ID of the asset to label.</p> required <code>geojson_file_paths</code> <code>List[str]</code> <p>List of file paths to the GeoJSON files to be processed. Each file should contain a FeatureCollection with features.</p> required <code>job_names</code> <code>Optional[List[str]]</code> <p>Optional list of job names in the Kili project, one for each GeoJSON file. When provided, all compatible geometries from the corresponding file will be mapped to this job. Must have the same length as <code>geojson_file_paths</code>.</p> <code>None</code> <code>category_names</code> <code>Optional[List[str]]</code> <p>Optional list of category names, one for each GeoJSON file. When provided, all geometries from the corresponding file will be assigned to this category. Must have the same length as <code>geojson_file_paths</code>. Each category must exist in the corresponding job's ontology.</p> <code>None</code> <code>label_type</code> <code>Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW']</code> <p>Can be one of <code>AUTOSAVE</code>, <code>DEFAULT</code>, <code>PREDICTION</code>, <code>REVIEW</code> or <code>INFERENCE</code>.</p> <code>'DEFAULT'</code> <code>step_name</code> <code>Optional[str]</code> <p>Name of the step to which the labels belong. The label_type must match accordingly.</p> <code>None</code> <code>model_name</code> <code>Optional[str]</code> <p>Name of the model that generated the labels. Only useful when uploading PREDICTION or INFERENCE labels.</p> <code>None</code> <p>Note</p> <p>Geometry-to-job compatibility: - Point geometries \u2192 jobs with 'marker' tool - LineString geometries \u2192 jobs with 'polyline' tool - Polygon geometries \u2192 jobs with 'polygon' or 'semantic' tool - MultiPolygon geometries \u2192 jobs with 'semantic' tool</p> <p>GeoJSON 'kili' properties structure (Mode 1): <pre><code>{\n    \"properties\": {\n        \"kili\": {\n            \"job\": \"job_name\",\n            \"type\": \"marker|polyline|polygon|semantic\",\n            \"categories\": [{\"name\": \"category_name\"}]\n        }\n    }\n}\n</code></pre></p> <p>Automatic mapping priority (Mode 3): - Point \u2192 first available 'marker' job - LineString \u2192 first available 'polyline' job - Polygon \u2192 first available 'polygon' job, fallback to 'semantic' - MultiPolygon \u2192 first available 'semantic' job</p> <p>Examples:</p> <p>Mode 1 - With kili properties in GeoJSON:</p> <pre><code>&gt;&gt;&gt; kili.append_labels_from_geojson_files(\n        project_id=\"project_id\",\n        asset_external_id=\"asset_1\",\n        geojson_file_paths=[\"annotations.geojson\"]\n    )\n</code></pre> <p>Mode 2 - With specific job/category mapping:</p> <pre><code>&gt;&gt;&gt; kili.append_labels_from_geojson_files(\n        project_id=\"project_id\",\n        asset_external_id=\"asset_1\",\n        geojson_file_paths=[\"points.geojson\", \"polygons.geojson\"],\n        job_names=[\"MARKERS\", \"POLYGONS\"],\n        category_names=[\"BUILDING\", \"ROAD\"]\n    )\n</code></pre> <p>Mode 3 - Automatic mapping:</p> <pre><code>&gt;&gt;&gt; kili.append_labels_from_geojson_files(\n        project_id=\"project_id\",\n        asset_external_id=\"asset_1\",\n        geojson_file_paths=[\"mixed_geometries.geojson\"]\n    )\n</code></pre> Source code in <code>kili/presentation/client/label.py</code> <pre><code>def append_labels_from_geojson_files(\n    self,\n    project_id: str,\n    asset_external_id: str,\n    geojson_file_paths: List[str],\n    job_names: Optional[List[str]] = None,\n    category_names: Optional[List[str]] = None,\n    label_type: LabelType = \"DEFAULT\",\n    step_name: Optional[str] = None,\n    model_name: Optional[str] = None,\n):\n    \"\"\"Import and convert GeoJSON files into annotations for a specific asset in a Kili project.\n\n    This method processes GeoJSON feature collections, converts them to the appropriate\n    Kili annotation format, and appends them as labels to the specified asset.\n\n    Three modes of import are supported:\n\n    1. **With `kili` properties**: GeoJSON features contain 'kili' metadata in their properties\n       with job, type, and category information.\n\n    2. **With specific job/category names**: Provide `job_names` and `category_names` to map\n       all compatible geometries from each file to the specified job and category.\n\n    3. **Automatic mapping**: When no 'kili' properties or specific names are provided,\n       geometries are automatically mapped based on type and available jobs.\n\n    Args:\n        project_id: The ID of the Kili project to add the labels to.\n        asset_external_id: The external ID of the asset to label.\n        geojson_file_paths: List of file paths to the GeoJSON files to be processed.\n            Each file should contain a FeatureCollection with features.\n        job_names: Optional list of job names in the Kili project, one for each GeoJSON file.\n            When provided, all compatible geometries from the corresponding file will be\n            mapped to this job. Must have the same length as `geojson_file_paths`.\n        category_names: Optional list of category names, one for each GeoJSON file.\n            When provided, all geometries from the corresponding file will be assigned\n            to this category. Must have the same length as `geojson_file_paths`.\n            Each category must exist in the corresponding job's ontology.\n        label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`.\n        step_name: Name of the step to which the labels belong.\n            The label_type must match accordingly.\n        model_name: Name of the model that generated the labels.\n            Only useful when uploading PREDICTION or INFERENCE labels.\n\n\n    Note:\n        **Geometry-to-job compatibility:**\n        - Point geometries \u2192 jobs with 'marker' tool\n        - LineString geometries \u2192 jobs with 'polyline' tool\n        - Polygon geometries \u2192 jobs with 'polygon' or 'semantic' tool\n        - MultiPolygon geometries \u2192 jobs with 'semantic' tool\n\n        **GeoJSON 'kili' properties structure (Mode 1):**\n        ```json\n        {\n            \"properties\": {\n                \"kili\": {\n                    \"job\": \"job_name\",\n                    \"type\": \"marker|polyline|polygon|semantic\",\n                    \"categories\": [{\"name\": \"category_name\"}]\n                }\n            }\n        }\n        ```\n\n        **Automatic mapping priority (Mode 3):**\n        - Point \u2192 first available 'marker' job\n        - LineString \u2192 first available 'polyline' job\n        - Polygon \u2192 first available 'polygon' job, fallback to 'semantic'\n        - MultiPolygon \u2192 first available 'semantic' job\n\n    Examples:\n        Mode 1 - With kili properties in GeoJSON:\n        &gt;&gt;&gt; kili.append_labels_from_geojson_files(\n                project_id=\"project_id\",\n                asset_external_id=\"asset_1\",\n                geojson_file_paths=[\"annotations.geojson\"]\n            )\n\n        Mode 2 - With specific job/category mapping:\n        &gt;&gt;&gt; kili.append_labels_from_geojson_files(\n                project_id=\"project_id\",\n                asset_external_id=\"asset_1\",\n                geojson_file_paths=[\"points.geojson\", \"polygons.geojson\"],\n                job_names=[\"MARKERS\", \"POLYGONS\"],\n                category_names=[\"BUILDING\", \"ROAD\"]\n            )\n\n        Mode 3 - Automatic mapping:\n        &gt;&gt;&gt; kili.append_labels_from_geojson_files(\n                project_id=\"project_id\",\n                asset_external_id=\"asset_1\",\n                geojson_file_paths=[\"mixed_geometries.geojson\"]\n            )\n    \"\"\"\n    if job_names is not None and category_names is not None:\n        if len(job_names) != len(geojson_file_paths):\n            raise ValueError(\"job_names must have the same length as geojson_file_paths\")\n        if len(category_names) != len(geojson_file_paths):\n            raise ValueError(\"category_names must have the same length as geojson_file_paths\")\n        if len(job_names) != len(category_names):\n            raise ValueError(\"job_names and category_names must have the same length\")\n    elif job_names is not None or category_names is not None:\n        raise ValueError(\n            \"Both job_names and category_names must be provided together, or both must be None\"\n        )\n\n    json_interface = self.kili_api_gateway.get_project(\n        ProjectId(project_id), (\"jsonInterface\",)\n    )[\"jsonInterface\"]\n\n    merged_json_response = {}\n\n    for file_index, file_path in enumerate(geojson_file_paths):\n        with open(file_path, encoding=\"utf-8\") as file:\n            feature_collection = json.load(file)\n\n        if job_names is not None and category_names is not None:\n            enriched_feature_collection = enrich_geojson_with_specific_mapping(\n                feature_collection,\n                json_interface,\n                job_names[file_index],\n                category_names[file_index],\n            )\n        else:\n            enriched_feature_collection = enrich_geojson_with_kili_properties(\n                feature_collection, json_interface\n            )\n\n        json_response = geojson_feature_collection_to_kili_json_response(\n            enriched_feature_collection\n        )\n\n        for job_name, job_data in json_response.items():\n            if job_name not in merged_json_response:\n                merged_json_response[job_name] = job_data\n            else:\n                for key, value in job_data.items():\n                    if key == \"annotations\":\n                        merged_json_response[job_name].setdefault(\"annotations\", []).extend(\n                            value\n                        )\n                    else:\n                        merged_json_response[job_name][key] = value\n\n    self.append_labels(\n        project_id=project_id,\n        json_response_array=[merged_json_response],\n        asset_external_id_array=[asset_external_id],\n        label_type=label_type,\n        step_name=step_name,\n        model_name=model_name,\n    )\n</code></pre>"},{"location":"sdk/label/#kili.presentation.client.label.LabelClientMethods.append_labels_from_shapefiles","title":"<code>append_labels_from_shapefiles(self, project_id, asset_external_id, shapefile_paths, job_names, category_names, from_epsgs=None, label_type='DEFAULT', step_name=None, model_name=None)</code>","text":"<p>Import and convert shapefiles into annotations for a specific asset in a Kili project.</p> <p>This method processes shapefile geometries (points, polylines, and polygons), converts them to the appropriate Kili annotation format, and appends them as labels to the specified asset. Each shapefile's geometries are associated with a job and category name in the Kili project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the Kili project to add the labels to.</p> required <code>asset_external_id</code> <code>str</code> <p>The external ID of the asset to label.</p> required <code>shapefile_paths</code> <code>List[str]</code> <p>List of file paths to the shapefiles to be processed.</p> required <code>job_names</code> <code>List[str]</code> <p>List of job names in the Kili project, corresponding to each shapefile.       Each job name must match an existing job in the project.</p> required <code>category_names</code> <code>List[str]</code> <p>List of category names corresponding to each shapefile.            Each category name must exist in the corresponding job's ontology.</p> required <code>from_epsgs</code> <code>Optional[List[int]]</code> <p>Optional list of EPSG codes specifying the coordinate reference systems        of the shapefiles. If not provided, EPSG:4326 (WGS84) is assumed for all files.        All geometries will be transformed to EPSG:4326 before being added to Kili.</p> <code>None</code> <code>label_type</code> <code>Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW']</code> <p>Can be one of <code>AUTOSAVE</code>, <code>DEFAULT</code>, <code>PREDICTION</code>, <code>REVIEW</code> or <code>INFERENCE</code>.</p> <code>'DEFAULT'</code> <code>step_name</code> <code>Optional[str]</code> <p>Name of the step to which the labels belong. The label_type must match accordingly.</p> <code>None</code> <code>model_name</code> <code>Optional[str]</code> <p>Name of the model that generated the labels. Only useful when uploading PREDICTION or INFERENCE labels.</p> <code>None</code> <p>Note</p> <p>This function requires the 'gis' extra dependencies. Install them with: pip install kili[gis] or pip install 'kili[gis]'</p> Source code in <code>kili/presentation/client/label.py</code> <pre><code>def append_labels_from_shapefiles(\n    self,\n    project_id: str,\n    asset_external_id: str,\n    shapefile_paths: List[str],\n    job_names: List[str],\n    category_names: List[str],\n    from_epsgs: Optional[List[int]] = None,\n    label_type: LabelType = \"DEFAULT\",\n    step_name: Optional[str] = None,\n    model_name: Optional[str] = None,\n):\n    \"\"\"Import and convert shapefiles into annotations for a specific asset in a Kili project.\n\n    This method processes shapefile geometries (points, polylines, and polygons), converts them\n    to the appropriate Kili annotation format, and appends them as labels to the specified asset.\n    Each shapefile's geometries are associated with a job and category name in the Kili project.\n\n    Args:\n        project_id: The ID of the Kili project to add the labels to.\n        asset_external_id: The external ID of the asset to label.\n        shapefile_paths: List of file paths to the shapefiles to be processed.\n        job_names: List of job names in the Kili project, corresponding to each shapefile.\n                  Each job name must match an existing job in the project.\n        category_names: List of category names corresponding to each shapefile.\n                       Each category name must exist in the corresponding job's ontology.\n        from_epsgs: Optional list of EPSG codes specifying the coordinate reference systems\n                   of the shapefiles. If not provided, EPSG:4326 (WGS84) is assumed for all files.\n                   All geometries will be transformed to EPSG:4326 before being added to Kili.\n        label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`.\n        step_name: Name of the step to which the labels belong.\n            The label_type must match accordingly.\n        model_name: Name of the model that generated the labels.\n            Only useful when uploading PREDICTION or INFERENCE labels.\n\n    Note:\n        This function requires the 'gis' extra dependencies.\n        Install them with: pip install kili[gis] or pip install 'kili[gis]'\n    \"\"\"\n    json_interface = self.kili_api_gateway.get_project(\n        ProjectId(project_id), (\"jsonInterface\",)\n    )[\"jsonInterface\"]\n\n    json_response = get_json_response_from_shapefiles(\n        shapefile_paths=shapefile_paths,\n        job_names=job_names,\n        category_names=category_names,\n        json_interface=json_interface,\n        from_epsgs=from_epsgs,\n    )\n\n    self.append_labels(\n        project_id=project_id,\n        json_response_array=[json_response],\n        asset_external_id_array=[asset_external_id],\n        label_type=label_type,\n        step_name=step_name,\n        model_name=model_name,\n    )\n</code></pre>"},{"location":"sdk/label/#kili.presentation.client.label.LabelClientMethods.append_to_labels","title":"<code>append_to_labels(self, json_response, author_id=None, label_asset_external_id=None, label_asset_id=None, label_type='DEFAULT', project_id=None, seconds_to_label=0)</code>","text":"<p>!!! danger \"[DEPRECATED]\".</p> <p>append_to_labels method is deprecated. Please use append_labels instead.     This new function allows to import several labels 10 times faster.</p> <p>Append a label to an asset.</p> <p>Parameters:</p> Name Type Description Default <code>json_response</code> <code>dict</code> <p>Label is given here.</p> required <code>author_id</code> <code>Optional[str]</code> <p>ID of the author of the label.</p> <code>None</code> <code>label_asset_external_id</code> <code>Optional[str]</code> <p>External identifier of the asset.</p> <code>None</code> <code>label_asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>Identifier of the project.</p> <code>None</code> <code>label_type</code> <code>Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW']</code> <p>Can be one of <code>AUTOSAVE</code>, <code>DEFAULT</code>, <code>PREDICTION</code>, <code>REVIEW</code> or <code>INFERENCE</code>.</p> <code>'DEFAULT'</code> <code>seconds_to_label</code> <code>Optional[int]</code> <p>Time to create the label.</p> <code>0</code> <p>Warning</p> <p>Either provide <code>label_asset_id</code> or <code>label_asset_external_id</code> and <code>project_id</code></p> <p>Returns:</p> Type Description <code>Dict[Literal['id'], str]</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_to_labels(label_asset_id=asset_id, json_response={...})\n</code></pre> Source code in <code>kili/presentation/client/label.py</code> <pre><code>@deprecate(\n    msg=(\n        \"append_to_labels method is deprecated. Please use append_labels instead. This new\"\n        \" function allows to import several labels 10 times faster.\"\n    )\n)\n@typechecked\ndef append_to_labels(\n    self,\n    json_response: dict,\n    author_id: Optional[str] = None,\n    label_asset_external_id: Optional[str] = None,\n    label_asset_id: Optional[str] = None,\n    label_type: LabelType = \"DEFAULT\",\n    project_id: Optional[str] = None,\n    seconds_to_label: Optional[int] = 0,\n) -&gt; Dict[Literal[\"id\"], str]:\n    \"\"\"!!! danger \"[DEPRECATED]\".\n\n    append_to_labels method is deprecated. Please use append_labels instead.\n        This new function allows to import several labels 10 times faster.\n\n    Append a label to an asset.\n\n    Args:\n        json_response: Label is given here.\n        author_id: ID of the author of the label.\n        label_asset_external_id: External identifier of the asset.\n        label_asset_id: Identifier of the asset.\n        project_id: Identifier of the project.\n        label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`.\n        seconds_to_label: Time to create the label.\n\n    !!! warning\n        Either provide `label_asset_id` or `label_asset_external_id` and `project_id`\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.append_to_labels(label_asset_id=asset_id, json_response={...})\n    \"\"\"\n    check_asset_identifier_arguments(\n        ProjectId(project_id) if project_id else None,\n        cast(ListOrTuple[AssetId], [label_asset_id]) if label_asset_id else None,\n        (\n            cast(ListOrTuple[AssetExternalId], [label_asset_external_id])\n            if label_asset_external_id\n            else None\n        ),\n    )\n\n    if (\n        label_asset_id is None\n        and label_asset_external_id is not None\n        and project_id is not None\n    ):\n        label_asset_id = AssetUseCasesUtils(self.kili_api_gateway).infer_ids_from_external_ids(\n            cast(List[AssetExternalId], [label_asset_external_id]), ProjectId(project_id)\n        )[AssetExternalId(label_asset_external_id)]\n\n    return LabelUseCases(self.kili_api_gateway).append_to_labels(\n        author_id=UserId(author_id) if author_id else None,\n        json_response=json_response,\n        label_type=label_type,\n        asset_id=AssetId(label_asset_id),  # pyright: ignore[reportGeneralTypeIssues]\n        seconds_to_label=seconds_to_label,\n        fields=(\"id\",),\n    )\n</code></pre>"},{"location":"sdk/label/#kili.presentation.client.label.LabelClientMethods.count_labels","title":"<code>count_labels(self, project_id, asset_id=None, asset_status_in=None, asset_external_id_in=None, asset_external_id_strictly_in=None, asset_step_name_in=None, asset_step_status_in=None, author_in=None, created_at=None, created_at_gte=None, created_at_lte=None, honeypot_mark_gte=None, honeypot_mark_lte=None, label_id=None, type_in=None, user_id=None, category_search=None, id_contains=None)</code>","text":"<p>Get the number of labels for the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code> <code>asset_status_in</code> <code>Optional[List[Literal['TODO', 'ONGOING', 'LABELED', 'REVIEWED', 'TO_REVIEW']]]</code> <p>Returned labels should have a status that belongs to that list, if given. Possible choices : <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code> or <code>REVIEWED</code></p> <code>None</code> <code>asset_external_id_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that belongs to that list, if given.</p> <code>None</code> <code>asset_external_id_strictly_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that exactly matches one of the ids in that list, if given.</p> <code>None</code> <code>asset_step_name_in</code> <code>Optional[List[str]]</code> <p>Returned assets are in a step whose name belong to that list, if given. Only applicable if the project is in WorkflowV2.</p> <code>None</code> <code>asset_step_status_in</code> <code>Optional[List[Literal['TO_DO', 'DOING', 'PARTIALLY_DONE', 'REDO', 'DONE', 'SKIPPED']]]</code> <p>Returned assets have the status of their step that belongs to that list, if given. Possible choices: <code>TO_DO</code>, <code>DOING</code>, <code>PARTIALLY_DONE</code>, <code>REDO</code>, <code>DONE</code>, <code>SKIPPED</code>. Only applicable if the project is in WorkflowV2.</p> <code>None</code> <code>author_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>created_at</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is equal to this date.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is greater than this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is lower than this date.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is greater than this number.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is lower than this number.</p> <code>None</code> <code>label_id</code> <code>Optional[str]</code> <p>Identifier of the label.</p> <code>None</code> <code>type_in</code> <code>Optional[List[Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW']]]</code> <p>Returned labels should have a label whose type belongs to that list, if given.</p> <code>None</code> <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>category_search</code> <code>Optional[str]</code> <p>Query to filter labels based on the content of their jsonResponse</p> <code>None</code> <code>id_contains</code> <code>Optional[List[str]]</code> <p>Filters out labels not belonging to that list. If empty, no filtering is applied.</p> <code>None</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of labels with the parameters provided</p> Source code in <code>kili/presentation/client/label.py</code> <pre><code>def count_labels(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_status_in: Optional[List[AssetStatus]] = None,\n    asset_external_id_in: Optional[List[str]] = None,\n    asset_external_id_strictly_in: Optional[List[str]] = None,\n    asset_step_name_in: Optional[List[str]] = None,\n    asset_step_status_in: Optional[List[StatusInStep]] = None,\n    author_in: Optional[List[str]] = None,\n    created_at: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    label_id: Optional[str] = None,\n    type_in: Optional[List[LabelType]] = None,\n    user_id: Optional[str] = None,\n    category_search: Optional[str] = None,\n    id_contains: Optional[List[str]] = None,\n) -&gt; int:\n    # pylint: disable=line-too-long\n    \"\"\"Get the number of labels for the given parameters.\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset.\n        asset_status_in: Returned labels should have a status that belongs to that list, if given.\n            Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED`\n        asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n        asset_external_id_strictly_in: Returned labels should have an external id that exactly matches one of the ids in that list, if given.\n        asset_step_name_in: Returned assets are in a step whose name belong to that list, if given.\n            Only applicable if the project is in WorkflowV2.\n        asset_step_status_in: Returned assets have the status of their step that belongs to that list, if given.\n            Possible choices: `TO_DO`, `DOING`, `PARTIALLY_DONE`, `REDO`, `DONE`, `SKIPPED`.\n            Only applicable if the project is in WorkflowV2.\n        author_in: Returned labels should have been made by authors in that list, if given.\n            An author can be designated by the first name, the last name, or the first name + last name.\n        created_at: Returned labels should have a label whose creation date is equal to this date.\n        created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n        created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n        honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n        honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n        label_id: Identifier of the label.\n        type_in: Returned labels should have a label whose type belongs to that list, if given.\n        user_id: Identifier of the user.\n        category_search: Query to filter labels based on the content of their jsonResponse\n        id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        The number of labels with the parameters provided\n    \"\"\"\n    if category_search:\n        validate_category_search_query(category_search)\n\n    asset_step_id_in = None\n    if (\n        asset_status_in is not None\n        or asset_step_name_in is not None\n        or asset_step_status_in is not None\n    ):\n        project_use_cases = ProjectUseCases(self.kili_api_gateway)\n        (\n            project_steps,\n            project_workflow_version,\n        ) = project_use_cases.get_project_steps_and_version(project_id)\n        check_asset_workflow_arguments(\n            project_workflow_version=project_workflow_version,\n            asset_workflow_filters={\n                \"skipped\": None,\n                \"step_name_in\": asset_step_name_in,\n                \"step_status_in\": asset_step_status_in,\n                \"status_in\": asset_status_in,\n            },\n        )\n        if project_workflow_version == \"V2\" and asset_step_name_in is not None:\n            asset_step_id_in = extract_step_ids_from_project_steps(\n                project_steps=project_steps,\n                step_name_in=asset_step_name_in,\n            )\n\n    filters = LabelFilters(\n        project_id=ProjectId(project_id),\n        asset=AssetFilters(\n            project_id=ProjectId(project_id),\n            asset_id=AssetId(asset_id) if asset_id else None,\n            status_in=asset_status_in,\n            external_id_in=(\n                cast(ListOrTuple[AssetExternalId], asset_external_id_in)\n                if asset_external_id_in\n                else None\n            ),\n            external_id_strictly_in=(\n                cast(ListOrTuple[AssetExternalId], asset_external_id_strictly_in)\n                if asset_external_id_strictly_in\n                else None\n            ),\n            step_id_in=asset_step_id_in,\n            step_status_in=asset_step_status_in,\n        ),\n        author_in=author_in,\n        created_at=created_at,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        honeypot_mark_gte=honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lte,\n        id_in=cast(List[LabelId], id_contains) if id_contains else None,\n        id=LabelId(label_id) if label_id else None,\n        type_in=type_in,\n        user=UserFilter(id=UserId(user_id)) if user_id else None,\n        search=category_search,\n        consensus_mark_gte=None,\n        consensus_mark_lte=None,\n        labeler_in=None,\n        reviewer_in=None,\n    )\n\n    return LabelUseCases(self.kili_api_gateway).count_labels(filters=filters)\n</code></pre>"},{"location":"sdk/label/#kili.presentation.client.label.LabelClientMethods.create_honeypot","title":"<code>create_honeypot(self, json_response, asset_external_id=None, asset_id=None, project_id=None)</code>","text":"<p>Create honeypot for an asset.</p> <p>Info</p> <p>Uses the given <code>json_response</code> to create a <code>REVIEW</code> label. This enables Kili to compute a<code>honeypotMark</code>, which measures the similarity between this label and other labels.</p> <p>Parameters:</p> Name Type Description Default <code>json_response</code> <code>dict</code> <p>The JSON response of the honeypot label of the asset.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset. Either provide <code>asset_id</code> or <code>asset_external_id</code> and <code>project_id</code>.</p> <code>None</code> <code>asset_external_id</code> <code>Optional[str]</code> <p>External identifier of the asset. Either provide <code>asset_id</code> or <code>asset_external_id</code> and <code>project_id</code>.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>Identifier of the project. Either provide <code>asset_id</code> or <code>asset_external_id</code> and <code>project_id</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary-like object representing the created label.</p> Source code in <code>kili/presentation/client/label.py</code> <pre><code>def create_honeypot(\n    self,\n    json_response: dict,\n    asset_external_id: Optional[str] = None,\n    asset_id: Optional[str] = None,\n    project_id: Optional[str] = None,\n) -&gt; Dict:\n    \"\"\"Create honeypot for an asset.\n\n    !!! info\n        Uses the given `json_response` to create a `REVIEW` label.\n        This enables Kili to compute a`honeypotMark`,\n        which measures the similarity between this label and other labels.\n\n    Args:\n        json_response: The JSON response of the honeypot label of the asset.\n        asset_id: Identifier of the asset.\n            Either provide `asset_id` or `asset_external_id` and `project_id`.\n        asset_external_id: External identifier of the asset.\n            Either provide `asset_id` or `asset_external_id` and `project_id`.\n        project_id: Identifier of the project.\n            Either provide `asset_id` or `asset_external_id` and `project_id`.\n\n    Returns:\n        A dictionary-like object representing the created label.\n    \"\"\"\n    return LabelUseCases(self.kili_api_gateway).create_honeypot_label(\n        json_response=json_response,\n        asset_id=AssetId(asset_id) if asset_id else None,\n        asset_external_id=AssetExternalId(asset_external_id) if asset_external_id else None,\n        project_id=ProjectId(project_id) if project_id else None,\n        fields=(\"id\",),\n    )\n</code></pre>"},{"location":"sdk/label/#kili.presentation.client.label.LabelClientMethods.create_predictions","title":"<code>create_predictions(self, project_id, external_id_array=None, model_name_array=None, json_response_array=None, model_name=None, asset_id_array=None, disable_tqdm=None, overwrite=False)</code>","text":"<p>Create predictions for specific assets.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>external_id_array</code> <code>Optional[List[str]]</code> <p>The external IDs of the assets for which we want to add predictions.</p> <code>None</code> <code>model_name_array</code> <code>Optional[List[str]]</code> <p>Deprecated, use <code>model_name</code> instead.</p> <code>None</code> <code>json_response_array</code> <code>Optional[List[dict]]</code> <p>The predictions are given here. For examples, see the recipe.</p> <code>None</code> <code>model_name</code> <code>Optional[str]</code> <p>The name of the model that generated the predictions</p> <code>None</code> <code>asset_id_array</code> <code>Optional[List[str]]</code> <p>The internal IDs of the assets for which we want to add predictions.</p> <code>None</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>Disable tqdm progress bar.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>if True, it will overwrite existing predictions of the same model name on the targeted assets.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[Literal['id'], str]</code> <p>A dictionary with the project <code>id</code>.</p> <p>Recipe</p> <p>For more detailed examples on how to create predictions, see the recipe.</p> <p>model name</p> <p>The use of <code>model_name_array</code> is deprecated. Creating predictions from different models is not supported anymore. Please use <code>model_name</code> argument instead to provide the predictions model name.</p> Source code in <code>kili/presentation/client/label.py</code> <pre><code>def create_predictions(\n    self,\n    project_id: str,\n    external_id_array: Optional[List[str]] = None,\n    model_name_array: Optional[List[str]] = None,\n    json_response_array: Optional[List[dict]] = None,\n    model_name: Optional[str] = None,\n    asset_id_array: Optional[List[str]] = None,\n    disable_tqdm: Optional[bool] = None,\n    overwrite: bool = False,\n) -&gt; Dict[Literal[\"id\"], str]:\n    # pylint: disable=line-too-long\n    \"\"\"Create predictions for specific assets.\n\n    Args:\n        project_id: Identifier of the project.\n        external_id_array: The external IDs of the assets for which we want to add predictions.\n        model_name_array: Deprecated, use `model_name` instead.\n        json_response_array: The predictions are given here. For examples,\n            see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n        model_name: The name of the model that generated the predictions\n        asset_id_array: The internal IDs of the assets for which we want to add predictions.\n        disable_tqdm: Disable tqdm progress bar.\n        overwrite: if True, it will overwrite existing predictions of\n            the same model name on the targeted assets.\n\n    Returns:\n        A dictionary with the project `id`.\n\n    !!! example \"Recipe\"\n        For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n\n    !!! warning \"model name\"\n        The use of `model_name_array` is deprecated. Creating predictions from different\n        models is not supported anymore. Please use `model_name` argument instead to\n        provide the predictions model name.\n    \"\"\"\n    if json_response_array is None or len(json_response_array) == 0:\n        raise ValueError(\n            \"json_response_array is empty, you must provide at least one prediction to upload\"\n        )\n\n    assert_all_arrays_have_same_size(\n        [external_id_array, json_response_array, model_name_array, asset_id_array]\n    )\n    nb_labels_to_add = len(json_response_array)\n\n    if model_name is None:\n        if model_name_array is None:\n            raise ValueError(\"You must provide a model name with the `model_name` argument.\")\n\n        if len(set(model_name_array)) &gt; 1:\n            raise ValueError(\n                \"Creating predictions from different models is not supported anymore. Separate\"\n                \" your calls by models.\"\n            )\n\n        warnings.warn(\n            \"The use of `model_name_array` is deprecated. Creating predictions from\"\n            \" different models is not supported anymore. Please use `model_name` argument\"\n            \" instead to provide the predictions model name.\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n        model_name = model_name_array[0]\n\n    labels = [\n        LabelToCreateUseCaseInput(\n            asset_id=AssetId(asset_id) if asset_id else None,\n            asset_external_id=AssetExternalId(asset_external_id) if asset_external_id else None,\n            json_response=json_response,\n            label_type=\"PREDICTION\",\n            model_name=model_name,\n            seconds_to_label=None,\n            author_id=None,\n            referenced_label_id=None,\n        )\n        for (asset_id, asset_external_id, json_response) in zip(\n            asset_id_array or repeat(None, nb_labels_to_add),\n            external_id_array or repeat(None, nb_labels_to_add),\n            json_response_array,\n        )\n    ]\n\n    LabelUseCases(self.kili_api_gateway).append_labels(\n        fields=(\"id\",),\n        disable_tqdm=disable_tqdm,\n        label_type=\"PREDICTION\",\n        labels=labels,\n        overwrite=overwrite,\n        project_id=ProjectId(project_id) if project_id else None,\n    )\n    return {\"id\": project_id}\n</code></pre>"},{"location":"sdk/label/#kili.presentation.client.label.LabelClientMethods.delete_labels","title":"<code>delete_labels(self, ids, disable_tqdm=None)</code>","text":"<p>Delete labels.</p> <p>Currently, only <code>PREDICTION</code> and <code>INFERENCE</code> labels can be deleted.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>List of label ids to delete.</p> required <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>The deleted label ids.</p> Source code in <code>kili/presentation/client/label.py</code> <pre><code>def delete_labels(\n    self,\n    ids: ListOrTuple[str],\n    disable_tqdm: Optional[bool] = None,\n) -&gt; List[str]:\n    \"\"\"Delete labels.\n\n    Currently, only `PREDICTION` and `INFERENCE` labels can be deleted.\n\n    Args:\n        ids: List of label ids to delete.\n        disable_tqdm: If `True`, the progress bar will be disabled.\n\n    Returns:\n        The deleted label ids.\n    \"\"\"\n    if is_empty_list_with_warning(\"delete_labels\", \"ids\", ids):\n        return []\n\n    deleted_label_ids = LabelUseCases(self.kili_api_gateway).delete_labels(\n        ids=cast(ListOrTuple[LabelId], ids),\n        disable_tqdm=disable_tqdm,\n    )\n    return cast(List[str], deleted_label_ids)\n</code></pre>"},{"location":"sdk/label/#kili.presentation.client.label.LabelClientMethods.export_labels","title":"<code>export_labels(self, project_id, filename, fmt, asset_ids=None, layout='split', single_file=False, disable_tqdm=None, with_assets=True, external_ids=None, annotation_modifier=None, asset_filter_kwargs=None, normalized_coordinates=None, label_type_in=None, include_sent_back_labels=None)</code>","text":"<p>Export the project labels with the requested format into the requested output path.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>filename</code> <code>Optional[str]</code> <p>Relative or full path of the archive that will contain the exported data.</p> required <code>fmt</code> <code>Literal['raw', 'kili', 'yolo_v4', 'yolo_v5', 'yolo_v7', 'yolo_v8', 'coco', 'pascal_voc', 'geojson']</code> <p>Format of the exported labels.</p> required <code>asset_ids</code> <code>Optional[List[str]]</code> <p>Optional list of the assets internal IDs from which to export the labels.</p> <code>None</code> <code>layout</code> <code>Literal['split', 'merged']</code> <p>Layout of the exported files. \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels.</p> <code>'split'</code> <code>single_file</code> <code>bool</code> <p>Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili).</p> <code>False</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>Disable the progress bar if True.</p> <code>None</code> <code>with_assets</code> <code>bool</code> <p>Download the assets in the export.</p> <code>True</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>Optional list of the assets external IDs from which to export the labels.</p> <code>None</code> <code>annotation_modifier</code> <code>Optional[Callable[[Dict, Dict, Dict], Dict]]</code> <p>(For COCO export only) function that takes the COCO annotation, the COCO image, and the Kili annotation, and should return an updated COCO annotation. This can be used if you want to add a new attribute to the COCO annotation. For example, you can add a method that computes if the annotation is a rectangle or not and add it to the COCO annotation (see example).</p> <code>None</code> <code>asset_filter_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of arguments to pass to <code>kili.assets()</code> in order to filter the assets the labels are exported from. The supported arguments are:</p> <ul> <li><code>consensus_mark_gte</code></li> <li><code>consensus_mark_lte</code></li> <li><code>external_id_strictly_in</code></li> <li><code>external_id_in</code></li> <li><code>honeypot_mark_gte</code></li> <li><code>honeypot_mark_lte</code></li> <li><code>label_author_in</code></li> <li><code>label_labeler_in</code></li> <li><code>label_labeler_not_in</code></li> <li><code>label_reviewer_in</code></li> <li><code>label_reviewer_not_in</code></li> <li><code>assignee_in</code></li> <li><code>assignee_not_in</code></li> <li><code>skipped</code>: only applicable if the project is in the WorkflowV1 (legacy).</li> <li><code>status_in</code>: only applicable if the project is in the WorkflowV1 (legacy).</li> <li><code>label_category_search</code></li> <li><code>created_at_gte</code></li> <li><code>created_at_lte</code></li> <li><code>issue_type</code></li> <li><code>issue_status</code></li> <li><code>inference_mark_gte</code></li> <li><code>inference_mark_lte</code></li> <li><code>metadata_where</code></li> <li><code>step_name_in</code>: : only applicable if the project is in the WorkflowV2.</li> <li><code>step_status_in</code>: only applicable if the project is in the WorkflowV2.</li> </ul> <p>See the documentation of <code>kili.assets()</code> for more information.</p> <code>None</code> <code>normalized_coordinates</code> <code>Optional[bool]</code> <p>This parameter is only effective on the Kili (a.k.a raw) format. If True, the coordinates of the <code>(x, y)</code> vertices are normalized between 0 and 1. If False, the json response will contain additional fields with coordinates in absolute values, that is, in pixels.</p> <code>None</code> <code>label_type_in</code> <code>Optional[List[str]]</code> <p>Optional list of label type. Exported assets should have a label whose type belongs to that list. By default, only <code>DEFAULT</code> and <code>REVIEW</code> labels are exported.</p> <code>None</code> <code>include_sent_back_labels</code> <code>Optional[bool]</code> <p>If True, the export will include the labels that have been sent back.</p> <code>None</code> <p>Info</p> <p>The supported formats are:</p> <ul> <li>Yolo V4, V5, V7, V8 for object detection tasks.</li> <li>Kili (a.k.a raw) for all tasks.</li> <li>COCO for object detection tasks (bounding box and semantic segmentation).</li> <li>Pascal VOC for object detection tasks (bounding box).</li> </ul> <p>Cloud storage</p> <p>Export with asset download (<code>with_assets=True</code>) is not allowed for projects connected to a cloud storage.</p> <p>Example</p> <pre><code>kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\")\n</code></pre> <p>Example</p> <pre><code>def is_rectangle(coco_annotation, coco_image, kili_annotation):\n    is_rectangle = ...\n    return {**coco_annotation, \"attributes\": {\"is_rectangle\": is_rectangle}}\n\nkili.export_labels(\n    \"your_project_id\",\n    \"export.zip\",\n    \"coco\",\n    annotation_modifier=add_is_rectangle\n)\n</code></pre> Source code in <code>kili/presentation/client/label.py</code> <pre><code>def export_labels(\n    self,\n    project_id: str,\n    filename: Optional[str],\n    fmt: LabelFormat,\n    asset_ids: Optional[List[str]] = None,\n    layout: SplitOption = \"split\",\n    single_file: bool = False,\n    disable_tqdm: Optional[bool] = None,\n    with_assets: bool = True,\n    external_ids: Optional[List[str]] = None,\n    annotation_modifier: Optional[CocoAnnotationModifier] = None,\n    asset_filter_kwargs: Optional[Dict[str, Any]] = None,\n    normalized_coordinates: Optional[bool] = None,\n    label_type_in: Optional[List[str]] = None,\n    include_sent_back_labels: Optional[bool] = None,\n) -&gt; Optional[List[Dict[str, Union[List[str], str]]]]:\n    # pylint: disable=line-too-long\n    \"\"\"Export the project labels with the requested format into the requested output path.\n\n    Args:\n        project_id: Identifier of the project.\n        filename: Relative or full path of the archive that will contain\n            the exported data.\n        fmt: Format of the exported labels.\n        asset_ids: Optional list of the assets internal IDs from which to export the labels.\n        layout: Layout of the exported files. \"split\" means there is one folder\n            per job, \"merged\" that there is one folder with every labels.\n        single_file: Layout of the exported labels. Single file mode is\n            only available for some specific formats (COCO and Kili).\n        disable_tqdm: Disable the progress bar if True.\n        with_assets: Download the assets in the export.\n        external_ids: Optional list of the assets external IDs from which to export the labels.\n        annotation_modifier: (For COCO export only) function that takes the COCO annotation, the\n            COCO image, and the Kili annotation, and should return an updated COCO annotation.\n            This can be used if you want to add a new attribute to the COCO annotation. For\n            example, you can add a method that computes if the annotation is a rectangle or not\n            and add it to the COCO annotation (see example).\n        asset_filter_kwargs: Optional dictionary of arguments to pass to `kili.assets()` in order to filter the assets the labels are exported from. The supported arguments are:\n\n            - `consensus_mark_gte`\n            - `consensus_mark_lte`\n            - `external_id_strictly_in`\n            - `external_id_in`\n            - `honeypot_mark_gte`\n            - `honeypot_mark_lte`\n            - `label_author_in`\n            - `label_labeler_in`\n            - `label_labeler_not_in`\n            - `label_reviewer_in`\n            - `label_reviewer_not_in`\n            - `assignee_in`\n            - `assignee_not_in`\n            - `skipped`: only applicable if the project is in the WorkflowV1 (legacy).\n            - `status_in`: only applicable if the project is in the WorkflowV1 (legacy).\n            - `label_category_search`\n            - `created_at_gte`\n            - `created_at_lte`\n            - `issue_type`\n            - `issue_status`\n            - `inference_mark_gte`\n            - `inference_mark_lte`\n            - `metadata_where`\n            - `step_name_in`: : only applicable if the project is in the WorkflowV2.\n            - `step_status_in`: only applicable if the project is in the WorkflowV2.\n\n            See the documentation of [`kili.assets()`](https://python-sdk-docs.kili-technology.com/latest/sdk/asset/#kili.queries.asset.__init__.QueriesAsset.assets) for more information.\n        normalized_coordinates: This parameter is only effective on the Kili (a.k.a raw) format.\n            If True, the coordinates of the `(x, y)` vertices are normalized between 0 and 1.\n            If False, the json response will contain additional fields with coordinates in absolute values, that is, in pixels.\n        label_type_in: Optional list of label type. Exported assets should have a label whose type belongs to that list.\n            By default, only `DEFAULT` and `REVIEW` labels are exported.\n        include_sent_back_labels: If True, the export will include the labels that have been sent back.\n\n    !!! Info\n        The supported formats are:\n\n        - Yolo V4, V5, V7, V8 for object detection tasks.\n        - Kili (a.k.a raw) for all tasks.\n        - COCO for object detection tasks (bounding box and semantic segmentation).\n        - Pascal VOC for object detection tasks (bounding box).\n\n    !!! warning \"Cloud storage\"\n        Export with asset download (`with_assets=True`) is not allowed for projects connected to a cloud storage.\n\n    !!! Example\n        ```python\n        kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\")\n        ```\n\n    !!! Example\n        ```python\n        def is_rectangle(coco_annotation, coco_image, kili_annotation):\n            is_rectangle = ...\n            return {**coco_annotation, \"attributes\": {\"is_rectangle\": is_rectangle}}\n\n        kili.export_labels(\n            \"your_project_id\",\n            \"export.zip\",\n            \"coco\",\n            annotation_modifier=add_is_rectangle\n        )\n        ```\n    \"\"\"\n    if external_ids is not None and asset_ids is None:\n        id_map = AssetUseCasesUtils(self.kili_api_gateway).infer_ids_from_external_ids(\n            asset_external_ids=cast(List[AssetExternalId], external_ids),\n            project_id=ProjectId(project_id),\n        )\n        resolved_asset_ids = [id_map[AssetExternalId(i)] for i in external_ids]\n    else:\n        resolved_asset_ids = cast(List[AssetId], asset_ids)\n\n    if asset_filter_kwargs and (\n        asset_filter_kwargs.get(\"step_name_in\") is not None\n        or asset_filter_kwargs.get(\"step_status_in\") is not None\n        or asset_filter_kwargs.get(\"status_in\") is not None\n        or asset_filter_kwargs.get(\"skipped\") is not None\n    ):\n        skipped = asset_filter_kwargs.get(\"skipped\")\n        status_in = asset_filter_kwargs.get(\"status_in\")\n        step_name_in = asset_filter_kwargs.get(\"step_name_in\")\n        step_status_in = asset_filter_kwargs.get(\"step_status_in\")\n\n        project_use_cases = ProjectUseCases(self.kili_api_gateway)\n        (\n            project_steps,\n            project_workflow_version,\n        ) = project_use_cases.get_project_steps_and_version(project_id)\n\n        check_asset_workflow_arguments(\n            project_workflow_version=project_workflow_version,\n            asset_workflow_filters={\n                \"skipped\": skipped,\n                \"status_in\": status_in,\n                \"step_name_in\": step_name_in,\n                \"step_status_in\": step_status_in,\n            },\n        )\n\n        if project_workflow_version == \"V2\" and step_name_in is not None:\n            step_id_in = extract_step_ids_from_project_steps(\n                project_steps=project_steps,\n                step_name_in=step_name_in,\n            )\n            asset_filter_kwargs.pop(\"step_name_in\", None)\n            asset_filter_kwargs[\"step_id_in\"] = step_id_in\n\n    try:\n        return export_labels(\n            self,  # pyright: ignore[reportGeneralTypeIssues]\n            asset_ids=resolved_asset_ids,\n            project_id=ProjectId(project_id),\n            export_type=\"latest\",\n            label_format=fmt,\n            split_option=layout,\n            single_file=single_file,\n            output_file=filename,\n            disable_tqdm=disable_tqdm,\n            log_level=\"WARNING\",\n            with_assets=with_assets,\n            annotation_modifier=annotation_modifier,\n            asset_filter_kwargs=asset_filter_kwargs,\n            normalized_coordinates=normalized_coordinates,\n            label_type_in=label_type_in,\n            include_sent_back_labels=include_sent_back_labels,\n        )\n    except NoCompatibleJobError as excp:\n        warnings.warn(str(excp), stacklevel=2)\n        return None\n</code></pre>"},{"location":"sdk/label/#kili.presentation.client.label.LabelClientMethods.export_labels_as_df","title":"<code>export_labels_as_df(self, project_id, fields=('author.email', 'author.id', 'createdAt', 'id', 'labelType'), asset_fields=('externalId',))</code>","text":"<p>Get the labels of a project as a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the labels. See the documentation for all possible fields.</p> <code>('author.email', 'author.id', 'createdAt', 'id', 'labelType')</code> <code>asset_fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the assets. See the documentation for all possible fields.</p> <code>('externalId',)</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A pandas DataFrame containing the labels.</p> Source code in <code>kili/presentation/client/label.py</code> <pre><code>def export_labels_as_df(\n    self,\n    project_id: str,\n    fields: ListOrTuple[str] = (\"author.email\", \"author.id\", \"createdAt\", \"id\", \"labelType\"),\n    asset_fields: ListOrTuple[str] = (\"externalId\",),\n) -&gt; \"pd.DataFrame\":\n    # pylint: disable=line-too-long\n    \"\"\"Get the labels of a project as a pandas DataFrame.\n\n    Args:\n        project_id: Identifier of the project\n        fields: All the fields to request among the possible fields for the labels.\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/label) for all possible fields.\n        asset_fields: All the fields to request among the possible fields for the assets.\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/asset) for all possible fields.\n\n    Returns:\n        A pandas DataFrame containing the labels.\n    \"\"\"\n    return LabelUseCases(self.kili_api_gateway).export_labels_as_df(\n        project_id=ProjectId(project_id), label_fields=fields, asset_fields=asset_fields\n    )\n</code></pre>"},{"location":"sdk/label/#kili.presentation.client.label.LabelClientMethods.inferences","title":"<code>inferences(self, project_id, asset_id=None, asset_status_in=None, asset_external_id_in=None, asset_step_name_in=None, asset_step_status_in=None, author_in=None, created_at=None, created_at_gte=None, created_at_lte=None, fields=('author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'modelName'), first=None, honeypot_mark_gte=None, honeypot_mark_lte=None, id_contains=None, label_id=None, skip=0, user_id=None, disable_tqdm=None, category_search=None, *, as_generator=False)</code>","text":"<p>Get inference labels from a project based on a set of criteria.</p> <p>This method is equivalent to the <code>kili.labels()</code> method, but it only returns label of type \"INFERENCE\".</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code> <code>asset_status_in</code> <code>Union[List[Literal['TODO', 'ONGOING', 'LABELED', 'REVIEWED', 'TO_REVIEW']], Tuple[Literal['TODO', 'ONGOING', 'LABELED', 'REVIEWED', 'TO_REVIEW'], ...]]</code> <p>Returned labels should have a status that belongs to that list, if given. Possible choices : <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO REVIEW</code> or <code>REVIEWED</code></p> <code>None</code> <code>asset_external_id_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that belongs to that list, if given.</p> <code>None</code> <code>asset_step_name_in</code> <code>Optional[List[str]]</code> <p>Returned assets are in a step whose name belong to that list, if given. Only applicable if the project is in WorkflowV2.</p> <code>None</code> <code>asset_step_status_in</code> <code>Optional[List[Literal['TO_DO', 'DOING', 'PARTIALLY_DONE', 'REDO', 'DONE', 'SKIPPED']]]</code> <p>Returned assets have the status of their step that belongs to that list, if given. Possible choices: <code>TO_DO</code>, <code>DOING</code>, <code>PARTIALLY_DONE</code>, <code>REDO</code>, <code>DONE</code>, <code>SKIPPED</code>. Only applicable if the project is in WorkflowV2.</p> <code>None</code> <code>author_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>created_at</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is equal to this date.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is greater than this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is lower than this date.</p> <code>None</code> <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the labels. See the documentation for all possible fields.</p> <code>('author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'modelName')</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of labels to return.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is greater than this number.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is lower than this number.</p> <code>None</code> <code>id_contains</code> <code>Optional[List[str]]</code> <p>Filters out labels not belonging to that list. If empty, no filtering is applied.</p> <code>None</code> <code>label_id</code> <code>Optional[str]</code> <p>Identifier of the label.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of labels to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>None</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the labels is returned.</p> <code>False</code> <code>category_search</code> <code>Optional[str]</code> <p>Query to filter labels based on the content of their jsonResponse</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>An iterable of inference labels.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.inferences(project_id=project_id) # returns a list of inference labels of a project\n</code></pre> Source code in <code>kili/presentation/client/label.py</code> <pre><code>def inferences(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_status_in: Optional[ListOrTuple[AssetStatus]] = None,\n    asset_external_id_in: Optional[List[str]] = None,\n    asset_step_name_in: Optional[List[str]] = None,\n    asset_step_status_in: Optional[List[StatusInStep]] = None,\n    author_in: Optional[List[str]] = None,\n    created_at: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    fields: ListOrTuple[str] = (\n        \"author.email\",\n        \"author.id\",\n        \"id\",\n        \"jsonResponse\",\n        \"labelType\",\n        \"modelName\",\n    ),\n    first: Optional[int] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    id_contains: Optional[List[str]] = None,\n    label_id: Optional[str] = None,\n    skip: int = 0,\n    user_id: Optional[str] = None,\n    disable_tqdm: Optional[bool] = None,\n    category_search: Optional[str] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n    \"\"\"Get inference labels from a project based on a set of criteria.\n\n    This method is equivalent to the `kili.labels()` method, but it only returns label of type \"INFERENCE\".\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset.\n        asset_status_in: Returned labels should have a status that belongs to that list, if given.\n            Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n        asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n        asset_step_name_in: Returned assets are in a step whose name belong to that list, if given.\n            Only applicable if the project is in WorkflowV2.\n        asset_step_status_in: Returned assets have the status of their step that belongs to that list, if given.\n            Possible choices: `TO_DO`, `DOING`, `PARTIALLY_DONE`, `REDO`, `DONE`, `SKIPPED`.\n            Only applicable if the project is in WorkflowV2.\n        author_in: Returned labels should have been made by authors in that list, if given.\n            An author can be designated by the first name, the last name, or the first name + last name.\n        created_at: Returned labels should have a label whose creation date is equal to this date.\n        created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n        created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n        fields: All the fields to request among the possible fields for the labels.\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/label) for all possible fields.\n        first: Maximum number of labels to return.\n        honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n        honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n        id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n        label_id: Identifier of the label.\n        skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n        user_id: Identifier of the user.\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the labels is returned.\n        category_search: Query to filter labels based on the content of their jsonResponse\n\n    Returns:\n        An iterable of inference labels.\n\n    Examples:\n        &gt;&gt;&gt; kili.inferences(project_id=project_id) # returns a list of inference labels of a project\n    \"\"\"\n    return self.labels(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_status_in=asset_status_in,\n        asset_external_id_in=asset_external_id_in,\n        asset_step_name_in=asset_step_name_in,\n        asset_step_status_in=asset_step_status_in,\n        author_in=author_in,\n        created_at=created_at,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        fields=fields,\n        first=first,\n        honeypot_mark_gte=honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lte,\n        id_contains=id_contains,\n        label_id=label_id,\n        skip=skip,\n        type_in=[\"INFERENCE\"],\n        user_id=user_id,\n        disable_tqdm=disable_tqdm,\n        category_search=category_search,\n        as_generator=as_generator,  # pyright: ignore[reportGeneralTypeIssues]\n    )\n</code></pre>"},{"location":"sdk/label/#kili.presentation.client.label.LabelClientMethods.labels","title":"<code>labels(self, project_id, asset_id=None, asset_status_in=None, asset_external_id_in=None, asset_external_id_strictly_in=None, asset_step_name_in=None, asset_step_status_in=None, author_in=None, created_at=None, created_at_gte=None, created_at_lte=None, fields=('author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel', 'isLatestLabelForUser', 'assetId'), first=None, honeypot_mark_gte=None, honeypot_mark_lte=None, id_contains=None, label_id=None, skip=0, type_in=None, user_id=None, disable_tqdm=None, category_search=None, output_format='dict', *, as_generator=False)</code>","text":"<p>Get a label list or a label generator from a project based on a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code> <code>asset_status_in</code> <code>Union[List[Literal['TODO', 'ONGOING', 'LABELED', 'REVIEWED', 'TO_REVIEW']], Tuple[Literal['TODO', 'ONGOING', 'LABELED', 'REVIEWED', 'TO_REVIEW'], ...]]</code> <p>Returned labels should have a status that belongs to that list, if given. Possible choices : <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO REVIEW</code> or <code>REVIEWED</code>.</p> <code>None</code> <code>asset_external_id_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that belongs to that list, if given.</p> <code>None</code> <code>asset_external_id_strictly_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that exactly matches one of the ids in that list, if given.</p> <code>None</code> <code>asset_step_name_in</code> <code>Optional[List[str]]</code> <p>Returned assets are in a step whose name belong to that list, if given. Only applicable if the project is in WorkflowV2.</p> <code>None</code> <code>asset_step_status_in</code> <code>Optional[List[Literal['TO_DO', 'DOING', 'PARTIALLY_DONE', 'REDO', 'DONE', 'SKIPPED']]]</code> <p>Returned assets have the status of their step that belongs to that list, if given. Possible choices: <code>TO_DO</code>, <code>DOING</code>, <code>PARTIALLY_DONE</code>, <code>REDO</code>, <code>DONE</code>, <code>SKIPPED</code>. Only applicable if the project is in WorkflowV2.</p> <code>None</code> <code>author_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>created_at</code> <code>Optional[str]</code> <p>Returned labels should have their creation date equal to this date.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned labels should have their creation date greater or equal to this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned labels should have their creation date lower or equal to this date.</p> <code>None</code> <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the labels. See the documentation for all possible fields.</p> <code>('author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel', 'isLatestLabelForUser', 'assetId')</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of labels to return.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is greater than this number.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is lower than this number.</p> <code>None</code> <code>id_contains</code> <code>Optional[List[str]]</code> <p>Filters out labels not belonging to that list. If empty, no filtering is applied.</p> <code>None</code> <code>label_id</code> <code>Optional[str]</code> <p>Identifier of the label.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of labels to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>type_in</code> <code>Optional[List[Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW']]]</code> <p>Returned labels should have a label whose type belongs to that list, if given.</p> <code>None</code> <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled.</p> <code>None</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the labels is returned.</p> <code>False</code> <code>category_search</code> <code>Optional[str]</code> <p>Query to filter labels based on the content of their jsonResponse.</p> <code>None</code> <code>output_format</code> <code>Literal['dict', 'parsed_label']</code> <p>If <code>dict</code>, the output is an iterable of Python dictionaries. If <code>parsed_label</code>, the output is an iterable of parsed labels objects. More information on parsed labels in the documentation.</p> <code>'dict'</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>Iterable[Union[Dict, kili.utils.labels.parsing.ParsedLabel]]</code> <p>An iterable of labels.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID\n&gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project\n</code></pre> <p>How to filter based on label categories</p> <p>The search query is composed of logical expressions following this format:</p> <pre><code>[job_name].[category_name].count [comparaison_operator] [value]\n</code></pre> <p>where:</p> <ul> <li><code>[job_name]</code> is the name of the job in the interface</li> <li><code>[category_name]</code> is the name of the category in the interface for this job</li> <li><code>[comparaison_operator]</code> can be one of: [<code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;</code>]</li> <li><code>[value]</code> is an integer that represents the count of such objects of the given category in the label</li> </ul> <p>These operations can be separated by OR and AND operators</p> <p>Examples:</p> <p>category_search = <code>JOB_CLASSIF.CATEGORY_A.count &gt; 0</code> category_search = <code>JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0</code> category_search = <code>(JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10</code></p> Source code in <code>kili/presentation/client/label.py</code> <pre><code>def labels(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_status_in: Optional[ListOrTuple[AssetStatus]] = None,\n    asset_external_id_in: Optional[List[str]] = None,\n    asset_external_id_strictly_in: Optional[List[str]] = None,\n    asset_step_name_in: Optional[List[str]] = None,\n    asset_step_status_in: Optional[List[StatusInStep]] = None,\n    author_in: Optional[List[str]] = None,\n    created_at: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    fields: ListOrTuple[str] = (\n        \"author.email\",\n        \"author.id\",\n        \"id\",\n        \"jsonResponse\",\n        \"labelType\",\n        \"secondsToLabel\",\n        \"isLatestLabelForUser\",\n        \"assetId\",\n    ),\n    first: Optional[int] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    id_contains: Optional[List[str]] = None,\n    label_id: Optional[str] = None,\n    skip: int = 0,\n    type_in: Optional[List[LabelType]] = None,\n    user_id: Optional[str] = None,\n    disable_tqdm: Optional[bool] = None,\n    category_search: Optional[str] = None,\n    output_format: Literal[\"dict\", \"parsed_label\"] = \"dict\",\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Union[Dict, ParsedLabel]]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a label list or a label generator from a project based on a set of criteria.\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset.\n        asset_status_in: Returned labels should have a status that belongs to that list, if given.\n            Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`.\n        asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n        asset_external_id_strictly_in: Returned labels should have an external id that exactly matches one of the ids in that list, if given.\n        asset_step_name_in: Returned assets are in a step whose name belong to that list, if given.\n            Only applicable if the project is in WorkflowV2.\n        asset_step_status_in: Returned assets have the status of their step that belongs to that list, if given.\n            Possible choices: `TO_DO`, `DOING`, `PARTIALLY_DONE`, `REDO`, `DONE`, `SKIPPED`.\n            Only applicable if the project is in WorkflowV2.\n        author_in: Returned labels should have been made by authors in that list, if given.\n            An author can be designated by the first name, the last name, or the first name + last name.\n        created_at: Returned labels should have their creation date equal to this date.\n        created_at_gte: Returned labels should have their creation date greater or equal to this date.\n        created_at_lte: Returned labels should have their creation date lower or equal to this date.\n        fields: All the fields to request among the possible fields for the labels.\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/label) for all possible fields.\n        first: Maximum number of labels to return.\n        honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n        honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n        id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n        label_id: Identifier of the label.\n        skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n        type_in: Returned labels should have a label whose type belongs to that list, if given.\n        user_id: Identifier of the user.\n        disable_tqdm: If `True`, the progress bar will be disabled.\n        as_generator: If `True`, a generator on the labels is returned.\n        category_search: Query to filter labels based on the content of their jsonResponse.\n        output_format: If `dict`, the output is an iterable of Python dictionaries.\n            If `parsed_label`, the output is an iterable of parsed labels objects. More information on parsed labels in the [documentation](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/label_parsing/).\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        An iterable of labels.\n\n    Examples:\n        &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID\n        &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project\n\n    !!! example \"How to filter based on label categories\"\n        The search query is composed of logical expressions following this format:\n\n            [job_name].[category_name].count [comparaison_operator] [value]\n        where:\n\n        - `[job_name]` is the name of the job in the interface\n        - `[category_name]` is the name of the category in the interface for this job\n        - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n        - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n        These operations can be separated by OR and AND operators\n\n    Example:\n            category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n            category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n            category_search = `(JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n    \"\"\"\n    if category_search:\n        validate_category_search_query(category_search)\n\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n\n    asset_step_id_in = None\n    if (\n        asset_status_in is not None\n        or asset_step_name_in is not None\n        or asset_step_status_in is not None\n    ):\n        project_use_cases = ProjectUseCases(self.kili_api_gateway)\n        (\n            project_steps,\n            project_workflow_version,\n        ) = project_use_cases.get_project_steps_and_version(project_id)\n        check_asset_workflow_arguments(\n            project_workflow_version=project_workflow_version,\n            asset_workflow_filters={\n                \"skipped\": None,\n                \"step_name_in\": asset_step_name_in,\n                \"step_status_in\": asset_step_status_in,\n                \"status_in\": asset_status_in,\n            },\n        )\n        if project_workflow_version == \"V2\" and asset_step_name_in is not None:\n            asset_step_id_in = extract_step_ids_from_project_steps(\n                project_steps=project_steps,\n                step_name_in=asset_step_name_in,\n            )\n\n    filters = LabelFilters(\n        project_id=ProjectId(project_id),\n        asset=AssetFilters(\n            project_id=ProjectId(project_id),\n            asset_id=AssetId(asset_id) if asset_id else None,\n            status_in=asset_status_in,\n            external_id_in=(\n                cast(ListOrTuple[AssetExternalId], asset_external_id_in)\n                if asset_external_id_in\n                else None\n            ),\n            external_id_strictly_in=(\n                cast(ListOrTuple[AssetExternalId], asset_external_id_strictly_in)\n                if asset_external_id_strictly_in\n                else None\n            ),\n            step_id_in=asset_step_id_in,\n            step_status_in=asset_step_status_in,\n        ),\n        author_in=author_in,\n        created_at=created_at,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        honeypot_mark_gte=honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lte,\n        id_in=cast(List[LabelId], id_contains) if id_contains else None,\n        id=LabelId(label_id) if label_id else None,\n        type_in=type_in,\n        user=UserFilter(id=UserId(user_id)) if user_id else None,\n        search=category_search,\n        consensus_mark_gte=None,\n        consensus_mark_lte=None,\n        labeler_in=None,\n        reviewer_in=None,\n    )\n\n    labels_gen = LabelUseCases(self.kili_api_gateway).list_labels(\n        filters=filters,\n        options=options,\n        fields=fields,\n        output_format=output_format,\n        project_id=ProjectId(project_id),\n    )\n\n    if as_generator:\n        return labels_gen\n    return list(labels_gen)\n</code></pre>"},{"location":"sdk/label/#kili.presentation.client.label.LabelClientMethods.predictions","title":"<code>predictions(self, project_id, asset_id=None, asset_status_in=None, asset_external_id_in=None, asset_step_name_in=None, asset_step_status_in=None, author_in=None, created_at=None, created_at_gte=None, created_at_lte=None, fields=('author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'modelName'), first=None, honeypot_mark_gte=None, honeypot_mark_lte=None, id_contains=None, label_id=None, skip=0, user_id=None, disable_tqdm=None, category_search=None, *, as_generator=False)</code>","text":"<p>Get prediction labels from a project based on a set of criteria.</p> <p>This method is equivalent to the <code>kili.labels()</code> method, but it only returns label of type \"PREDICTION\".</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code> <code>asset_status_in</code> <code>Union[List[Literal['TODO', 'ONGOING', 'LABELED', 'REVIEWED', 'TO_REVIEW']], Tuple[Literal['TODO', 'ONGOING', 'LABELED', 'REVIEWED', 'TO_REVIEW'], ...]]</code> <p>Returned labels should have a status that belongs to that list, if given. Possible choices : <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO REVIEW</code> or <code>REVIEWED</code></p> <code>None</code> <code>asset_external_id_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that belongs to that list, if given.</p> <code>None</code> <code>asset_step_name_in</code> <code>Optional[List[str]]</code> <p>Returned assets are in a step whose name belong to that list, if given. Only applicable if the project is in WorkflowV2.</p> <code>None</code> <code>asset_step_status_in</code> <code>Optional[List[Literal['TO_DO', 'DOING', 'PARTIALLY_DONE', 'REDO', 'DONE', 'SKIPPED']]]</code> <p>Returned assets have the status of their step that belongs to that list, if given. Possible choices: <code>TO_DO</code>, <code>DOING</code>, <code>PARTIALLY_DONE</code>, <code>REDO</code>, <code>DONE</code>, <code>SKIPPED</code>. Only applicable if the project is in WorkflowV2.</p> <code>None</code> <code>author_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>created_at</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is equal to this date.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is greater than this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is lower than this date.</p> <code>None</code> <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the labels. See the documentation for all possible fields.</p> <code>('author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'modelName')</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of labels to return.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is greater than this number.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is lower than this number.</p> <code>None</code> <code>id_contains</code> <code>Optional[List[str]]</code> <p>Filters out labels not belonging to that list. If empty, no filtering is applied.</p> <code>None</code> <code>label_id</code> <code>Optional[str]</code> <p>Identifier of the label.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of labels to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>None</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the labels is returned.</p> <code>False</code> <code>category_search</code> <code>Optional[str]</code> <p>Query to filter labels based on the content of their jsonResponse</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>An iterable of labels.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.predictions(project_id=project_id) # returns a list of prediction labels of a project\n</code></pre> Source code in <code>kili/presentation/client/label.py</code> <pre><code>def predictions(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_status_in: Optional[ListOrTuple[AssetStatus]] = None,\n    asset_external_id_in: Optional[List[str]] = None,\n    asset_step_name_in: Optional[List[str]] = None,\n    asset_step_status_in: Optional[List[StatusInStep]] = None,\n    author_in: Optional[List[str]] = None,\n    created_at: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    fields: ListOrTuple[str] = (\n        \"author.email\",\n        \"author.id\",\n        \"id\",\n        \"jsonResponse\",\n        \"labelType\",\n        \"modelName\",\n    ),\n    first: Optional[int] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    id_contains: Optional[List[str]] = None,\n    label_id: Optional[str] = None,\n    skip: int = 0,\n    user_id: Optional[str] = None,\n    disable_tqdm: Optional[bool] = None,\n    category_search: Optional[str] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n    \"\"\"Get prediction labels from a project based on a set of criteria.\n\n    This method is equivalent to the `kili.labels()` method, but it only returns label of type \"PREDICTION\".\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset.\n        asset_status_in: Returned labels should have a status that belongs to that list, if given.\n            Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n        asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n        asset_step_name_in: Returned assets are in a step whose name belong to that list, if given.\n            Only applicable if the project is in WorkflowV2.\n        asset_step_status_in: Returned assets have the status of their step that belongs to that list, if given.\n            Possible choices: `TO_DO`, `DOING`, `PARTIALLY_DONE`, `REDO`, `DONE`, `SKIPPED`.\n            Only applicable if the project is in WorkflowV2.\n        author_in: Returned labels should have been made by authors in that list, if given.\n            An author can be designated by the first name, the last name, or the first name + last name.\n        created_at: Returned labels should have a label whose creation date is equal to this date.\n        created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n        created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n        fields: All the fields to request among the possible fields for the labels.\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/label) for all possible fields.\n        first: Maximum number of labels to return.\n        honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n        honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n        id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n        label_id: Identifier of the label.\n        skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n        user_id: Identifier of the user.\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the labels is returned.\n        category_search: Query to filter labels based on the content of their jsonResponse\n\n    Returns:\n        An iterable of labels.\n\n    Examples:\n        &gt;&gt;&gt; kili.predictions(project_id=project_id) # returns a list of prediction labels of a project\n    \"\"\"\n    return self.labels(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_status_in=asset_status_in,\n        asset_external_id_in=asset_external_id_in,\n        asset_step_name_in=asset_step_name_in,\n        asset_step_status_in=asset_step_status_in,\n        author_in=author_in,\n        created_at=created_at,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        fields=fields,\n        first=first,\n        honeypot_mark_gte=honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lte,\n        id_contains=id_contains,\n        label_id=label_id,\n        skip=skip,\n        type_in=[\"PREDICTION\"],\n        user_id=user_id,\n        disable_tqdm=disable_tqdm,\n        category_search=category_search,\n        as_generator=as_generator,  # pyright: ignore[reportGeneralTypeIssues]\n    )\n</code></pre>"},{"location":"sdk/label/#kili.entrypoints.subscriptions.label.__init__.SubscriptionsLabel.label_created_or_updated","title":"<code>label_created_or_updated(self, project_id, callback)</code>","text":"<p>Subscribe a callback to a project, which is executed when a label is created or updated.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>callback</code> <code>Callable[[str, str], NoneType]</code> <p>This function takes as input the id of the asset and its content.</p> required <p>Returns:</p> Type Description <code>SubscriptionGraphQLClient</code> <p>A subscription client.</p> <p>Recipe</p> <p>For more detailed examples on how to use Webhooks, See the related recipe</p> Source code in <code>kili/entrypoints/subscriptions/label/__init__.py</code> <pre><code>def label_created_or_updated(\n    self, project_id: str, callback: Callable[[str, str], None]\n) -&gt; SubscriptionGraphQLClient:\n    # pylint: disable=line-too-long\n    \"\"\"Subscribe a callback to a project, which is executed when a label is created or updated.\n\n    Args:\n        project_id: Identifier of the project\n        callback: This function takes as input the id of the asset and its content.\n\n    Returns:\n        A subscription client.\n\n    !!! example \"Recipe\"\n        For more detailed examples on how to use Webhooks,\n        See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/main/recipes/webhooks_example.ipynb)\n    \"\"\"\n    ws_endpoint = self.graphql_client.endpoint.replace(\"http\", \"ws\")\n    websocket = SubscriptionGraphQLClient(ws_endpoint)\n    headers = {\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"}\n    authorization = f\"X-API-Key: {self.api_key}\"  # type: ignore  # pylint: disable=no-member\n    headers[\"Authorization\"] = authorization\n    variables = {\"projectID\": project_id}\n    websocket.subscribe(\n        GQL_LABEL_CREATED_OR_UPDATED,\n        variables=variables,\n        callback=callback,\n        headers=headers,\n        authorization=authorization,\n    )\n    return websocket\n</code></pre>"},{"location":"sdk/label_parsing/","title":"Label parsing module","text":"<p>The module <code>kili.utils.labels.parsing</code> provides a <code>ParsedLabel</code> class that is used to parse labels.</p> <p>Using labels as <code>ParsedLabel</code> instances is recommended when manipulating the label data, as it will provide autocompletion to access the meaningful fields of the label. If you prefer not to use it, you can still access the labeling data through the label dictionaries.</p> <p>Read more about this feature in the label parsing tutorial.</p> <p>Warning</p> <p>This feature is currently in beta. The classes and methods can still change marginally.</p>"},{"location":"sdk/label_parsing/#parsedlabel","title":"ParsedLabel","text":"<p>Class that represents a parsed label.</p> Source code in <code>kili/utils/labels/parsing.py</code> <pre><code>class ParsedLabel(Dict):\n    \"\"\"Class that represents a parsed label.\"\"\"\n\n    def __init__(self, label: Dict, json_interface: Dict, input_type: InputType) -&gt; None:\n        # pylint: disable=line-too-long\n        \"\"\"Class that represents a parsed label.\n\n        The class behaves like a dict but adds the attribute `.jobs`.\n\n        The original input label passed to this class is not modified.\n\n        Args:\n            label: Label to parse.\n            json_interface: Json interface of the project.\n            input_type: Type of assets of the project.\n\n        !!! Example\n            ```python\n            from kili.utils.labels.parsing import ParsedLabel\n\n            my_label = kili.labels(\"project_id\")[0]  # my_label is a dict\n\n            my_parsed_label = ParsedLabel(my_label, json_interface, input_type)  # ParsedLabel object\n\n            # Access the job \"JOB_0\" data through the attribute \".jobs\":\n            print(my_parsed_label.jobs[\"JOB_0\"])\n            ```\n\n        !!! info\n            More information about the label parsing can be found in this [tutorial](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/label_parsing/).\n        \"\"\"\n        label_copy = deepcopy(label)\n        json_response = label_copy.pop(\"jsonResponse\", {})\n\n        super().__init__(label_copy)\n\n        project_info = Project(inputType=input_type, jsonInterface=json_interface[\"jobs\"])\n\n        self.jobs = json_response_module.ParsedJobs(\n            project_info=project_info, json_response=json_response\n        )\n\n    def to_dict(self) -&gt; Dict:\n        \"\"\"Return a copy of the parsed label as a dict.\n\n        !!! Example\n            ```python\n            my_parsed_label = ParsedLabel(my_dict_label, json_interface, input_type)\n\n            # Convert back to native Python dictionary\n            my_label_as_dict = label.to_dict()\n\n            assert isinstance(my_label_as_dict, dict)  # True\n            ```\n        \"\"\"\n        ret = {k: deepcopy(v) for k, v in self.items() if k != \"jsonResponse\"}\n        ret[\"jsonResponse\"] = self.json_response\n        return ret\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the representation of the object.\"\"\"\n        return repr(self.to_dict())\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the string representation of the object.\"\"\"\n        return str(self.to_dict())\n\n    @property\n    def json_response(self) -&gt; Dict:\n        \"\"\"Returns a copy of the json response of the parsed label.\"\"\"\n        return self.jobs.to_dict()\n</code></pre>"},{"location":"sdk/label_parsing/#kili.utils.labels.parsing.ParsedLabel.__init__","title":"<code>__init__(self, label, json_interface, input_type)</code>  <code>special</code>","text":"<p>Class that represents a parsed label.</p> <p>The class behaves like a dict but adds the attribute <code>.jobs</code>.</p> <p>The original input label passed to this class is not modified.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Dict</code> <p>Label to parse.</p> required <code>json_interface</code> <code>Dict</code> <p>Json interface of the project.</p> required <code>input_type</code> <code>Literal['IMAGE', 'GEOSPATIAL', 'PDF', 'TEXT', 'VIDEO', 'LLM_RLHF', 'LLM_INSTR_FOLLOWING', 'LLM_STATIC']</code> <p>Type of assets of the project.</p> required <p>Example</p> <pre><code>from kili.utils.labels.parsing import ParsedLabel\n\nmy_label = kili.labels(\"project_id\")[0]  # my_label is a dict\n\nmy_parsed_label = ParsedLabel(my_label, json_interface, input_type)  # ParsedLabel object\n\n# Access the job \"JOB_0\" data through the attribute \".jobs\":\nprint(my_parsed_label.jobs[\"JOB_0\"])\n</code></pre> <p>Info</p> <p>More information about the label parsing can be found in this tutorial.</p> Source code in <code>kili/utils/labels/parsing.py</code> <pre><code>def __init__(self, label: Dict, json_interface: Dict, input_type: InputType) -&gt; None:\n    # pylint: disable=line-too-long\n    \"\"\"Class that represents a parsed label.\n\n    The class behaves like a dict but adds the attribute `.jobs`.\n\n    The original input label passed to this class is not modified.\n\n    Args:\n        label: Label to parse.\n        json_interface: Json interface of the project.\n        input_type: Type of assets of the project.\n\n    !!! Example\n        ```python\n        from kili.utils.labels.parsing import ParsedLabel\n\n        my_label = kili.labels(\"project_id\")[0]  # my_label is a dict\n\n        my_parsed_label = ParsedLabel(my_label, json_interface, input_type)  # ParsedLabel object\n\n        # Access the job \"JOB_0\" data through the attribute \".jobs\":\n        print(my_parsed_label.jobs[\"JOB_0\"])\n        ```\n\n    !!! info\n        More information about the label parsing can be found in this [tutorial](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/label_parsing/).\n    \"\"\"\n    label_copy = deepcopy(label)\n    json_response = label_copy.pop(\"jsonResponse\", {})\n\n    super().__init__(label_copy)\n\n    project_info = Project(inputType=input_type, jsonInterface=json_interface[\"jobs\"])\n\n    self.jobs = json_response_module.ParsedJobs(\n        project_info=project_info, json_response=json_response\n    )\n</code></pre>"},{"location":"sdk/label_parsing/#kili.utils.labels.parsing.ParsedLabel.to_dict","title":"<code>to_dict(self)</code>","text":"<p>Return a copy of the parsed label as a dict.</p> <p>Example</p> <pre><code>my_parsed_label = ParsedLabel(my_dict_label, json_interface, input_type)\n\n# Convert back to native Python dictionary\nmy_label_as_dict = label.to_dict()\n\nassert isinstance(my_label_as_dict, dict)  # True\n</code></pre> Source code in <code>kili/utils/labels/parsing.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n    \"\"\"Return a copy of the parsed label as a dict.\n\n    !!! Example\n        ```python\n        my_parsed_label = ParsedLabel(my_dict_label, json_interface, input_type)\n\n        # Convert back to native Python dictionary\n        my_label_as_dict = label.to_dict()\n\n        assert isinstance(my_label_as_dict, dict)  # True\n        ```\n    \"\"\"\n    ret = {k: deepcopy(v) for k, v in self.items() if k != \"jsonResponse\"}\n    ret[\"jsonResponse\"] = self.json_response\n    return ret\n</code></pre>"},{"location":"sdk/label_parsing/#task-specific-attributes-and-methods","title":"Task specific attributes and methods","text":""},{"location":"sdk/label_parsing/#classification-tasks","title":"Classification tasks","text":"<p>For classification tasks, the following attributes are available:</p>"},{"location":"sdk/label_parsing/#categories","title":"<code>.categories</code>","text":"<p>Returns a <code>CategoryList</code> object that contains the categories of an asset.</p> <pre><code>label.jobs[\"CLASSIF_JOB\"].categories\n</code></pre>"},{"location":"sdk/label_parsing/#category","title":"<code>.category</code>","text":"<p>Returns a <code>Category</code> object that contains the category of an asset.</p> <p>Only available if the classification job is a one-class classification job.</p> <pre><code>label.jobs[\"CLASSIF_JOB\"].category\n# Same as:\nlabel.jobs[\"CLASSIF_JOB\"].categories[0]\n</code></pre>"},{"location":"sdk/label_parsing/#name","title":"<code>.name</code>","text":"<p>Retrieves the category name.</p> <pre><code>label.jobs[\"CLASSIF_JOB\"].category.name\n</code></pre> <p>Example</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"mlTask\": \"CLASSIFICATION\",\n            \"content\": {\n                \"categories\": {\n                    \"CATEGORY_A\": {\"name\": \"A\"},\n                    \"CATEGORY_B\": {\"name\": \"B\"},\n                },\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\njson_response_dict = {\n    \"JOB_0\": {\n        \"categories\": [\n            {\n                \"confidence\": 100,\n                \"name\": \"CATEGORY_A\",\n            }\n        ]\n    }\n}\nmy_label = {\"jsonResponse\": json_response_dict}\n\nparsed_label = ParsedLabel(label=my_label, json_interface=json_interface, input_type=\"IMAGE\")\n\nprint(parsed_label.jobs[\"JOB_0\"].categories[0].name)  # CATEGORY_A\nprint(parsed_label.jobs[\"JOB_0\"].categories[0].display_name)  # A\n</code></pre>"},{"location":"sdk/label_parsing/#display_name","title":"<code>.display_name</code>","text":"<p>Retrieves the category name as it is displayed in the interface.</p> <pre><code>label.jobs[\"CLASSIF_JOB\"].category.display_name\n</code></pre>"},{"location":"sdk/label_parsing/#confidence","title":"<code>.confidence</code>","text":"<p>Retrieves the confidence (when available).</p> <pre><code>label.jobs[\"CLASSIF_JOB\"].category.confidence\n</code></pre>"},{"location":"sdk/label_parsing/#transcription-tasks","title":"Transcription tasks","text":""},{"location":"sdk/label_parsing/#text","title":"<code>.text</code>","text":"<p>Retrieves the transcription text.</p> <pre><code>label.jobs[\"TRANSCRIPTION_JOB\"].text\n</code></pre>"},{"location":"sdk/label_parsing/#object-detection-tasks","title":"Object detection tasks","text":"<p>For more information about the different object detection tasks and their label formats, please refer to the Kili documentation.</p>"},{"location":"sdk/label_parsing/#standard-object-detection","title":"Standard object detection","text":""},{"location":"sdk/label_parsing/#bounding_poly","title":"<code>.bounding_poly</code>","text":"<p>Returns a list of bounding polygons for an annotation.</p> <pre><code>label.jobs[\"DETECTION_JOB\"].annotations[0].bounding_poly\n</code></pre>"},{"location":"sdk/label_parsing/#normalized_vertices","title":"<code>.normalized_vertices</code>","text":"<p>Returns a list of normalized vertices for a bounding polygon.</p> <pre><code>label.jobs[\"DETECTION_JOB\"].annotations[0].bounding_poly[0].normalized_vertices\n</code></pre>"},{"location":"sdk/label_parsing/#bounding_poly_annotations","title":"<code>.bounding_poly_annotations</code>","text":"<p>This attribute is an alias for <code>.annotations</code>.</p> <p>The benefit of using this attribute is that it will only show in your IDE autocompletions the attributes that are relevant for the object detection task.</p> <pre><code># the .content attribute is not relevant for object detection tasks!\n\n# IDE autocompletion will accept this attribute, but will crash at runtime\nlabel.jobs[\"BBOX_JOB\"].annotations.content\n\n# IDE autocompletion will not display this attribute and Python linter will raise an error\nlabel.jobs[\"BBOX_JOB\"].bounding_poly_annotations.content\n</code></pre>"},{"location":"sdk/label_parsing/#point-detection","title":"Point detection","text":""},{"location":"sdk/label_parsing/#point","title":"<code>.point</code>","text":"<p>Returns the <code>x</code> and <code>y</code> coordinates of the point.</p> <pre><code>label.jobs[\"POINT_JOB\"].annotations[0].point\n</code></pre>"},{"location":"sdk/label_parsing/#line-detection","title":"Line detection","text":""},{"location":"sdk/label_parsing/#polyline","title":"<code>.polyline</code>","text":"<p>Returns the list of points for a line annotation.</p> <pre><code>label.jobs[\"LINE_JOB\"].annotations[0].polyline\n</code></pre>"},{"location":"sdk/label_parsing/#pose-estimation","title":"Pose estimation","text":""},{"location":"sdk/label_parsing/#points","title":"<code>.points</code>","text":"<p>Returns the list of points for an annotation.</p> <pre><code>label.jobs[\"POSE_JOB\"].annotations[0].points\n</code></pre>"},{"location":"sdk/label_parsing/#point_1","title":"<code>.point</code>","text":"<p>Returns the point data.</p> <pre><code>label.jobs[\"POSE_JOB\"].annotations[0].points[0].point\n</code></pre>"},{"location":"sdk/label_parsing/#pointpoint","title":"<code>.point.point</code>","text":"<p>Returns a dictionary with the coordinates of the point.</p> <pre><code>label.jobs[\"POSE_JOB\"].annotations[0].points[0].point.point\n</code></pre>"},{"location":"sdk/label_parsing/#code","title":"<code>.code</code>","text":"<p>Returns the point identifier (unique for each point in an object).</p> <pre><code>label.jobs[\"POSE_JOB\"].annotations[0].points[0].point.code\n</code></pre>"},{"location":"sdk/label_parsing/#name_1","title":"<code>.name</code>","text":"<p>Returns the point name.</p> <pre><code>label.jobs[\"POSE_JOB\"].annotations[0].points[0].point.name\n</code></pre>"},{"location":"sdk/label_parsing/#job_name","title":"<code>.job_name</code>","text":"<p>Returns the job which annotated point belongs to.</p> <pre><code>label.jobs[\"POSE_JOB\"].annotations[0].points[0].point.job_name\n</code></pre>"},{"location":"sdk/label_parsing/#video-tasks","title":"Video tasks","text":""},{"location":"sdk/label_parsing/#frames","title":"<code>.frames</code>","text":"<p>Returns a list of parsed label data for a each frame.</p> <pre><code>label.jobs[\"FRAME_CLASSIF_JOB\"].frames\nlabel.jobs[\"FRAME_CLASSIF_JOB\"].frames[5]  # 6th frame\n\n# get category name of the 6th frame (for a frame classification job only)\nlabel.jobs[\"FRAME_CLASSIF_JOB\"].frames[5].category.name\n</code></pre>"},{"location":"sdk/label_parsing/#named-entities-recognition-tasks","title":"Named entities recognition tasks","text":""},{"location":"sdk/label_parsing/#content","title":"<code>.content</code>","text":"<p>Returns the content of the mention.</p> <pre><code>label.jobs[\"NER_JOB\"].annotations[0].content\n</code></pre>"},{"location":"sdk/label_parsing/#begin_offset","title":"<code>.begin_offset</code>","text":"<p>Returns the position of the first character of the mention in the text.</p> <pre><code>label.jobs[\"NER_JOB\"].annotations[0].begin_offset\n</code></pre>"},{"location":"sdk/label_parsing/#end_offet","title":"<code>.end_offet</code>","text":"<p>When available, returns the position of the last character of the mention in the text.</p> <pre><code>label.jobs[\"NER_JOB\"].annotations[0].end_offset\n</code></pre>"},{"location":"sdk/label_parsing/#entity_annotations","title":"<code>.entity_annotations</code>","text":"<p>This attribute is an alias for <code>.annotations</code>.</p> <p>The benefit of using this attribute is that it will only show in your IDE autocompletions the attributes that are relevant for the NER task.</p> <pre><code># the .points attribute is not relevant for NER tasks, it is only used for pose estimation tasks!\n\n# IDE autocompletion will accept this attribute, but will crash at runtime\nlabel.jobs[\"NER_JOB\"].annotations.points\n\n# IDE autocompletion will not display this attribute and Python linter will raise an error\nlabel.jobs[\"NER_JOB\"].entity_annotations.points\n</code></pre>"},{"location":"sdk/label_parsing/#named-entities-recognition-in-pdfs-tasks","title":"Named entities recognition in PDFs tasks","text":""},{"location":"sdk/label_parsing/#content_1","title":"<code>.content</code>","text":"<p>Returns the content of the mention.</p> <pre><code>label.jobs[\"NER_PDF_JOB\"].annotations[0].content\n</code></pre>"},{"location":"sdk/label_parsing/#annotations","title":"<code>.annotations</code>","text":"<p>NER in PDFs annotations have an additional layer of annotations. See the documentation for more information.</p>"},{"location":"sdk/label_parsing/#polys","title":"<code>.polys</code>","text":"<p>Returns a list of dictionaries containing the normalized vertices of the mention.</p> <pre><code>label.jobs[\"NER_PDF_JOB\"].annotations[0].annotations[0].polys\n</code></pre>"},{"location":"sdk/label_parsing/#page_number_array","title":"<code>.page_number_array</code>","text":"<pre><code>label.jobs[\"NER_PDF_JOB\"].annotations[0].annotations[0].page_number_array\n</code></pre>"},{"location":"sdk/label_parsing/#bounding_poly_1","title":"<code>.bounding_poly</code>","text":"<p>Returns a list of dictionaries containing the normalized vertices of the mention.</p> <pre><code>label.jobs[\"NER_PDF_JOB\"].annotations[0].annotations[0].bounding_poly\n</code></pre>"},{"location":"sdk/label_parsing/#relation-tasks","title":"Relation tasks","text":""},{"location":"sdk/label_parsing/#named-entities-relation","title":"Named entities relation","text":""},{"location":"sdk/label_parsing/#start_entities","title":"<code>.start_entities</code>","text":"<p>Returns a list of dictionaries containing the start entities Ids of the relation.</p> <pre><code>label.jobs[\"NER_RELATION_JOB\"].annotations[0].start_entities\n</code></pre>"},{"location":"sdk/label_parsing/#end_entities","title":"<code>.end_entities</code>","text":"<p>Returns a list of dictionaries containing the end entities Ids of the relation.</p> <pre><code>label.jobs[\"NER_RELATION_JOB\"].annotations[0].end_entities\n</code></pre>"},{"location":"sdk/label_parsing/#object-detection-relation","title":"Object detection relation","text":""},{"location":"sdk/label_parsing/#start_objects","title":"<code>.start_objects</code>","text":"<p>Returns a list of dictionaries containing the start objects Ids of the relation.</p> <pre><code>label.jobs[\"OBJECT_RELATION_JOB\"].annotations[0].start_objects\n</code></pre>"},{"location":"sdk/label_parsing/#end_objects","title":"<code>.end_objects</code>","text":"<p>Returns a list of dictionaries containing the end objects Ids of the relation.</p> <pre><code>label.jobs[\"OBJECT_RELATION_JOB\"].annotations[0].end_objects\n</code></pre>"},{"location":"sdk/label_parsing/#children-tasks","title":"Children tasks","text":""},{"location":"sdk/label_parsing/#children","title":"<code>.children</code>","text":"<p>Depending on the task, the <code>.children</code> attribute can be found in different places:</p> <pre><code># For cassification task\nlabel.jobs[\"CLASSIF_JOB\"].category.children\n\n# For several kinds of tasks: object detection, NER, pose estimation, etc.\nlabel.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].children\n</code></pre> <p>You can find more information about the children jobs in the label parsing tutorial.</p>"},{"location":"sdk/label_parsing/#migrating-from-jsonreponse-format","title":"Migrating from jsonReponse format","text":"<p>In most cases, the attributes of a parsed label are the snake case version of the keys present in the json response.</p> <p>For example, with a NER (named entities recognition) label, you can access the <code>beginOffset</code> data of an annotation with <code>parsed_label.jobs[\"NER_JOB\"].annotations[0].begin_offset</code>.</p> <p>The different json response keys are listed in the Kili documentation:</p> <ul> <li>for classification tasks</li> <li>for exported object/entity detection and relation tasks</li> <li>for exported transcription tasks.</li> </ul>"},{"location":"sdk/label_utils/","title":"Label utils module","text":"<p>The module <code>kili.utils.labels</code> provides a set of helpers to convert point, bounding box, polygon and segmentation labels.</p> <p>Info</p> <p>In Kili json response format, a normalized vertex is a dictionary with keys <code>x</code> and <code>y</code> and values between <code>0</code> and <code>1</code>. The origin is always the top left corner of the image. The x-axis is horizontal and the y-axis is vertical with the y-axis pointing down. You can find more information about the Kili data format here.</p>"},{"location":"sdk/label_utils/#points","title":"Points","text":"<p><code>kili.utils.labels.point</code></p> <p>Helpers to create point annotations.</p>"},{"location":"sdk/label_utils/#kili.utils.labels.point.normalized_point_to_point","title":"<code>normalized_point_to_point(point, img_width=None, img_height=None, origin_location='bottom_left')</code>","text":"<p>Convert a Kili normalized vertex to a 2D point.</p> <p>It is the inverse of the method <code>point_to_normalized_point</code>.</p> <p>A point is a dict with keys <code>\"x\"</code> and <code>\"y\"</code>, and corresponding values in pixels (<code>int</code> or <code>float</code>).</p> <p>Conventions for the input point:</p> <ul> <li>The origin is the top left corner of the image.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical and goes from top to bottom.</li> </ul> <p>Conventions for the output point:</p> <ul> <li>The origin is defined by the <code>origin_location</code> argument.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical. If <code>origin_location</code> is <code>\"top_left\"</code>, it goes from top to bottom. If <code>origin_location</code> is <code>\"bottom_left\"</code>, it goes from bottom to top.</li> </ul> <p>If the image width and height are provided, the output point coordinates will be scaled to the image size. If not, the method will return a point with normalized coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Dict[str, float]</code> <p>Point to convert.</p> required <code>img_width</code> <code>Union[int, float]</code> <p>Width of the image the point is defined in.</p> <code>None</code> <code>img_height</code> <code>Union[int, float]</code> <p>Height of the image the point is defined in.</p> <code>None</code> <code>origin_location</code> <code>Literal['top_left', 'bottom_left']</code> <p>Location of the origin of output point coordinate system. Can be either <code>top_left</code> or <code>bottom_left</code>.</p> <code>'bottom_left'</code> <p>Returns:</p> Type Description <code>Dict[Literal['x', 'y'], float]</code> <p>A dict with keys <code>\"x\"</code> and <code>\"y\"</code>, and corresponding values in pixels.</p> Source code in <code>kili/utils/labels/point.py</code> <pre><code>def normalized_point_to_point(\n    point: Dict[str, float],\n    img_width: Optional[Union[int, float]] = None,\n    img_height: Optional[Union[int, float]] = None,\n    origin_location: Literal[\"top_left\", \"bottom_left\"] = \"bottom_left\",\n) -&gt; Dict[Literal[\"x\", \"y\"], float]:\n    # pylint: disable=line-too-long\n    \"\"\"Convert a Kili normalized vertex to a 2D point.\n\n    It is the inverse of the method `point_to_normalized_point`.\n\n    A point is a dict with keys `\"x\"` and `\"y\"`, and corresponding values in pixels (`int` or `float`).\n\n    Conventions for the input point:\n\n    - The origin is the top left corner of the image.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical and goes from top to bottom.\n\n    Conventions for the output point:\n\n    - The origin is defined by the `origin_location` argument.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical. If `origin_location` is `\"top_left\"`, it goes from top to bottom. If `origin_location` is `\"bottom_left\"`, it goes from bottom to top.\n\n    If the image width and height are provided, the output point coordinates will be scaled to the image size.\n    If not, the method will return a point with normalized coordinates.\n\n    Args:\n        point: Point to convert.\n        img_width: Width of the image the point is defined in.\n        img_height: Height of the image the point is defined in.\n        origin_location: Location of the origin of output point coordinate system. Can be either `top_left` or `bottom_left`.\n\n    Returns:\n        A dict with keys `\"x\"` and `\"y\"`, and corresponding values in pixels.\n    \"\"\"\n    if (img_width is None) != (img_height is None):\n        raise ValueError(\"img_width and img_height must be both None or both not None.\")\n\n    if origin_location == \"bottom_left\":\n        point = {\"x\": point[\"x\"], \"y\": 1 - point[\"y\"]}\n\n    img_height = img_height or 1\n    img_width = img_width or 1\n\n    return {\"x\": point[\"x\"] * img_width, \"y\": point[\"y\"] * img_height}\n</code></pre>"},{"location":"sdk/label_utils/#kili.utils.labels.point.point_to_normalized_point","title":"<code>point_to_normalized_point(point, img_width=None, img_height=None, origin_location='bottom_left')</code>","text":"<p>Converts a 2D point to a Kili normalized vertex.</p> <p>The output can be used to create object detection annotations. See the documentation for more details.</p> <p>A point is a dict with keys <code>\"x\"</code> and <code>\"y\"</code>, and corresponding values in pixels (<code>int</code> or <code>float</code>).</p> <p>Conventions for the input point:</p> <ul> <li>The origin is defined by the <code>origin_location</code> argument.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical. If <code>origin_location</code> is <code>\"top_left\"</code>, it goes from top to bottom. If <code>origin_location</code> is <code>\"bottom_left\"</code>, it goes from bottom to top.</li> </ul> <p>Conventions for the output point:</p> <ul> <li>The origin is the top left corner of the image.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical and goes from top to bottom.</li> </ul> <p>If the image width and height are provided, the input point coordinates will be normalized to <code>[0, 1]</code>. If not, the method expects the input point coordinates to be already normalized.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Dict[str, Union[int, float]]</code> <p>Point to convert.</p> required <code>img_width</code> <code>Union[int, float]</code> <p>Width of the image the point is defined in.</p> <code>None</code> <code>img_height</code> <code>Union[int, float]</code> <p>Height of the image the point is defined in.</p> <code>None</code> <code>origin_location</code> <code>Literal['top_left', 'bottom_left']</code> <p>Location of the origin of input point coordinate system. Can be either <code>top_left</code> or <code>bottom_left</code>.</p> <code>'bottom_left'</code> <p>Returns:</p> Type Description <code>Dict[Literal['x', 'y'], float]</code> <p>A dict with keys <code>\"x\"</code> and <code>\"y\"</code>, and corresponding normalized values.</p> <p>Example</p> <pre><code>from kili.utils.labels.point import point_to_normalized_point\n\nnormalized_point = point_to_normalized_point({\"x\": 5, \"y\": 40}, img_width=100, img_height=100)\n\njson_response = {\n    \"OBJECT_DETECTION_JOB\": {\n        \"annotations\": [\n            {\n                \"point\": normalized_point,\n                \"categories\": [{\"name\": \"CLASS_A\"}],\n                \"type\": \"marker\",\n            }\n        ]\n    }\n}\n</code></pre> Source code in <code>kili/utils/labels/point.py</code> <pre><code>def point_to_normalized_point(\n    point: Dict[str, Union[int, float]],\n    img_width: Optional[Union[int, float]] = None,\n    img_height: Optional[Union[int, float]] = None,\n    origin_location: Literal[\"top_left\", \"bottom_left\"] = \"bottom_left\",\n) -&gt; Dict[Literal[\"x\", \"y\"], float]:\n    # pylint: disable=line-too-long\n    \"\"\"Converts a 2D point to a Kili normalized vertex.\n\n    The output can be used to create object detection annotations. See the [documentation](https://docs.kili-technology.com/reference/export-object-entity-detection-and-relation) for more details.\n\n    A point is a dict with keys `\"x\"` and `\"y\"`, and corresponding values in pixels (`int` or `float`).\n\n    Conventions for the input point:\n\n    - The origin is defined by the `origin_location` argument.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical. If `origin_location` is `\"top_left\"`, it goes from top to bottom. If `origin_location` is `\"bottom_left\"`, it goes from bottom to top.\n\n    Conventions for the output point:\n\n    - The origin is the top left corner of the image.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical and goes from top to bottom.\n\n    If the image width and height are provided, the input point coordinates will be normalized to `[0, 1]`.\n    If not, the method expects the input point coordinates to be already normalized.\n\n    Args:\n        point: Point to convert.\n        img_width: Width of the image the point is defined in.\n        img_height: Height of the image the point is defined in.\n        origin_location: Location of the origin of input point coordinate system. Can be either `top_left` or `bottom_left`.\n\n    Returns:\n        A dict with keys `\"x\"` and `\"y\"`, and corresponding normalized values.\n\n    !!! Example\n        ```python\n        from kili.utils.labels.point import point_to_normalized_point\n\n        normalized_point = point_to_normalized_point({\"x\": 5, \"y\": 40}, img_width=100, img_height=100)\n\n        json_response = {\n            \"OBJECT_DETECTION_JOB\": {\n                \"annotations\": [\n                    {\n                        \"point\": normalized_point,\n                        \"categories\": [{\"name\": \"CLASS_A\"}],\n                        \"type\": \"marker\",\n                    }\n                ]\n            }\n        }\n        ```\n    \"\"\"\n    if (img_width is None) != (img_height is None):\n        raise ValueError(\"img_width and img_height must be both None or both not None.\")\n\n    if img_width is not None and img_height is not None:\n        point = {\n            \"x\": point[\"x\"] / img_width,\n            \"y\": point[\"y\"] / img_height,\n        }\n\n    if origin_location == \"bottom_left\":\n        point = {\"x\": point[\"x\"], \"y\": 1 - point[\"y\"]}\n\n    assert 0 &lt;= point[\"x\"] &lt;= 1, f\"Point x coordinate {point['x']} should be in [0, 1].\"\n    assert 0 &lt;= point[\"y\"] &lt;= 1, f\"Point y coordinate {point['y']} should be in [0, 1].\"\n\n    return {\"x\": point[\"x\"], \"y\": point[\"y\"]}\n</code></pre>"},{"location":"sdk/label_utils/#bounding-boxes","title":"Bounding boxes","text":"<p><code>kili.utils.labels.bbox</code></p> <p>Helpers to create boundingPoly rectangle annotations.</p>"},{"location":"sdk/label_utils/#kili.utils.labels.bbox.bbox_points_to_normalized_vertices","title":"<code>bbox_points_to_normalized_vertices(*, bottom_left, bottom_right, top_right, top_left, img_width=None, img_height=None, origin_location='bottom_left')</code>","text":"<p>Converts a bounding box defined by its 4 points to normalized vertices.</p> <p>The output can be used to create a boundingPoly rectangle annotation. See the documentation for more details.</p> <p>A point is a dict with keys <code>\"x\"</code> and <code>\"y\"</code>, and corresponding values in pixels (<code>int</code> or <code>float</code>).</p> <p>Conventions for the input points:</p> <ul> <li>The origin is defined by the <code>origin_location</code> argument.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical. If <code>origin_location</code> is <code>\"top_left\"</code>, it goes from top to bottom. If <code>origin_location</code> is <code>\"bottom_left\"</code>, it goes from bottom to top.</li> </ul> <p>Conventions for the output vertices:</p> <ul> <li>The origin is the top left corner of the image.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical and goes from top to bottom.</li> </ul> <p>If the image width and height are provided, the input point coordinates will be normalized to <code>[0, 1]</code>. If not, the method expects the input points' coordinates to be already normalized.</p> <p>Parameters:</p> Name Type Description Default <code>bottom_left</code> <code>Dict[str, Union[int, float]]</code> <p>Bottom left point of the bounding box.</p> required <code>bottom_right</code> <code>Dict[str, Union[int, float]]</code> <p>Bottom right point of the bounding box.</p> required <code>top_right</code> <code>Dict[str, Union[int, float]]</code> <p>Top right point of the bounding box.</p> required <code>top_left</code> <code>Dict[str, Union[int, float]]</code> <p>Top left point of the bounding box.</p> required <code>img_width</code> <code>Union[int, float]</code> <p>Width of the image the bounding box is defined in.</p> <code>None</code> <code>img_height</code> <code>Union[int, float]</code> <p>Height of the image the bounding box is defined in.</p> <code>None</code> <code>origin_location</code> <code>Literal['top_left', 'bottom_left']</code> <p>Location of the origin of input point coordinate system. Can be either <code>top_left</code> or <code>bottom_left</code>.</p> <code>'bottom_left'</code> <p>Returns:</p> Type Description <code>List[Dict[Literal['x', 'y'], float]]</code> <p>A list of normalized vertices.</p> <p>Example</p> <pre><code>from kili.utils.labels.bbox import bbox_points_to_normalized_vertices\n\ninputs = {\n    bottom_left = {\"x\": 0, \"y\": 0},\n    bottom_right = {\"x\": 10, \"y\": 0},\n    top_right = {\"x\": 10, \"y\": 10},\n    top_left = {\"x\": 0, \"y\": 10},\n    img_width = 100,\n    img_height = 100,\n}\nnormalized_vertices = bbox_points_to_normalized_vertices(**inputs)\njson_response = {\n    \"OBJECT_DETECTION_JOB\": {\n        \"annotations\": [\n            {\n                \"boundingPoly\": [{\"normalizedVertices\": normalized_vertices}],\n                \"categories\": [{\"name\": \"CLASS_A\"}],\n                \"type\": \"rectangle\",\n            }\n        ]\n    }\n}\n</code></pre> Source code in <code>kili/utils/labels/bbox.py</code> <pre><code>def bbox_points_to_normalized_vertices(\n    *,\n    bottom_left: Dict[str, Union[int, float]],\n    bottom_right: Dict[str, Union[int, float]],\n    top_right: Dict[str, Union[int, float]],\n    top_left: Dict[str, Union[int, float]],\n    img_width: Optional[Union[int, float]] = None,\n    img_height: Optional[Union[int, float]] = None,\n    origin_location: Literal[\"top_left\", \"bottom_left\"] = \"bottom_left\",\n) -&gt; List[Dict[Literal[\"x\", \"y\"], float]]:\n    # pylint: disable=line-too-long\n    \"\"\"Converts a bounding box defined by its 4 points to normalized vertices.\n\n    The output can be used to create a boundingPoly rectangle annotation. See the [documentation](https://docs.kili-technology.com/reference/export-object-entity-detection-and-relation#standard-object-detection) for more details.\n\n    A point is a dict with keys `\"x\"` and `\"y\"`, and corresponding values in pixels (`int` or `float`).\n\n    Conventions for the input points:\n\n    - The origin is defined by the `origin_location` argument.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical. If `origin_location` is `\"top_left\"`, it goes from top to bottom. If `origin_location` is `\"bottom_left\"`, it goes from bottom to top.\n\n    Conventions for the output vertices:\n\n    - The origin is the top left corner of the image.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical and goes from top to bottom.\n\n    If the image width and height are provided, the input point coordinates will be normalized to `[0, 1]`.\n    If not, the method expects the input points' coordinates to be already normalized.\n\n    Args:\n        bottom_left: Bottom left point of the bounding box.\n        bottom_right: Bottom right point of the bounding box.\n        top_right: Top right point of the bounding box.\n        top_left: Top left point of the bounding box.\n        img_width: Width of the image the bounding box is defined in.\n        img_height: Height of the image the bounding box is defined in.\n        origin_location: Location of the origin of input point coordinate system. Can be either `top_left` or `bottom_left`.\n\n    Returns:\n        A list of normalized vertices.\n\n    !!! Example\n        ```python\n        from kili.utils.labels.bbox import bbox_points_to_normalized_vertices\n\n        inputs = {\n            bottom_left = {\"x\": 0, \"y\": 0},\n            bottom_right = {\"x\": 10, \"y\": 0},\n            top_right = {\"x\": 10, \"y\": 10},\n            top_left = {\"x\": 0, \"y\": 10},\n            img_width = 100,\n            img_height = 100,\n        }\n        normalized_vertices = bbox_points_to_normalized_vertices(**inputs)\n        json_response = {\n            \"OBJECT_DETECTION_JOB\": {\n                \"annotations\": [\n                    {\n                        \"boundingPoly\": [{\"normalizedVertices\": normalized_vertices}],\n                        \"categories\": [{\"name\": \"CLASS_A\"}],\n                        \"type\": \"rectangle\",\n                    }\n                ]\n            }\n        }\n        ```\n    \"\"\"\n    assert bottom_left[\"x\"] &lt;= bottom_right[\"x\"], \"bottom_left.x must be &lt;= bottom_right.x\"\n    assert top_left[\"x\"] &lt;= top_right[\"x\"], \"top_left.x must be &lt;= top_right.x\"\n    if origin_location == \"bottom_left\":\n        assert bottom_left[\"y\"] &lt;= top_left[\"y\"], \"bottom_left.y must be &lt;= top_left.y\"\n        assert bottom_right[\"y\"] &lt;= top_right[\"y\"], \"bottom_right.y must be &lt;= top_right.y\"\n    elif origin_location == \"top_left\":\n        assert bottom_left[\"y\"] &gt;= top_left[\"y\"], \"bottom_left.y must be &gt;= top_left.y\"\n        assert bottom_right[\"y\"] &gt;= top_right[\"y\"], \"bottom_right.y must be &gt;= top_right.y\"\n\n    if (img_width is None) != (img_height is None):\n        raise ValueError(\"img_width and img_height must be both None or both not None.\")\n\n    return [\n        point_to_normalized_point(\n            point, img_width=img_width, img_height=img_height, origin_location=origin_location\n        )\n        for point in (bottom_left, top_left, top_right, bottom_right)\n    ]\n</code></pre>"},{"location":"sdk/label_utils/#kili.utils.labels.bbox.normalized_vertices_to_bbox_points","title":"<code>normalized_vertices_to_bbox_points(normalized_vertices, img_width=None, img_height=None, origin_location='bottom_left')</code>","text":"<p>Converts a rectangle normalizedVertices annotation to a bounding box defined by 4 points.</p> <p>It is the inverse of the method <code>bbox_points_to_normalized_vertices</code>.</p> <p>A point is a dict with keys <code>\"x\"</code> and <code>\"y\"</code>, and corresponding values in pixels (<code>int</code> or <code>float</code>).</p> <p>Conventions for the input vertices:</p> <ul> <li>The origin is the top left corner of the image.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical and goes from top to bottom.</li> </ul> <p>Conventions for the output points (<code>top_left</code>, <code>bottom_left</code>, <code>bottom_right</code>, <code>top_right</code>):</p> <ul> <li>The origin is defined by the <code>origin_location</code> argument.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical. If <code>origin_location</code> is <code>\"top_left\"</code>, it goes from top to bottom. If <code>origin_location</code> is <code>\"bottom_left\"</code>, it goes from bottom to top.</li> </ul> <p>If the image width and height are provided, the output point coordinates will be scaled to the image size. If not, the method will return the output points' coordinates normalized to <code>[0, 1]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>normalized_vertices</code> <code>List[Dict[str, float]]</code> <p>A list of normalized vertices.</p> required <code>img_width</code> <code>Union[int, float]</code> <p>Width of the image the bounding box is defined in.</p> <code>None</code> <code>img_height</code> <code>Union[int, float]</code> <p>Height of the image the bounding box is defined in.</p> <code>None</code> <code>origin_location</code> <code>Literal['top_left', 'bottom_left']</code> <p>Location of the origin of output point coordinate system. Can be either <code>top_left</code> or <code>bottom_left</code>.</p> <code>'bottom_left'</code> <p>Returns:</p> Type Description <code>Dict[Literal['top_left', 'bottom_left', 'bottom_right', 'top_right'], Dict[Literal['x', 'y'], float]]</code> <p>A dict with keys <code>\"top_left\"</code>, <code>\"bottom_left\"</code>, <code>\"bottom_right\"</code>, <code>\"top_right\"</code>, and corresponding points.</p> <p>Example</p> <pre><code>from kili.utils.labels.bbox import normalized_vertices_to_bbox_points\n\n# if using raw dict label:\nnormalized_vertices = label[\"jsonResponse\"][\"OBJECT_DETECTION_JOB\"][\"annotations\"][0][\"boundingPoly\"][0][\"normalizedVertices\"]\n\n# if using parsed label:\nnormalized_vertices = label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].bounding_poly[0].normalized_vertices\n\nimg_height, img_width = 1080, 1920\nbbox_points = normalized_vertices_to_bbox_points(normalized_vertices, img_width, img_height)\n</code></pre> Source code in <code>kili/utils/labels/bbox.py</code> <pre><code>def normalized_vertices_to_bbox_points(\n    normalized_vertices: List[Dict[str, float]],\n    img_width: Optional[Union[int, float]] = None,\n    img_height: Optional[Union[int, float]] = None,\n    origin_location: Literal[\"top_left\", \"bottom_left\"] = \"bottom_left\",\n) -&gt; Dict[\n    Literal[\"top_left\", \"bottom_left\", \"bottom_right\", \"top_right\"], Dict[Literal[\"x\", \"y\"], float]\n]:\n    # pylint: disable=line-too-long\n    \"\"\"Converts a rectangle normalizedVertices annotation to a bounding box defined by 4 points.\n\n    It is the inverse of the method `bbox_points_to_normalized_vertices`.\n\n    A point is a dict with keys `\"x\"` and `\"y\"`, and corresponding values in pixels (`int` or `float`).\n\n    Conventions for the input vertices:\n\n    - The origin is the top left corner of the image.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical and goes from top to bottom.\n\n    Conventions for the output points (`top_left`, `bottom_left`, `bottom_right`, `top_right`):\n\n    - The origin is defined by the `origin_location` argument.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical. If `origin_location` is `\"top_left\"`, it goes from top to bottom. If `origin_location` is `\"bottom_left\"`, it goes from bottom to top.\n\n    If the image width and height are provided, the output point coordinates will be scaled to the image size.\n    If not, the method will return the output points' coordinates normalized to `[0, 1]`.\n\n    Args:\n        normalized_vertices: A list of normalized vertices.\n        img_width: Width of the image the bounding box is defined in.\n        img_height: Height of the image the bounding box is defined in.\n        origin_location: Location of the origin of output point coordinate system. Can be either `top_left` or `bottom_left`.\n\n    Returns:\n        A dict with keys `\"top_left\"`, `\"bottom_left\"`, `\"bottom_right\"`, `\"top_right\"`, and corresponding points.\n\n    !!! Example\n        ```python\n        from kili.utils.labels.bbox import normalized_vertices_to_bbox_points\n\n        # if using raw dict label:\n        normalized_vertices = label[\"jsonResponse\"][\"OBJECT_DETECTION_JOB\"][\"annotations\"][0][\"boundingPoly\"][0][\"normalizedVertices\"]\n\n        # if using parsed label:\n        normalized_vertices = label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].bounding_poly[0].normalized_vertices\n\n        img_height, img_width = 1080, 1920\n        bbox_points = normalized_vertices_to_bbox_points(normalized_vertices, img_width, img_height)\n        ```\n    \"\"\"\n    if len(normalized_vertices) != 4:\n        raise ValueError(f\"normalized_vertices must have length 4. Got {len(normalized_vertices)}.\")\n\n    if (img_width is None) != (img_height is None):\n        raise ValueError(\"img_width and img_height must be both None or both not None.\")\n\n    img_height = img_height or 1\n    img_width = img_width or 1\n\n    ret = {}\n\n    for vertex, point_name in zip(\n        normalized_vertices, (\"bottom_left\", \"top_left\", \"top_right\", \"bottom_right\")\n    ):\n        ret[point_name] = normalized_point_to_point(\n            vertex, img_width=img_width, img_height=img_height, origin_location=origin_location\n        )\n\n    return ret\n</code></pre>"},{"location":"sdk/label_utils/#polygon-and-segmentation-masks","title":"Polygon and segmentation masks","text":"<p><code>kili.utils.labels.image</code></p> <p>OpenCV</p> <p>It is recommended to install the image dependencies to use the image helpers.</p> <pre><code>pip install kili[image-utils]\n</code></pre> <p>Helpers to create boundingPoly polygon and semantic annotations.</p>"},{"location":"sdk/label_utils/#kili.utils.labels.image.mask_to_normalized_vertices","title":"<code>mask_to_normalized_vertices(image)</code>","text":"<p>Converts a binary mask to a list of normalized vertices using OpenCV cv2.findContours.</p> <p>The output can be used to create \"boundingPoly\" polygon or semantic annotations. See the documentation for more details.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>Binary mask. Should be an array of shape (height, width) with values in {0, 255}.</p> required <p>Returns:</p> Type Description <code>Tuple</code> <p>A tuple containing a list of normalized vertices and the hierarchy of the contours (see OpenCV documentation).</p> <p>Example</p> <pre><code>import urllib.request\nimport cv2\nfrom kili.utils.labels.image import mask_to_normalized_vertices\n\nmask_url = \"https://raw.githubusercontent.com/kili-technology/kili-python-sdk/main/recipes/img/HUMAN.mask.png\"\nurllib.request.urlretrieve(mask_url, \"mask.png\")\n\nimg = cv2.imread(\"mask.png\")[:, :, 0]  # keep only height and width\nimg[200:220, 200:220] = 0  # add a hole in the mask to test the hierarchy\n\ncontours, hierarchy = mask_to_normalized_vertices(img)\n# hierarchy tells us that the first contour is the outer contour\n# and the second one is the inner contour\n\njson_response = {\n    \"OBJECT_DETECTION_JOB\": {\n        \"annotations\": [\n            {\n                \"boundingPoly\": [\n                    {\"normalizedVertices\": contours[0]},  # outer contour\n                    {\"normalizedVertices\": contours[1]},  # inner contour\n                ],\n                \"categories\": [{\"name\": \"A\"}],\n                \"type\": \"semantic\",\n            }\n        ]\n    }\n}\n</code></pre> Source code in <code>kili/utils/labels/image.py</code> <pre><code>def mask_to_normalized_vertices(\n    image: np.ndarray,\n) -&gt; Tuple[List[List[Dict[str, float]]], np.ndarray]:\n    # pylint: disable=line-too-long\n    \"\"\"Converts a binary mask to a list of normalized vertices using OpenCV [cv2.findContours](https://docs.opencv.org/4.7.0/d3/dc0/group__imgproc__shape.html#gadf1ad6a0b82947fa1fe3c3d497f260e0).\n\n    The output can be used to create \"boundingPoly\" polygon or semantic annotations.\n    See the [documentation](https://docs.kili-technology.com/reference/export-object-entity-detection-and-relation#standard-object-detection) for more details.\n\n    Args:\n        image: Binary mask. Should be an array of shape (height, width) with values in {0, 255}.\n\n    Returns:\n        Tuple: A tuple containing a list of normalized vertices and the hierarchy of the contours (see [OpenCV documentation](https://docs.opencv.org/4.7.0/d9/d8b/tutorial_py_contours_hierarchy.html)).\n\n    !!! Example\n        ```python\n        import urllib.request\n        import cv2\n        from kili.utils.labels.image import mask_to_normalized_vertices\n\n        mask_url = \"https://raw.githubusercontent.com/kili-technology/kili-python-sdk/main/recipes/img/HUMAN.mask.png\"\n        urllib.request.urlretrieve(mask_url, \"mask.png\")\n\n        img = cv2.imread(\"mask.png\")[:, :, 0]  # keep only height and width\n        img[200:220, 200:220] = 0  # add a hole in the mask to test the hierarchy\n\n        contours, hierarchy = mask_to_normalized_vertices(img)\n        # hierarchy tells us that the first contour is the outer contour\n        # and the second one is the inner contour\n\n        json_response = {\n            \"OBJECT_DETECTION_JOB\": {\n                \"annotations\": [\n                    {\n                        \"boundingPoly\": [\n                            {\"normalizedVertices\": contours[0]},  # outer contour\n                            {\"normalizedVertices\": contours[1]},  # inner contour\n                        ],\n                        \"categories\": [{\"name\": \"A\"}],\n                        \"type\": \"semantic\",\n                    }\n                ]\n            }\n        }\n        ```\n    \"\"\"\n    if image.ndim &gt; 2:\n        raise ValueError(f\"Image should be a 2D array, got {image.ndim}D array\")\n\n    unique_values = np.unique(image).tolist()\n    if not all(value in [0, 255] for value in unique_values):\n        raise ValueError(f\"Image should be binary with values in {{0, 255}}, got {unique_values}\")\n\n    img_height, img_width = image.shape\n    # pylint:disable=no-member\n    contours, hierarchy = cv2.findContours(image, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)  # type: ignore\n\n    contours = [\n        _opencv_contour_to_normalized_vertices(contour, img_width, img_height)\n        for contour in contours\n    ]\n    hierarchy = hierarchy[0]\n\n    return contours, hierarchy\n</code></pre>"},{"location":"sdk/label_utils/#kili.utils.labels.image.normalized_vertices_to_mask","title":"<code>normalized_vertices_to_mask(normalized_vertices, img_width, img_height)</code>","text":"<p>Converts a Kili label with normalized vertices to a binary mask.</p> <p>It is the inverse of the method <code>mask_to_normalized_vertices</code>.</p> <p>Parameters:</p> Name Type Description Default <code>normalized_vertices</code> <code>List[Dict[str, float]]</code> <p>A list of normalized vertices.</p> required <code>img_width</code> <code>int</code> <p>Width of the image the segmentation is defined in.</p> required <code>img_height</code> <code>int</code> <p>Height of the image the segmentation is defined in.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array of shape (height, width) with values in {0, 255}.</p> <p>Example</p> <pre><code>from kili.utils.labels.image import normalized_vertices_to_mask\n\n# if using raw dict label:\nnormalized_vertices = label[\"jsonResponse\"][\"OBJECT_DETECTION_JOB\"][\"annotations\"][0][\"boundingPoly\"][0][\"normalizedVertices\"]\n\n# if using parsed label:\nnormalized_vertices = label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].bounding_poly[0].normalized_vertices\n\nimg_height, img_width = 1080, 1920\nmask = normalized_vertices_to_mask(normalized_vertices, img_width, img_height)\nplt.imshow(mask)\nplt.show()\n</code></pre> Source code in <code>kili/utils/labels/image.py</code> <pre><code>def normalized_vertices_to_mask(\n    normalized_vertices: List[Dict[str, float]], img_width: int, img_height: int\n) -&gt; np.ndarray:\n    # pylint: disable=line-too-long\n    \"\"\"Converts a Kili label with normalized vertices to a binary mask.\n\n    It is the inverse of the method `mask_to_normalized_vertices`.\n\n    Args:\n        normalized_vertices: A list of normalized vertices.\n        img_width: Width of the image the segmentation is defined in.\n        img_height: Height of the image the segmentation is defined in.\n\n    Returns:\n        A numpy array of shape (height, width) with values in {0, 255}.\n\n    !!! Example\n        ```python\n        from kili.utils.labels.image import normalized_vertices_to_mask\n\n        # if using raw dict label:\n        normalized_vertices = label[\"jsonResponse\"][\"OBJECT_DETECTION_JOB\"][\"annotations\"][0][\"boundingPoly\"][0][\"normalizedVertices\"]\n\n        # if using parsed label:\n        normalized_vertices = label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].bounding_poly[0].normalized_vertices\n\n        img_height, img_width = 1080, 1920\n        mask = normalized_vertices_to_mask(normalized_vertices, img_width, img_height)\n        plt.imshow(mask)\n        plt.show()\n        ```\n    \"\"\"\n    mask = np.zeros((img_height, img_width), dtype=np.uint8)\n    polygon = [\n        [\n            int(round(vertice[\"x\"] * img_width)),\n            int(round(vertice[\"y\"] * img_height)),\n        ]\n        for vertice in normalized_vertices\n    ]\n    polygon = np.array([polygon])\n    cv2.fillPoly(img=mask, pts=polygon, color=255)  # type: ignore  # pylint:disable=no-member\n    return mask\n</code></pre>"},{"location":"sdk/label_utils/#geojson","title":"GeoJson","text":"<p>Info</p> <p>Label coordinates of GeoTIFF files (with geospatial metadata) are expressed in latitude and longitude where <code>x</code> stands for longitude and <code>y</code> for latitude.</p> <p>Read more about Kili labeling features for geospatial imagery here.</p> <p>Warning</p> <p>If the geotiff image asset does not have geospatial metadata, the coordinates will be expressed in normalized coordinates, and the export to GeoJSON will not be accurate since the geospatial information is missing.</p> <p>To check if your image asset has geospatial metadata, you can use the following code snippet:</p> <pre><code>&gt;&gt;&gt; asset = kili.assets(..., fields=[\"jsonContent\"])[0]\n&gt;&gt;&gt; print(asset['jsonContent'])\n\n# asset without geospatial metadata\n[{\"imageUrl\": \"https://...\", \"initEpsg\": -1, \"useClassicCoordinates\": true}]\n\n# asset with geospatial metadata\n# note that the epsg and initEpsg may be different for your asset\n[{\"bounds\": [[...], [...]], \"epsg\": \"EPSG4326\", \"imageUrl\": \"https://...\", \"initEpsg\": 4326, \"useClassicCoordinates\": false}]\n</code></pre>"},{"location":"sdk/label_utils/#point","title":"Point","text":"<p>Point label utils.</p>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.point.geojson_point_feature_to_kili_point_annotation","title":"<code>geojson_point_feature_to_kili_point_annotation(point, categories=None, children=None, mid=None)</code>","text":"<p>Convert a geojson point feature to a Kili point annotation.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Dict[str, Any]</code> <p>a geojson point feature.</p> required <code>categories</code> <code>Optional[List[Dict]]</code> <p>the categories of the annotation. If not provided, the categories are taken from the <code>kili</code> key of the geojson feature properties.</p> <code>None</code> <code>children</code> <code>Optional[Dict]</code> <p>the children of the annotation. If not provided, the children are taken from the <code>kili</code> key of the geojson feature properties.</p> <code>None</code> <code>mid</code> <code>Optional[str]</code> <p>the mid of the annotation. If not provided, the mid is taken from the <code>id</code> key of the geojson feature.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A Kili point annotation.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; point = {\n    'type': 'Feature',\n    'geometry': {'type': 'Point', 'coordinates': [-79.0, -3.0]},\n    'id': 'mid_object',\n    'properties': {'kili': {'categories': [{'name': 'A'}]}}\n}\n&gt;&gt;&gt; geojson_point_feature_to_kili_point_annotation(point)\n{\n    'children': {},\n    'point': {'x': -79.0, 'y': -3.0},\n    'categories': [{'name': 'A'}],\n    'mid': 'mid_object',\n    'type': 'marker'\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/point.py</code> <pre><code>def geojson_point_feature_to_kili_point_annotation(\n    point: Dict[str, Any],\n    categories: Optional[List[Dict]] = None,\n    children: Optional[Dict] = None,\n    mid: Optional[str] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert a geojson point feature to a Kili point annotation.\n\n    Args:\n        point: a geojson point feature.\n        categories: the categories of the annotation.\n            If not provided, the categories are taken from the `kili` key of the geojson feature properties.\n        children: the children of the annotation.\n            If not provided, the children are taken from the `kili` key of the geojson feature properties.\n        mid: the mid of the annotation.\n            If not provided, the mid is taken from the `id` key of the geojson feature.\n\n    Returns:\n        A Kili point annotation.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; point = {\n            'type': 'Feature',\n            'geometry': {'type': 'Point', 'coordinates': [-79.0, -3.0]},\n            'id': 'mid_object',\n            'properties': {'kili': {'categories': [{'name': 'A'}]}}\n        }\n        &gt;&gt;&gt; geojson_point_feature_to_kili_point_annotation(point)\n        {\n            'children': {},\n            'point': {'x': -79.0, 'y': -3.0},\n            'categories': [{'name': 'A'}],\n            'mid': 'mid_object',\n            'type': 'marker'\n        }\n        ```\n    \"\"\"\n    assert point.get(\"type\") == \"Feature\", f\"Feature type must be `Feature`, got: {point['type']}\"\n    assert (\n        point[\"geometry\"][\"type\"] == \"Point\"\n    ), f\"Geometry type must be `Point`, got: {point['geometry']['type']}\"\n\n    children = children or point[\"properties\"].get(\"kili\", {}).get(\"children\", {})\n    categories = categories or point[\"properties\"][\"kili\"][\"categories\"]\n\n    ret = {\n        \"children\": children,\n        \"categories\": categories,\n        \"type\": \"marker\",\n    }\n    ret[\"point\"] = {\n        \"x\": point[\"geometry\"][\"coordinates\"][0],\n        \"y\": point[\"geometry\"][\"coordinates\"][1],\n    }\n\n    if mid is not None:\n        ret[\"mid\"] = str(mid)\n    elif \"id\" in point:\n        ret[\"mid\"] = str(point[\"id\"])\n\n    return ret\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.point.kili_point_annotation_to_geojson_point_feature","title":"<code>kili_point_annotation_to_geojson_point_feature(point_annotation, job_name=None)</code>","text":"<p>Convert a Kili point annotation to a geojson point feature.</p> <p>Parameters:</p> Name Type Description Default <code>point_annotation</code> <code>Dict[str, Any]</code> <p>a Kili point annotation.</p> required <code>job_name</code> <code>Optional[str]</code> <p>the name of the job to which the annotation belongs.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A geojson point feature.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; point = {\n    'children': {},\n    'point': {'x': -79.0, 'y': -3.0},\n    'categories': [{'name': 'A'}],\n    'mid': 'mid_object',\n    'type': 'marker'\n}\n&gt;&gt;&gt; kili_point_annotation_to_geojson_point_feature(point)\n{\n    'type': 'Feature',\n    'geometry': {\n        'type': 'Point',\n        'coordinates': [-79.0, -3.0]},\n        'id': 'mid_object',\n        'properties': {\n            'kili': {\n                'categories': [{'name': 'A'}],\n                'children': {},\n                'type': 'marker'\n            }\n        }\n    }\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/point.py</code> <pre><code>def kili_point_annotation_to_geojson_point_feature(\n    point_annotation: Dict[str, Any], job_name: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert a Kili point annotation to a geojson point feature.\n\n    Args:\n        point_annotation: a Kili point annotation.\n        job_name: the name of the job to which the annotation belongs.\n\n    Returns:\n        A geojson point feature.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; point = {\n            'children': {},\n            'point': {'x': -79.0, 'y': -3.0},\n            'categories': [{'name': 'A'}],\n            'mid': 'mid_object',\n            'type': 'marker'\n        }\n        &gt;&gt;&gt; kili_point_annotation_to_geojson_point_feature(point)\n        {\n            'type': 'Feature',\n            'geometry': {\n                'type': 'Point',\n                'coordinates': [-79.0, -3.0]},\n                'id': 'mid_object',\n                'properties': {\n                    'kili': {\n                        'categories': [{'name': 'A'}],\n                        'children': {},\n                        'type': 'marker'\n                    }\n                }\n            }\n        }\n        ```\n    \"\"\"\n    point = point_annotation\n    assert point[\"type\"] == \"marker\", f\"Annotation type must be `marker`, got: {point['type']}\"\n\n    ret = {\"type\": \"Feature\", \"geometry\": kili_point_to_geojson_point(point[\"point\"])}\n    if \"mid\" in point:\n        ret[\"id\"] = point[\"mid\"]\n    ret[\"properties\"] = {\"kili\": {k: v for k, v in point.items() if k not in [\"point\", \"mid\"]}}\n    if job_name is not None:\n        ret[\"properties\"][\"kili\"][\"job\"] = job_name\n    return ret\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.point.kili_point_to_geojson_point","title":"<code>kili_point_to_geojson_point(point)</code>","text":"<p>Convert a Kili point to a geojson point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Dict[str, float]</code> <p>a Kili point (vertex).</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A geojson point.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; point = {\"x\": 1.0, \"y\": 2.0}\n&gt;&gt;&gt; kili_point_to_geojson_point(point)\n{\n    \"type\": \"Point\",\n    \"coordinates\": [1.0, 2.0]\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/point.py</code> <pre><code>def kili_point_to_geojson_point(point: Dict[str, float]) -&gt; Dict[str, Any]:\n    \"\"\"Convert a Kili point to a geojson point.\n\n    Args:\n        point: a Kili point (vertex).\n\n    Returns:\n        A geojson point.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; point = {\"x\": 1.0, \"y\": 2.0}\n        &gt;&gt;&gt; kili_point_to_geojson_point(point)\n        {\n            \"type\": \"Point\",\n            \"coordinates\": [1.0, 2.0]\n        }\n        ```\n    \"\"\"\n    return {\"type\": \"Point\", \"coordinates\": [point[\"x\"], point[\"y\"]]}\n</code></pre>"},{"location":"sdk/label_utils/#line","title":"Line","text":"<p>Geojson linestring utilities.</p>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.line.geojson_linestring_feature_to_kili_line_annotation","title":"<code>geojson_linestring_feature_to_kili_line_annotation(line, categories=None, children=None, mid=None)</code>","text":"<p>Convert a geojson linestring feature to a Kili line annotation.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>Dict[str, Any]</code> <p>a geojson linestring feature.</p> required <code>categories</code> <code>Optional[List[Dict]]</code> <p>the categories of the annotation. If not provided, the categories are taken from the <code>kili</code> key of the geojson feature properties.</p> <code>None</code> <code>children</code> <code>Optional[Dict]</code> <p>the children of the annotation. If not provided, the children are taken from the <code>kili</code> key of the geojson feature properties.</p> <code>None</code> <code>mid</code> <code>Optional[str]</code> <p>the mid of the annotation. If not provided, the mid is taken from the <code>id</code> key of the geojson feature.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A Kili line annotation.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; line = {\n    'type': 'Feature',\n    'geometry': {\n        'type': 'LineString',\n        'coordinates': [[-79.0, -3.0], [-79.0, -3.0]]},\n    }\n    'id': 'mid_object',\n    'properties': {\n        'kili': {\n            'categories': [{'name': 'A'}],\n            'children': {},\n            'job': 'job_name'\n        }\n    }\n}\n&gt;&gt;&gt; geojson_linestring_feature_to_kili_line_annotation(line)\n{\n    'children': {},\n    'polyline': [{'x': -79.0, 'y': -3.0}, {'x': -79.0, 'y': -3.0}],\n    'categories': [{'name': 'A'}],\n    'mid': 'mid_object',\n    'type': 'polyline'\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/line.py</code> <pre><code>def geojson_linestring_feature_to_kili_line_annotation(\n    line: Dict[str, Any],\n    categories: Optional[List[Dict]] = None,\n    children: Optional[Dict] = None,\n    mid: Optional[str] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert a geojson linestring feature to a Kili line annotation.\n\n    Args:\n        line: a geojson linestring feature.\n        categories: the categories of the annotation.\n            If not provided, the categories are taken from the `kili` key of the geojson feature properties.\n        children: the children of the annotation.\n            If not provided, the children are taken from the `kili` key of the geojson feature properties.\n        mid: the mid of the annotation.\n            If not provided, the mid is taken from the `id` key of the geojson feature.\n\n    Returns:\n        A Kili line annotation.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; line = {\n            'type': 'Feature',\n            'geometry': {\n                'type': 'LineString',\n                'coordinates': [[-79.0, -3.0], [-79.0, -3.0]]},\n            }\n            'id': 'mid_object',\n            'properties': {\n                'kili': {\n                    'categories': [{'name': 'A'}],\n                    'children': {},\n                    'job': 'job_name'\n                }\n            }\n        }\n        &gt;&gt;&gt; geojson_linestring_feature_to_kili_line_annotation(line)\n        {\n            'children': {},\n            'polyline': [{'x': -79.0, 'y': -3.0}, {'x': -79.0, 'y': -3.0}],\n            'categories': [{'name': 'A'}],\n            'mid': 'mid_object',\n            'type': 'polyline'\n        }\n        ```\n    \"\"\"\n    assert line[\"type\"] == \"Feature\", f\"Feature type must be `Feature`, got: {line['type']}\"\n    assert (\n        line[\"geometry\"][\"type\"] == \"LineString\"\n    ), f\"Geometry type must be `LineString`, got: {line['geometry']['type']}\"\n\n    children = children or line[\"properties\"].get(\"kili\", {}).get(\"children\", {})\n    categories = categories or line[\"properties\"][\"kili\"][\"categories\"]\n\n    ret = {\n        \"children\": children,\n        \"categories\": categories,\n        \"type\": \"polyline\",\n    }\n    ret[\"polyline\"] = [{\"x\": coord[0], \"y\": coord[1]} for coord in line[\"geometry\"][\"coordinates\"]]\n\n    if mid is not None:\n        ret[\"mid\"] = str(mid)\n    elif \"id\" in line:\n        ret[\"mid\"] = str(line[\"id\"])\n\n    return ret\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.line.kili_line_annotation_to_geojson_linestring_feature","title":"<code>kili_line_annotation_to_geojson_linestring_feature(polyline_annotation, job_name=None)</code>","text":"<p>Convert a Kili line annotation to a geojson linestring feature.</p> <p>Parameters:</p> Name Type Description Default <code>polyline_annotation</code> <code>Dict[str, Any]</code> <p>a Kili line annotation.</p> required <code>job_name</code> <code>Optional[str]</code> <p>the name of the job to which the annotation belongs.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A geojson linestring feature.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; polyline = {\n    'children': {},\n    'polyline': [{'x': -79.0, 'y': -3.0}, {'x': -79.0, 'y': -3.0}],\n    'categories': [{'name': 'A'}],\n    'mid': 'mid_object',\n    'type': 'polyline'\n}\n&gt;&gt;&gt; kili_line_annotation_to_geojson_linestring_feature(polyline, 'job_name')\n{\n    'type': 'Feature',\n    'geometry': {\n        'type': 'LineString',\n        'coordinates': [[-79.0, -3.0], [-79.0, -3.0]]},\n        'id': 'mid_object',\n        'properties': {\n            'kili': {\n                'categories': [{'name': 'A'}],\n                'children': {},\n                'job': 'job_name'\n            }\n        }\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/line.py</code> <pre><code>def kili_line_annotation_to_geojson_linestring_feature(\n    polyline_annotation: Dict[str, Any], job_name: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert a Kili line annotation to a geojson linestring feature.\n\n    Args:\n        polyline_annotation: a Kili line annotation.\n        job_name: the name of the job to which the annotation belongs.\n\n    Returns:\n        A geojson linestring feature.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; polyline = {\n            'children': {},\n            'polyline': [{'x': -79.0, 'y': -3.0}, {'x': -79.0, 'y': -3.0}],\n            'categories': [{'name': 'A'}],\n            'mid': 'mid_object',\n            'type': 'polyline'\n        }\n        &gt;&gt;&gt; kili_line_annotation_to_geojson_linestring_feature(polyline, 'job_name')\n        {\n            'type': 'Feature',\n            'geometry': {\n                'type': 'LineString',\n                'coordinates': [[-79.0, -3.0], [-79.0, -3.0]]},\n                'id': 'mid_object',\n                'properties': {\n                    'kili': {\n                        'categories': [{'name': 'A'}],\n                        'children': {},\n                        'job': 'job_name'\n                    }\n                }\n        }\n        ```\n    \"\"\"\n    assert (\n        polyline_annotation[\"type\"] == \"polyline\"\n    ), f\"Annotation type must be `polyline`, got: {polyline_annotation['type']}\"\n\n    ret = {\n        \"type\": \"Feature\",\n        \"geometry\": kili_line_to_geojson_linestring(polyline_annotation[\"polyline\"]),\n    }\n    if \"mid\" in polyline_annotation:\n        ret[\"id\"] = polyline_annotation[\"mid\"]\n    ret[\"properties\"] = {\n        \"kili\": {k: v for k, v in polyline_annotation.items() if k not in [\"mid\", \"polyline\"]}\n    }\n    if job_name is not None:\n        ret[\"properties\"][\"kili\"][\"job\"] = job_name\n    return ret\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.line.kili_line_to_geojson_linestring","title":"<code>kili_line_to_geojson_linestring(polyline)</code>","text":"<p>Convert a Kili line to a geojson linestring.</p> <p>Parameters:</p> Name Type Description Default <code>polyline</code> <code>List[Dict[str, float]]</code> <p>a Kili line (polyline).</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A geojson linestring.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; polyline = [{\"x\": 1.0, \"y\": 2.0}, {\"x\": 3.0, \"y\": 4.0}]\n&gt;&gt;&gt; kili_line_to_geojson_linestring(polyline)\n{\n    \"type\": \"LineString\",\n    \"coordinates\": [[1.0, 2.0], [3.0, 4.0]]\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/line.py</code> <pre><code>def kili_line_to_geojson_linestring(polyline: List[Dict[str, float]]) -&gt; Dict[str, Any]:\n    \"\"\"Convert a Kili line to a geojson linestring.\n\n    Args:\n        polyline: a Kili line (polyline).\n\n    Returns:\n        A geojson linestring.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; polyline = [{\"x\": 1.0, \"y\": 2.0}, {\"x\": 3.0, \"y\": 4.0}]\n        &gt;&gt;&gt; kili_line_to_geojson_linestring(polyline)\n        {\n            \"type\": \"LineString\",\n            \"coordinates\": [[1.0, 2.0], [3.0, 4.0]]\n        }\n        ```\n    \"\"\"\n    ret = {\"type\": \"LineString\", \"coordinates\": []}\n    ret[\"coordinates\"] = [[vertex[\"x\"], vertex[\"y\"]] for vertex in polyline]\n    return ret  # type: ignore\n</code></pre>"},{"location":"sdk/label_utils/#bounding-box","title":"Bounding box","text":"<p>Bounding box conversion functions between Kili and geojson formats.</p>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.bbox.geojson_polygon_feature_to_kili_bbox_annotation","title":"<code>geojson_polygon_feature_to_kili_bbox_annotation(polygon, categories=None, children=None, mid=None)</code>","text":"<p>Convert a geojson polygon feature to a Kili bounding box annotation.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>Dict[str, Any]</code> <p>a geojson polygon feature.</p> required <code>categories</code> <code>Optional[List[Dict]]</code> <p>the categories of the annotation. If not provided, the categories are taken from the <code>kili</code> key of the geojson feature properties.</p> <code>None</code> <code>children</code> <code>Optional[Dict]</code> <p>the children of the annotation. If not provided, the children are taken from the <code>kili</code> key of the geojson feature properties.</p> <code>None</code> <code>mid</code> <code>Optional[str]</code> <p>the mid of the annotation. If not provided, the mid is taken from the <code>id</code> key of the geojson feature.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A Kili bounding box annotation.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; polygon = {\n    'type': 'Feature',\n    'geometry': {\n        'type': 'Polygon',\n        'coordinates': [\n            [\n                [-12.6, 12.87],\n                [-42.6, 22.17],\n                [-17.6, -22.4],\n                [2.6, -1.87],\n                [-12.6, 12.87]\n            ]\n        ]\n    },\n    'id': 'mid_object',\n    'properties': {\n        'kili': {\n            'categories': [{'name': 'A'}],\n            'children': {},\n            'type': 'rectangle',\n            'job': 'job_name'\n        }\n    }\n}\n&gt;&gt;&gt; geojson_polygon_feature_to_kili_bbox_annotation(polygon)\n{\n    'children': {},\n    'boundingPoly': [\n            {\n                'normalizedVertices': [\n                    {'x': -12.6, 'y': 12.87},\n                    {'x': -42.6, 'y': 22.17},\n                    {'x': -17.6, 'y': -22.4},\n                    {'x': 2.6, 'y': -1.87}\n                ]\n            }\n        ],\n    'categories': [{'name': 'A'}],\n    'mid': 'mid_object',\n    'type': 'rectangle'\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/bbox.py</code> <pre><code>def geojson_polygon_feature_to_kili_bbox_annotation(\n    polygon: Dict[str, Any],\n    categories: Optional[List[Dict]] = None,\n    children: Optional[Dict] = None,\n    mid: Optional[str] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert a geojson polygon feature to a Kili bounding box annotation.\n\n    Args:\n        polygon: a geojson polygon feature.\n        categories: the categories of the annotation.\n            If not provided, the categories are taken from the `kili` key of the geojson feature properties.\n        children: the children of the annotation.\n            If not provided, the children are taken from the `kili` key of the geojson feature properties.\n        mid: the mid of the annotation.\n            If not provided, the mid is taken from the `id` key of the geojson feature.\n\n    Returns:\n        A Kili bounding box annotation.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; polygon = {\n            'type': 'Feature',\n            'geometry': {\n                'type': 'Polygon',\n                'coordinates': [\n                    [\n                        [-12.6, 12.87],\n                        [-42.6, 22.17],\n                        [-17.6, -22.4],\n                        [2.6, -1.87],\n                        [-12.6, 12.87]\n                    ]\n                ]\n            },\n            'id': 'mid_object',\n            'properties': {\n                'kili': {\n                    'categories': [{'name': 'A'}],\n                    'children': {},\n                    'type': 'rectangle',\n                    'job': 'job_name'\n                }\n            }\n        }\n        &gt;&gt;&gt; geojson_polygon_feature_to_kili_bbox_annotation(polygon)\n        {\n            'children': {},\n            'boundingPoly': [\n                    {\n                        'normalizedVertices': [\n                            {'x': -12.6, 'y': 12.87},\n                            {'x': -42.6, 'y': 22.17},\n                            {'x': -17.6, 'y': -22.4},\n                            {'x': 2.6, 'y': -1.87}\n                        ]\n                    }\n                ],\n            'categories': [{'name': 'A'}],\n            'mid': 'mid_object',\n            'type': 'rectangle'\n        }\n        ```\n    \"\"\"\n    assert (\n        polygon.get(\"type\") == \"Feature\"\n    ), f\"Feature type must be `Feature`, got: {polygon['type']}\"\n    assert (\n        polygon[\"geometry\"][\"type\"] == \"Polygon\"\n    ), f\"Geometry type must be `Polygon`, got: {polygon['geometry']['type']}\"\n\n    children = children or polygon[\"properties\"].get(\"kili\", {}).get(\"children\", {})\n    categories = categories or polygon[\"properties\"][\"kili\"][\"categories\"]\n\n    ret = {\n        \"children\": children,\n        \"categories\": categories,\n        \"type\": \"rectangle\",\n    }\n    # geojson polygon has one more point than kili bounding box\n    coords = polygon[\"geometry\"][\"coordinates\"][0]\n    normalized_vertices = [\n        {\"x\": coords[0][0], \"y\": coords[0][1]},\n        {\"x\": coords[3][0], \"y\": coords[3][1]},\n        {\"x\": coords[2][0], \"y\": coords[2][1]},\n        {\"x\": coords[1][0], \"y\": coords[1][1]},\n    ]\n    ret[\"boundingPoly\"] = [{\"normalizedVertices\": normalized_vertices}]\n\n    if mid is not None:\n        ret[\"mid\"] = mid\n    elif \"id\" in polygon:\n        ret[\"mid\"] = polygon[\"id\"]\n\n    return ret\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.bbox.kili_bbox_annotation_to_geojson_polygon_feature","title":"<code>kili_bbox_annotation_to_geojson_polygon_feature(bbox_annotation, job_name=None)</code>","text":"<p>Convert a Kili bounding box annotation to a geojson polygon feature.</p> <p>Parameters:</p> Name Type Description Default <code>bbox_annotation</code> <code>Dict[str, Any]</code> <p>a Kili bounding box annotation.</p> required <code>job_name</code> <code>Optional[str]</code> <p>the name of the job to which the annotation belongs.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A geojson polygon feature.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; bbox = {\n    'children': {},\n    'boundingPoly': [\n            {\n                'normalizedVertices': [\n                    {'x': -12.6, 'y': 12.87},\n                    {'x': -42.6, 'y': 22.17},\n                    {'x': -17.6, 'y': -22.4},\n                    {'x': 2.6, 'y': -1.87}\n                ]\n            }\n        ],\n    'categories': [{'name': 'A'}],\n    'mid': 'mid_object',\n    'type': 'rectangle'\n}\n&gt;&gt;&gt; kili_bbox_annotation_to_geojson_polygon_feature(bbox, 'job_name')\n{\n    'type': 'Feature',\n    'geometry': {\n        'type': 'Polygon',\n        'coordinates': [\n            [\n                [-12.6, 12.87],\n                [-42.6, 22.17],\n                [-17.6, -22.4],\n                [2.6, -1.87],\n                [-12.6, 12.87]\n            ]\n        ]\n    },\n    'id': 'mid_object',\n    'properties': {\n        'kili': {\n            'categories': [{'name': 'A'}],\n            'children': {},\n            'type': 'rectangle',\n            'job': 'job_name'\n        }\n    }\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/bbox.py</code> <pre><code>def kili_bbox_annotation_to_geojson_polygon_feature(\n    bbox_annotation: Dict[str, Any], job_name: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert a Kili bounding box annotation to a geojson polygon feature.\n\n    Args:\n        bbox_annotation: a Kili bounding box annotation.\n        job_name: the name of the job to which the annotation belongs.\n\n    Returns:\n        A geojson polygon feature.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; bbox = {\n            'children': {},\n            'boundingPoly': [\n                    {\n                        'normalizedVertices': [\n                            {'x': -12.6, 'y': 12.87},\n                            {'x': -42.6, 'y': 22.17},\n                            {'x': -17.6, 'y': -22.4},\n                            {'x': 2.6, 'y': -1.87}\n                        ]\n                    }\n                ],\n            'categories': [{'name': 'A'}],\n            'mid': 'mid_object',\n            'type': 'rectangle'\n        }\n        &gt;&gt;&gt; kili_bbox_annotation_to_geojson_polygon_feature(bbox, 'job_name')\n        {\n            'type': 'Feature',\n            'geometry': {\n                'type': 'Polygon',\n                'coordinates': [\n                    [\n                        [-12.6, 12.87],\n                        [-42.6, 22.17],\n                        [-17.6, -22.4],\n                        [2.6, -1.87],\n                        [-12.6, 12.87]\n                    ]\n                ]\n            },\n            'id': 'mid_object',\n            'properties': {\n                'kili': {\n                    'categories': [{'name': 'A'}],\n                    'children': {},\n                    'type': 'rectangle',\n                    'job': 'job_name'\n                }\n            }\n        }\n        ```\n    \"\"\"\n    bbox = bbox_annotation\n    assert bbox[\"type\"] == \"rectangle\", f\"Annotation type must be `rectangle`, got: {bbox['type']}\"\n\n    ret = {\n        \"type\": \"Feature\",\n        \"geometry\": kili_bbox_to_geojson_polygon(bbox[\"boundingPoly\"][0][\"normalizedVertices\"]),\n    }\n    if \"mid\" in bbox:\n        ret[\"id\"] = bbox[\"mid\"]\n    ret[\"properties\"] = {\n        \"kili\": {k: v for k, v in bbox.items() if k not in [\"boundingPoly\", \"mid\"]}\n    }\n    if job_name is not None:\n        ret[\"properties\"][\"kili\"][\"job\"] = job_name\n    return ret\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.bbox.kili_bbox_to_geojson_polygon","title":"<code>kili_bbox_to_geojson_polygon(vertices)</code>","text":"<p>Convert a Kili bounding box to a geojson polygon.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>List[Dict[str, float]]</code> <p>Kili bounding polygon vertices.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A geojson polygon.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; vertices = [\n    {'x': 12.0, 'y': 3.0},\n    {'x': 12.0, 'y': 4.0},\n    {'x': 13.0, 'y': 4.0},\n    {'x': 13.0, 'y': 3.0}\n]\n&gt;&gt;&gt; kili_bbox_to_geojson_polygon(vertices)\n{\n    'type': 'Polygon',\n    'coordinates': [\n        [\n            [12.0, 3.0],\n            [12.0, 4.0],\n            [13.0, 4.0],\n            [13.0, 3.0],\n            [12.0, 3.0]\n        ]\n    ]\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/bbox.py</code> <pre><code>def kili_bbox_to_geojson_polygon(vertices: List[Dict[str, float]]) -&gt; Dict[str, Any]:\n    \"\"\"Convert a Kili bounding box to a geojson polygon.\n\n    Args:\n        vertices: Kili bounding polygon vertices.\n\n    Returns:\n        A geojson polygon.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; vertices = [\n            {'x': 12.0, 'y': 3.0},\n            {'x': 12.0, 'y': 4.0},\n            {'x': 13.0, 'y': 4.0},\n            {'x': 13.0, 'y': 3.0}\n        ]\n        &gt;&gt;&gt; kili_bbox_to_geojson_polygon(vertices)\n        {\n            'type': 'Polygon',\n            'coordinates': [\n                [\n                    [12.0, 3.0],\n                    [12.0, 4.0],\n                    [13.0, 4.0],\n                    [13.0, 3.0],\n                    [12.0, 3.0]\n                ]\n            ]\n        }\n        ```\n    \"\"\"\n    vertex_name_to_value = {}\n    for vertex, point_name in zip(\n        vertices, (\"bottom_left\", \"top_left\", \"top_right\", \"bottom_right\")\n    ):\n        vertex_name_to_value[point_name] = vertex\n\n    ret = {\"type\": \"Polygon\", \"coordinates\": []}\n    ret[\"coordinates\"] = [\n        [\n            [vertex_name_to_value[\"bottom_left\"][\"x\"], vertex_name_to_value[\"bottom_left\"][\"y\"]],\n            [vertex_name_to_value[\"bottom_right\"][\"x\"], vertex_name_to_value[\"bottom_right\"][\"y\"]],\n            [vertex_name_to_value[\"top_right\"][\"x\"], vertex_name_to_value[\"top_right\"][\"y\"]],\n            [vertex_name_to_value[\"top_left\"][\"x\"], vertex_name_to_value[\"top_left\"][\"y\"]],\n            [vertex_name_to_value[\"bottom_left\"][\"x\"], vertex_name_to_value[\"bottom_left\"][\"y\"]],\n        ]\n    ]\n\n    return ret\n</code></pre>"},{"location":"sdk/label_utils/#polygon","title":"Polygon","text":"<p>Polygon label utils.</p>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.polygon.geojson_polygon_feature_to_kili_polygon_annotation","title":"<code>geojson_polygon_feature_to_kili_polygon_annotation(polygon, categories=None, children=None, mid=None)</code>","text":"<p>Convert a geojson polygon feature to a Kili polygon annotation.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>Dict[str, Any]</code> <p>a geojson polygon feature.</p> required <code>categories</code> <code>Optional[List[Dict]]</code> <p>the categories of the annotation. If not provided, the categories are taken from the <code>kili</code> key of the geojson feature properties.</p> <code>None</code> <code>children</code> <code>Optional[Dict]</code> <p>the children of the annotation. If not provided, the children are taken from the <code>kili</code> key of the geojson feature properties.</p> <code>None</code> <code>mid</code> <code>Optional[str]</code> <p>the mid of the annotation. If not provided, the mid is taken from the <code>id</code> key of the geojson feature.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A Kili polygon annotation.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; polygon = {\n    'type': 'Feature',\n    'geometry': {\n        'type': 'Polygon',\n        'coordinates': [[[-79.0, -3.0], [-79.0, -3.0]]]},\n    },\n    'id': 'mid_object',\n    'properties': {\n        'kili': {\n            'categories': [{'name': 'A'}],\n            'children': {},\n            'type': 'polygon',\n            'job': 'job_name'\n        }\n    }\n}\n&gt;&gt;&gt; geojson_polygon_feature_to_kili_polygon_annotation(polygon)\n{\n    'children': {},\n    'boundingPoly': [{'normalizedVertices': [{'x': -79.0, 'y': -3.0}]}],\n    'categories': [{'name': 'A'}],\n    'mid': 'mid_object',\n    'type': 'polygon'\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/polygon.py</code> <pre><code>def geojson_polygon_feature_to_kili_polygon_annotation(\n    polygon: Dict[str, Any],\n    categories: Optional[List[Dict]] = None,\n    children: Optional[Dict] = None,\n    mid: Optional[str] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert a geojson polygon feature to a Kili polygon annotation.\n\n    Args:\n        polygon: a geojson polygon feature.\n        categories: the categories of the annotation.\n            If not provided, the categories are taken from the `kili` key of the geojson feature properties.\n        children: the children of the annotation.\n            If not provided, the children are taken from the `kili` key of the geojson feature properties.\n        mid: the mid of the annotation.\n            If not provided, the mid is taken from the `id` key of the geojson feature.\n\n\n    Returns:\n        A Kili polygon annotation.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; polygon = {\n            'type': 'Feature',\n            'geometry': {\n                'type': 'Polygon',\n                'coordinates': [[[-79.0, -3.0], [-79.0, -3.0]]]},\n            },\n            'id': 'mid_object',\n            'properties': {\n                'kili': {\n                    'categories': [{'name': 'A'}],\n                    'children': {},\n                    'type': 'polygon',\n                    'job': 'job_name'\n                }\n            }\n        }\n        &gt;&gt;&gt; geojson_polygon_feature_to_kili_polygon_annotation(polygon)\n        {\n            'children': {},\n            'boundingPoly': [{'normalizedVertices': [{'x': -79.0, 'y': -3.0}]}],\n            'categories': [{'name': 'A'}],\n            'mid': 'mid_object',\n            'type': 'polygon'\n        }\n        ```\n    \"\"\"\n    assert (\n        polygon.get(\"type\") == \"Feature\"\n    ), f\"Feature type must be `Feature`, got: {polygon['type']}\"\n    assert (\n        polygon[\"geometry\"][\"type\"] == \"Polygon\"\n    ), f\"Geometry type must be `Polygon`, got: {polygon['geometry']['type']}\"\n\n    children = children or polygon[\"properties\"].get(\"kili\", {}).get(\"children\", {})\n    categories = categories or polygon[\"properties\"][\"kili\"][\"categories\"]\n\n    ret = {\n        \"children\": children,\n        \"categories\": categories,\n        \"type\": \"polygon\",\n    }\n    coords = polygon[\"geometry\"][\"coordinates\"][0]\n    normalized_vertices = [{\"x\": coord[0], \"y\": coord[1]} for coord in coords[:-1]]\n    ret[\"boundingPoly\"] = [{\"normalizedVertices\": normalized_vertices}]\n\n    if mid is not None:\n        ret[\"mid\"] = str(mid)\n    elif \"id\" in polygon:\n        ret[\"mid\"] = str(polygon[\"id\"])\n\n    return ret\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.polygon.get_oriented_area","title":"<code>get_oriented_area(vertices)</code>","text":"<p>Returns the area value which gives an indication on the vertices order. Positive if counter-clockwise, negative if clockwise.</p> <p>This function uses the Shoelace formula : see also : https://en.wikipedia.org/wiki/Shoelace_formula</p> Source code in <code>kili_formats/format/geojson/polygon.py</code> <pre><code>def get_oriented_area(vertices):\n    \"\"\"Returns the area value which gives an indication on the vertices order.\n    Positive if counter-clockwise, negative if clockwise.\n\n    This function uses the Shoelace formula :\n    see also : https://en.wikipedia.org/wiki/Shoelace_formula\n    \"\"\"\n    n = len(vertices)\n    sum_product = 0\n\n    for i in range(n):\n        x1, y1 = vertices[i][\"x\"], vertices[i][\"y\"]\n        x2, y2 = vertices[(i + 1) % n][\"x\"], vertices[(i + 1) % n][\"y\"]\n        sum_product += (x1 - x2) * (y2 + y1)\n\n    return sum_product\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.polygon.kili_polygon_annotation_to_geojson_polygon_feature","title":"<code>kili_polygon_annotation_to_geojson_polygon_feature(polygon_annotation, job_name=None)</code>","text":"<p>Convert a Kili polygon annotation to a geojson polygon feature.</p> <p>Parameters:</p> Name Type Description Default <code>polygon_annotation</code> <code>Dict[str, Any]</code> <p>a Kili polygon annotation.</p> required <code>job_name</code> <code>Optional[str]</code> <p>the name of the job to which the annotation belongs.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A geojson polygon feature.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; polygon = {\n    'children': {},\n    'boundingPoly': [{'normalizedVertices': [{'x': -79.0, 'y': -3.0}]}],\n    'categories': [{'name': 'A'}],\n    'mid': 'mid_object',\n    'type': 'polygon'\n}\n&gt;&gt;&gt; kili_polygon_annotation_to_geojson_polygon_feature(polygon, 'job_name')\n{\n    'type': 'Feature',\n    'geometry': {\n        'type': 'Polygon',\n        'coordinates': [[[-79.0, -3.0], [-79.0, -3.0]]]},\n        'id': 'mid_object',\n        'properties': {\n            'kili': {\n                'categories': [{'name': 'A'}],\n                'children': {},\n                'type': 'polygon',\n                'job': 'job_name'\n            }\n        }\n    }\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/polygon.py</code> <pre><code>def kili_polygon_annotation_to_geojson_polygon_feature(\n    polygon_annotation: Dict[str, Any], job_name: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert a Kili polygon annotation to a geojson polygon feature.\n\n    Args:\n        polygon_annotation: a Kili polygon annotation.\n        job_name: the name of the job to which the annotation belongs.\n\n    Returns:\n        A geojson polygon feature.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; polygon = {\n            'children': {},\n            'boundingPoly': [{'normalizedVertices': [{'x': -79.0, 'y': -3.0}]}],\n            'categories': [{'name': 'A'}],\n            'mid': 'mid_object',\n            'type': 'polygon'\n        }\n        &gt;&gt;&gt; kili_polygon_annotation_to_geojson_polygon_feature(polygon, 'job_name')\n        {\n            'type': 'Feature',\n            'geometry': {\n                'type': 'Polygon',\n                'coordinates': [[[-79.0, -3.0], [-79.0, -3.0]]]},\n                'id': 'mid_object',\n                'properties': {\n                    'kili': {\n                        'categories': [{'name': 'A'}],\n                        'children': {},\n                        'type': 'polygon',\n                        'job': 'job_name'\n                    }\n                }\n            }\n        }\n        ```\n    \"\"\"\n    polygon = polygon_annotation\n    assert (\n        polygon[\"type\"] == \"polygon\"\n    ), f\"Annotation type must be `polygon`, got: {polygon['type']}\"\n\n    ret = {\n        \"type\": \"Feature\",\n        \"geometry\": kili_polygon_to_geojson_polygon(\n            polygon[\"boundingPoly\"][0][\"normalizedVertices\"]\n        ),\n    }\n    if \"mid\" in polygon:\n        ret[\"id\"] = polygon[\"mid\"]\n    ret[\"properties\"] = {\n        \"kili\": {k: v for k, v in polygon.items() if k not in [\"boundingPoly\", \"mid\"]}\n    }\n    if job_name is not None:\n        ret[\"properties\"][\"kili\"][\"job\"] = job_name\n    return ret\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.polygon.kili_polygon_to_geojson_polygon","title":"<code>kili_polygon_to_geojson_polygon(vertices)</code>","text":"<p>Convert a Kili polygon to a geojson polygon.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>List[Dict[str, float]]</code> <p>Kili polygon vertices.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A geojson polygon.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; vertices = [\n    {'x': 10.42, 'y': 27.12},\n    {'x': 1.53, 'y': 14.57},\n    {'x': 147.45, 'y': 14.12},\n    {'x': 14.23, 'y': 0.23}\n]\n&gt;&gt;&gt; kili_polygon_to_geojson_polygon(vertices)\n{\n    'type': 'Polygon',\n    'coordinates': [\n        [\n            [10.42, 27.12],\n            [1.53, 14.57],\n            [147.45, 14.12],\n            [14.23, 0.23],\n            [10.42, 27.12]\n        ]\n    ]\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/polygon.py</code> <pre><code>def kili_polygon_to_geojson_polygon(vertices: List[Dict[str, float]]) -&gt; Dict[str, Any]:\n    \"\"\"Convert a Kili polygon to a geojson polygon.\n\n    Args:\n        vertices: Kili polygon vertices.\n\n    Returns:\n        A geojson polygon.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; vertices = [\n            {'x': 10.42, 'y': 27.12},\n            {'x': 1.53, 'y': 14.57},\n            {'x': 147.45, 'y': 14.12},\n            {'x': 14.23, 'y': 0.23}\n        ]\n        &gt;&gt;&gt; kili_polygon_to_geojson_polygon(vertices)\n        {\n            'type': 'Polygon',\n            'coordinates': [\n                [\n                    [10.42, 27.12],\n                    [1.53, 14.57],\n                    [147.45, 14.12],\n                    [14.23, 0.23],\n                    [10.42, 27.12]\n                ]\n            ]\n        }\n        ```\n    \"\"\"\n    reordered_polygon_vertices = order_counter_clockwise(vertices)\n    polygon = [[vertex[\"x\"], vertex[\"y\"]] for vertex in reordered_polygon_vertices]\n\n    polygon.append(polygon[0])  # the first and last positions must be the same\n    return {\"type\": \"Polygon\", \"coordinates\": [polygon]}\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.polygon.order_counter_clockwise","title":"<code>order_counter_clockwise(vertices)</code>","text":"<p>Returns the vertices, in the correct order :</p> <p>If the vertices are set clockwise, we reverse them to have them in the anti-clockwise order. For more information on the order expected for GeoJson : https://datatracker.ietf.org/doc/html/rfc7946#section-3.1.6</p> Source code in <code>kili_formats/format/geojson/polygon.py</code> <pre><code>def order_counter_clockwise(vertices):\n    \"\"\"Returns the vertices, in the correct order :\n\n    If the vertices are set clockwise, we reverse them to have them in the anti-clockwise order.\n    For more information on the order expected for GeoJson :\n    https://datatracker.ietf.org/doc/html/rfc7946#section-3.1.6\n    \"\"\"\n    order = get_oriented_area(vertices)\n    if order &lt; 0:\n        vertices.reverse()\n    elif order == 0:\n        raise ConversionError(\n            f\"Polygon order could not be identified as clockwise nor counter-clockwise because of \\\n                edges intersection in {vertices} and thus cannot be exported to GeoJson format.\"\n        )\n\n    return vertices\n</code></pre>"},{"location":"sdk/label_utils/#segmentation","title":"Segmentation","text":"<p>Geojson segmentation utilities.</p>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.segmentation._is_hierarchical_format","title":"<code>_is_hierarchical_format(bounding_poly)</code>  <code>private</code>","text":"<p>Check if boundingPoly is in hierarchical format.</p> <p>Hierarchical: [ [ {normalizedVertices: [...]}, ... ], ... ] Flat: [ {normalizedVertices: [...]}, ... ]</p> Source code in <code>kili_formats/format/geojson/segmentation.py</code> <pre><code>def _is_hierarchical_format(bounding_poly):\n    \"\"\"Check if boundingPoly is in hierarchical format.\n\n    Hierarchical: [ [ {normalizedVertices: [...]}, ... ], ... ]\n    Flat: [ {normalizedVertices: [...]}, ... ]\n    \"\"\"\n    if not bounding_poly or len(bounding_poly) == 0:\n        return False\n\n    first_element = bounding_poly[0]\n\n    if isinstance(first_element, list):\n        return True\n\n    if isinstance(first_element, dict) and \"normalizedVertices\" in first_element:\n        return False\n\n    return False\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.segmentation.geojson_polygon_feature_to_kili_segmentation_annotation","title":"<code>geojson_polygon_feature_to_kili_segmentation_annotation(polygon, categories=None, children=None, mid=None)</code>","text":"<p>Convert a geojson polygon feature to a list of Kili segmentation annotations.</p> <p>For Polygon: returns a single annotation. For MultiPolygon: returns N annotations (one per polygon part) with the same mid.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>Dict[str, Any]</code> <p>A geojson polygon feature.</p> required <code>categories</code> <code>Optional[List[Dict]]</code> <p>The categories of the annotation. If not provided, the categories are taken from the <code>kili</code> key of the geojson feature properties.</p> <code>None</code> <code>children</code> <code>Optional[Dict]</code> <p>The children of the annotation. If not provided, the children are taken from the <code>kili</code> key of the geojson feature properties.</p> <code>None</code> <code>mid</code> <code>Optional[str]</code> <p>The mid of the annotation. If not provided, the mid is taken from the <code>id</code> key of the geojson feature. If no id is available, a new UUID is generated.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>A list of Kili segmentation annotations. Each annotation has a flat boundingPoly structure.</p> <p>Example</p> <pre><code># Polygon feature -&gt; single annotation\n&gt;&gt;&gt; polygon = {\n...     'type': 'Feature',\n...     'geometry': {\n...         'type': 'Polygon',\n...         'coordinates': [\n...             [[0, 0], [1, 0], [1, 1], [0, 0]],  # exterior\n...             [[0.2, 0.2], [0.8, 0.2], [0.8, 0.8], [0.2, 0.2]]  # hole\n...         ]\n...     },\n...     'id': 'building_001',\n...     'properties': {\n...         'kili': {\n...             'categories': [{'name': 'building'}],\n...             'children': {},\n...             'type': 'semantic'\n...         }\n...     }\n... }\n&gt;&gt;&gt; geojson_polygon_feature_to_kili_segmentation_annotation(polygon)\n[\n    {\n        'children': {},\n        'boundingPoly': [\n            {'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]},\n            {'normalizedVertices': [{'x': 0.2, 'y': 0.2}, {'x': 0.8, 'y': 0.2}, {'x': 0.8, 'y': 0.8}]}\n        ],\n        'categories': [{'name': 'building'}],\n        'mid': 'building_001',\n        'type': 'semantic'\n    }\n]\n\n# MultiPolygon feature -&gt; multiple annotations with same mid\n&gt;&gt;&gt; multipolygon = {\n...     'type': 'Feature',\n...     'geometry': {\n...         'type': 'MultiPolygon',\n...         'coordinates': [\n...             [[[0, 0], [1, 0], [1, 1], [0, 0]]],  # First polygon\n...             [[[2, 2], [3, 2], [3, 3], [2, 2]]]   # Second polygon\n...         ]\n...     },\n...     'id': 'forest_001',\n...     'properties': {\n...         'kili': {\n...             'categories': [{'name': 'forest'}],\n...             'children': {},\n...             'type': 'semantic'\n...         }\n...     }\n... }\n&gt;&gt;&gt; geojson_polygon_feature_to_kili_segmentation_annotation(multipolygon)\n[\n    {\n        'children': {},\n        'boundingPoly': [\n            {'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]}\n        ],\n        'categories': [{'name': 'forest'}],\n        'mid': 'forest_001',\n        'type': 'semantic'\n    },\n    {\n        'children': {},\n        'boundingPoly': [\n            {'normalizedVertices': [{'x': 2, 'y': 2}, {'x': 3, 'y': 2}, {'x': 3, 'y': 3}]}\n        ],\n        'categories': [{'name': 'forest'}],\n        'mid': 'forest_001',\n        'type': 'semantic'\n    }\n]\n</code></pre> Source code in <code>kili_formats/format/geojson/segmentation.py</code> <pre><code>def geojson_polygon_feature_to_kili_segmentation_annotation(\n    polygon: Dict[str, Any],\n    categories: Optional[List[Dict]] = None,\n    children: Optional[Dict] = None,\n    mid: Optional[str] = None,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Convert a geojson polygon feature to a list of Kili segmentation annotations.\n\n    For Polygon: returns a single annotation.\n    For MultiPolygon: returns N annotations (one per polygon part) with the same mid.\n\n    Args:\n        polygon: A geojson polygon feature.\n        categories: The categories of the annotation.\n            If not provided, the categories are taken from the `kili` key of the geojson feature properties.\n        children: The children of the annotation.\n            If not provided, the children are taken from the `kili` key of the geojson feature properties.\n        mid: The mid of the annotation.\n            If not provided, the mid is taken from the `id` key of the geojson feature.\n            If no id is available, a new UUID is generated.\n\n    Returns:\n        A list of Kili segmentation annotations. Each annotation has a flat boundingPoly structure.\n\n    !!! Example\n        ```python\n        # Polygon feature -&gt; single annotation\n        &gt;&gt;&gt; polygon = {\n        ...     'type': 'Feature',\n        ...     'geometry': {\n        ...         'type': 'Polygon',\n        ...         'coordinates': [\n        ...             [[0, 0], [1, 0], [1, 1], [0, 0]],  # exterior\n        ...             [[0.2, 0.2], [0.8, 0.2], [0.8, 0.8], [0.2, 0.2]]  # hole\n        ...         ]\n        ...     },\n        ...     'id': 'building_001',\n        ...     'properties': {\n        ...         'kili': {\n        ...             'categories': [{'name': 'building'}],\n        ...             'children': {},\n        ...             'type': 'semantic'\n        ...         }\n        ...     }\n        ... }\n        &gt;&gt;&gt; geojson_polygon_feature_to_kili_segmentation_annotation(polygon)\n        [\n            {\n                'children': {},\n                'boundingPoly': [\n                    {'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]},\n                    {'normalizedVertices': [{'x': 0.2, 'y': 0.2}, {'x': 0.8, 'y': 0.2}, {'x': 0.8, 'y': 0.8}]}\n                ],\n                'categories': [{'name': 'building'}],\n                'mid': 'building_001',\n                'type': 'semantic'\n            }\n        ]\n\n        # MultiPolygon feature -&gt; multiple annotations with same mid\n        &gt;&gt;&gt; multipolygon = {\n        ...     'type': 'Feature',\n        ...     'geometry': {\n        ...         'type': 'MultiPolygon',\n        ...         'coordinates': [\n        ...             [[[0, 0], [1, 0], [1, 1], [0, 0]]],  # First polygon\n        ...             [[[2, 2], [3, 2], [3, 3], [2, 2]]]   # Second polygon\n        ...         ]\n        ...     },\n        ...     'id': 'forest_001',\n        ...     'properties': {\n        ...         'kili': {\n        ...             'categories': [{'name': 'forest'}],\n        ...             'children': {},\n        ...             'type': 'semantic'\n        ...         }\n        ...     }\n        ... }\n        &gt;&gt;&gt; geojson_polygon_feature_to_kili_segmentation_annotation(multipolygon)\n        [\n            {\n                'children': {},\n                'boundingPoly': [\n                    {'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]}\n                ],\n                'categories': [{'name': 'forest'}],\n                'mid': 'forest_001',\n                'type': 'semantic'\n            },\n            {\n                'children': {},\n                'boundingPoly': [\n                    {'normalizedVertices': [{'x': 2, 'y': 2}, {'x': 3, 'y': 2}, {'x': 3, 'y': 3}]}\n                ],\n                'categories': [{'name': 'forest'}],\n                'mid': 'forest_001',\n                'type': 'semantic'\n            }\n        ]\n        ```\n    \"\"\"\n    assert (\n        polygon.get(\"type\") == \"Feature\"\n    ), f\"Feature type must be `Feature`, got: {polygon['type']}\"\n\n    geometry_type = polygon[\"geometry\"][\"type\"]\n    assert geometry_type in [\n        \"Polygon\",\n        \"MultiPolygon\",\n    ], f\"Geometry type must be `Polygon` or `MultiPolygon`, got: {geometry_type}\"\n\n    children = children or polygon[\"properties\"].get(\"kili\", {}).get(\"children\", {})\n    categories = categories or polygon[\"properties\"][\"kili\"][\"categories\"]\n\n    annotation_mid = None\n    if mid is not None:\n        annotation_mid = str(mid)\n    elif \"id\" in polygon:\n        annotation_mid = str(polygon[\"id\"])\n    else:\n        annotation_mid = str(uuid.uuid4())\n\n    coords = polygon[\"geometry\"][\"coordinates\"]\n    annotations = []\n\n    if geometry_type == \"Polygon\":\n        # Single polygon: create one annotation\n        ret = {\n            \"children\": children,\n            \"categories\": categories,\n            \"type\": \"semantic\",\n            \"boundingPoly\": [\n                {\"normalizedVertices\": [{\"x\": coord[0], \"y\": coord[1]} for coord in ring[:-1]]}\n                for ring in coords\n            ],\n            \"mid\": annotation_mid,\n        }\n\n        annotations.append(ret)\n\n    else:\n        # MultiPolygon: create N annotations with same mid, one per polygon part\n        for polygon_coords in coords:\n            ret = {\n                \"children\": children,\n                \"categories\": categories,\n                \"type\": \"semantic\",\n                \"boundingPoly\": [\n                    {\"normalizedVertices\": [{\"x\": coord[0], \"y\": coord[1]} for coord in ring[:-1]]}\n                    for ring in polygon_coords\n                ],\n                \"mid\": annotation_mid,\n            }\n\n            annotations.append(ret)\n\n    return annotations\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.segmentation.kili_segmentation_annotation_to_geojson_polygon_feature","title":"<code>kili_segmentation_annotation_to_geojson_polygon_feature(segmentation_annotation, job_name=None)</code>","text":"<p>Convert a Kili segmentation annotation to a geojson polygon feature.</p> <p>Parameters:</p> Name Type Description Default <code>segmentation_annotation</code> <code>Dict[str, Any]</code> <p>A Kili segmentation annotation.</p> required <code>job_name</code> <code>Optional[str]</code> <p>The name of the job to which the annotation belongs.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A geojson polygon feature (can be Polygon or MultiPolygon).</p> <p>Example</p> <pre><code># Simple polygon annotation\n&gt;&gt;&gt; segmentation = {\n...     'children': {},\n...     'boundingPoly': [\n...         [  # Single polygon group\n...             {'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]},\n...             {'normalizedVertices': [{'x': 0.2, 'y': 0.2}, {'x': 0.8, 'y': 0.2}, {'x': 0.8, 'y': 0.8}]}\n...         ]\n...     ],\n...     'categories': [{'name': 'building'}],\n...     'mid': 'building_001',\n...     'type': 'semantic'\n... }\n&gt;&gt;&gt; kili_segmentation_annotation_to_geojson_polygon_feature(segmentation, 'detection_job')\n{\n    'type': 'Feature',\n    'geometry': {\n        'type': 'Polygon',\n        'coordinates': [\n            [[0, 0], [1, 0], [1, 1], [0, 0]],\n            [[0.2, 0.2], [0.8, 0.2], [0.8, 0.8], [0.2, 0.2]]\n        ]\n    },\n    'id': 'building_001',\n    'properties': {\n        'kili': {\n            'categories': [{'name': 'building'}],\n            'children': {},\n            'type': 'semantic',\n            'job': 'detection_job'\n        }\n    }\n}\n\n# MultiPolygon annotation\n&gt;&gt;&gt; segmentation = {\n...     'children': {},\n...     'boundingPoly': [\n...         [{'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]}],  # First polygon\n...         [{'normalizedVertices': [{'x': 2, 'y': 2}, {'x': 3, 'y': 2}, {'x': 3, 'y': 3}]}]   # Second polygon\n...     ],\n...     'categories': [{'name': 'forest'}],\n...     'mid': 'forest_001',\n...     'type': 'semantic'\n... }\n&gt;&gt;&gt; kili_segmentation_annotation_to_geojson_polygon_feature(segmentation, 'detection_job')\n{\n    'type': 'Feature',\n    'geometry': {\n        'type': 'MultiPolygon',\n        'coordinates': [\n            [[[0, 0], [1, 0], [1, 1], [0, 0]]],\n            [[[2, 2], [3, 2], [3, 3], [2, 2]]]\n        ]\n    },\n    'id': 'forest_001',\n    'properties': {\n        'kili': {\n            'categories': [{'name': 'forest'}],\n            'children': {},\n            'type': 'semantic',\n            'job': 'detection_job'\n        }\n    }\n}\n\n# Flat format annotation\n&gt;&gt;&gt; segmentation = {\n...     'children': {},\n...     'boundingPoly': [\n...         {'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]}\n...     ],\n...     'categories': [{'name': 'object'}],\n...     'mid': 'object_001',\n...     'type': 'semantic'\n... }\n&gt;&gt;&gt; kili_segmentation_annotation_to_geojson_polygon_feature(segmentation, 'detection_job')\n{\n    'type': 'Feature',\n    'geometry': {\n        'type': 'Polygon',\n        'coordinates': [\n            [[0, 0], [1, 0], [1, 1], [0, 0]]\n        ]\n    },\n    'id': 'object_001',\n    'properties': {\n        'kili': {\n            'categories': [{'name': 'object'}],\n            'children': {},\n            'type': 'semantic',\n            'job': 'detection_job'\n        }\n    }\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/segmentation.py</code> <pre><code>def kili_segmentation_annotation_to_geojson_polygon_feature(\n    segmentation_annotation: Dict[str, Any], job_name: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert a Kili segmentation annotation to a geojson polygon feature.\n\n    Args:\n        segmentation_annotation: A Kili segmentation annotation.\n        job_name: The name of the job to which the annotation belongs.\n\n    Returns:\n        A geojson polygon feature (can be Polygon or MultiPolygon).\n\n    !!! Example\n        ```python\n        # Simple polygon annotation\n        &gt;&gt;&gt; segmentation = {\n        ...     'children': {},\n        ...     'boundingPoly': [\n        ...         [  # Single polygon group\n        ...             {'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]},\n        ...             {'normalizedVertices': [{'x': 0.2, 'y': 0.2}, {'x': 0.8, 'y': 0.2}, {'x': 0.8, 'y': 0.8}]}\n        ...         ]\n        ...     ],\n        ...     'categories': [{'name': 'building'}],\n        ...     'mid': 'building_001',\n        ...     'type': 'semantic'\n        ... }\n        &gt;&gt;&gt; kili_segmentation_annotation_to_geojson_polygon_feature(segmentation, 'detection_job')\n        {\n            'type': 'Feature',\n            'geometry': {\n                'type': 'Polygon',\n                'coordinates': [\n                    [[0, 0], [1, 0], [1, 1], [0, 0]],\n                    [[0.2, 0.2], [0.8, 0.2], [0.8, 0.8], [0.2, 0.2]]\n                ]\n            },\n            'id': 'building_001',\n            'properties': {\n                'kili': {\n                    'categories': [{'name': 'building'}],\n                    'children': {},\n                    'type': 'semantic',\n                    'job': 'detection_job'\n                }\n            }\n        }\n\n        # MultiPolygon annotation\n        &gt;&gt;&gt; segmentation = {\n        ...     'children': {},\n        ...     'boundingPoly': [\n        ...         [{'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]}],  # First polygon\n        ...         [{'normalizedVertices': [{'x': 2, 'y': 2}, {'x': 3, 'y': 2}, {'x': 3, 'y': 3}]}]   # Second polygon\n        ...     ],\n        ...     'categories': [{'name': 'forest'}],\n        ...     'mid': 'forest_001',\n        ...     'type': 'semantic'\n        ... }\n        &gt;&gt;&gt; kili_segmentation_annotation_to_geojson_polygon_feature(segmentation, 'detection_job')\n        {\n            'type': 'Feature',\n            'geometry': {\n                'type': 'MultiPolygon',\n                'coordinates': [\n                    [[[0, 0], [1, 0], [1, 1], [0, 0]]],\n                    [[[2, 2], [3, 2], [3, 3], [2, 2]]]\n                ]\n            },\n            'id': 'forest_001',\n            'properties': {\n                'kili': {\n                    'categories': [{'name': 'forest'}],\n                    'children': {},\n                    'type': 'semantic',\n                    'job': 'detection_job'\n                }\n            }\n        }\n\n        # Flat format annotation\n        &gt;&gt;&gt; segmentation = {\n        ...     'children': {},\n        ...     'boundingPoly': [\n        ...         {'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]}\n        ...     ],\n        ...     'categories': [{'name': 'object'}],\n        ...     'mid': 'object_001',\n        ...     'type': 'semantic'\n        ... }\n        &gt;&gt;&gt; kili_segmentation_annotation_to_geojson_polygon_feature(segmentation, 'detection_job')\n        {\n            'type': 'Feature',\n            'geometry': {\n                'type': 'Polygon',\n                'coordinates': [\n                    [[0, 0], [1, 0], [1, 1], [0, 0]]\n                ]\n            },\n            'id': 'object_001',\n            'properties': {\n                'kili': {\n                    'categories': [{'name': 'object'}],\n                    'children': {},\n                    'type': 'semantic',\n                    'job': 'detection_job'\n                }\n            }\n        }\n        ```\n    \"\"\"\n    assert (\n        segmentation_annotation[\"type\"] == \"semantic\"\n    ), f\"Annotation type must be `semantic`, got: {segmentation_annotation['type']}\"\n\n    geometry = kili_segmentation_to_geojson_geometry(segmentation_annotation[\"boundingPoly\"])\n\n    ret = {\n        \"type\": \"Feature\",\n        \"geometry\": geometry,\n    }\n\n    if \"mid\" in segmentation_annotation:\n        ret[\"id\"] = segmentation_annotation[\"mid\"]\n\n    ret[\"properties\"] = {\n        \"kili\": {\n            k: v for k, v in segmentation_annotation.items() if k not in [\"mid\", \"boundingPoly\"]\n        }\n    }\n\n    if job_name is not None:\n        ret[\"properties\"][\"kili\"][\"job\"] = job_name\n\n    return ret\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.segmentation.kili_segmentation_to_geojson_geometry","title":"<code>kili_segmentation_to_geojson_geometry(bounding_poly)</code>","text":"<p>Convert a Kili segmentation to a geojson polygon or multipolygon geometry.</p> <p>Parameters:</p> Name Type Description Default <code>bounding_poly</code> <code>List[Any]</code> <p>A Kili segmentation bounding polygon.           Can be either:           - Hierarchical: List of polygon groups, each containing rings           - Flat: List of ring dictionaries</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A geojson Polygon or MultiPolygon geometry.</p> <p>Example</p> <pre><code># Single polygon with holes (hierarchical structure)\n&gt;&gt;&gt; bounding_poly = [\n...     [  # First (and only) polygon group\n...         {'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]},  # exterior\n...         {'normalizedVertices': [{'x': 0.2, 'y': 0.2}, {'x': 0.8, 'y': 0.2}, {'x': 0.8, 'y': 0.8}]}  # hole\n...     ]\n... ]\n&gt;&gt;&gt; kili_segmentation_to_geojson_geometry(bounding_poly)\n{\n    'type': 'Polygon',\n    'coordinates': [\n        [[0, 0], [1, 0], [1, 1], [0, 0]],  # exterior ring (closed)\n        [[0.2, 0.2], [0.8, 0.2], [0.8, 0.8], [0.2, 0.2]]  # hole (closed)\n    ]\n}\n\n# MultiPolygon (hierarchical structure)\n&gt;&gt;&gt; bounding_poly = [\n...     [  # First polygon group\n...         {'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]}\n...     ],\n...     [  # Second polygon group\n...         {'normalizedVertices': [{'x': 2, 'y': 2}, {'x': 3, 'y': 2}, {'x': 3, 'y': 3}]}\n...     ]\n... ]\n&gt;&gt;&gt; kili_segmentation_to_geojson_geometry(bounding_poly)\n{\n    'type': 'MultiPolygon',\n    'coordinates': [\n        [[[0, 0], [1, 0], [1, 1], [0, 0]]],  # First polygon\n        [[[2, 2], [3, 2], [3, 3], [2, 2]]]   # Second polygon\n    ]\n}\n\n# Flat structure (single polygon)\n&gt;&gt;&gt; bounding_poly = [\n...     {'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]}\n... ]\n&gt;&gt;&gt; kili_segmentation_to_geojson_geometry(bounding_poly)\n{\n    'type': 'Polygon',\n    'coordinates': [\n        [[0, 0], [1, 0], [1, 1], [0, 0]]\n    ]\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/segmentation.py</code> <pre><code>def kili_segmentation_to_geojson_geometry(bounding_poly: List[Any]) -&gt; Dict[str, Any]:\n    \"\"\"Convert a Kili segmentation to a geojson polygon or multipolygon geometry.\n\n    Args:\n        bounding_poly: A Kili segmentation bounding polygon.\n                      Can be either:\n                      - Hierarchical: List of polygon groups, each containing rings\n                      - Flat: List of ring dictionaries\n\n    Returns:\n        A geojson Polygon or MultiPolygon geometry.\n\n    !!! Example\n        ```python\n        # Single polygon with holes (hierarchical structure)\n        &gt;&gt;&gt; bounding_poly = [\n        ...     [  # First (and only) polygon group\n        ...         {'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]},  # exterior\n        ...         {'normalizedVertices': [{'x': 0.2, 'y': 0.2}, {'x': 0.8, 'y': 0.2}, {'x': 0.8, 'y': 0.8}]}  # hole\n        ...     ]\n        ... ]\n        &gt;&gt;&gt; kili_segmentation_to_geojson_geometry(bounding_poly)\n        {\n            'type': 'Polygon',\n            'coordinates': [\n                [[0, 0], [1, 0], [1, 1], [0, 0]],  # exterior ring (closed)\n                [[0.2, 0.2], [0.8, 0.2], [0.8, 0.8], [0.2, 0.2]]  # hole (closed)\n            ]\n        }\n\n        # MultiPolygon (hierarchical structure)\n        &gt;&gt;&gt; bounding_poly = [\n        ...     [  # First polygon group\n        ...         {'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]}\n        ...     ],\n        ...     [  # Second polygon group\n        ...         {'normalizedVertices': [{'x': 2, 'y': 2}, {'x': 3, 'y': 2}, {'x': 3, 'y': 3}]}\n        ...     ]\n        ... ]\n        &gt;&gt;&gt; kili_segmentation_to_geojson_geometry(bounding_poly)\n        {\n            'type': 'MultiPolygon',\n            'coordinates': [\n                [[[0, 0], [1, 0], [1, 1], [0, 0]]],  # First polygon\n                [[[2, 2], [3, 2], [3, 3], [2, 2]]]   # Second polygon\n            ]\n        }\n\n        # Flat structure (single polygon)\n        &gt;&gt;&gt; bounding_poly = [\n        ...     {'normalizedVertices': [{'x': 0, 'y': 0}, {'x': 1, 'y': 0}, {'x': 1, 'y': 1}]}\n        ... ]\n        &gt;&gt;&gt; kili_segmentation_to_geojson_geometry(bounding_poly)\n        {\n            'type': 'Polygon',\n            'coordinates': [\n                [[0, 0], [1, 0], [1, 1], [0, 0]]\n            ]\n        }\n        ```\n    \"\"\"\n    if not bounding_poly:\n        raise ValueError(\"Empty bounding_poly\")\n\n    is_hierarchical = _is_hierarchical_format(bounding_poly)\n\n    if is_hierarchical:\n        # Hierarchical format: [ [ {normalizedVertices: [...]}, ... ], ... ]\n        if len(bounding_poly) == 1:\n            # Single polygon (potentially with holes)\n            ret = {\"type\": \"Polygon\", \"coordinates\": []}\n            for ring_dict in bounding_poly[0]:\n                ring_coords = [\n                    [vertex[\"x\"], vertex[\"y\"]] for vertex in ring_dict[\"normalizedVertices\"]\n                ]\n                # Ensure the first and last points are identical (closed ring)\n                if ring_coords and ring_coords[0] != ring_coords[-1]:\n                    ring_coords.append(ring_coords[0])\n                ret[\"coordinates\"].append(ring_coords)\n            return ret\n        else:\n            # MultiPolygon\n            ret = {\"type\": \"MultiPolygon\", \"coordinates\": []}\n            for polygon_group in bounding_poly:\n                polygon_coords = []\n                for ring_dict in polygon_group:\n                    ring_coords = [\n                        [vertex[\"x\"], vertex[\"y\"]] for vertex in ring_dict[\"normalizedVertices\"]\n                    ]\n                    # Ensure the first and last points are identical (closed ring)\n                    if ring_coords and ring_coords[0] != ring_coords[-1]:\n                        ring_coords.append(ring_coords[0])\n                    polygon_coords.append(ring_coords)\n                ret[\"coordinates\"].append(polygon_coords)\n            return ret\n    else:\n        # Flat format: [ {normalizedVertices: [...]}, ... ]\n        # Treat as single polygon with multiple rings (exterior + holes)\n        ret = {\"type\": \"Polygon\", \"coordinates\": []}\n        for ring_dict in bounding_poly:\n            ring_coords = [[vertex[\"x\"], vertex[\"y\"]] for vertex in ring_dict[\"normalizedVertices\"]]\n            # Ensure the first and last points are identical (closed ring)\n            if ring_coords and ring_coords[0] != ring_coords[-1]:\n                ring_coords.append(ring_coords[0])\n            ret[\"coordinates\"].append(ring_coords)\n        return ret\n</code></pre>"},{"location":"sdk/label_utils/#collection","title":"Collection","text":"<p>Geojson collection module.</p>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.collection._convert_flat_to_hierarchical_format","title":"<code>_convert_flat_to_hierarchical_format(annotations_group)</code>  <code>private</code>","text":"<p>Convert flat format annotations to hierarchical format.</p> <p>Parameters:</p> Name Type Description Default <code>annotations_group</code> <p>List of semantic annotations with the same mid</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Single annotation with hierarchical boundingPoly structure</p> Source code in <code>kili_formats/format/geojson/collection.py</code> <pre><code>def _convert_flat_to_hierarchical_format(annotations_group) -&gt; Dict[str, Any]:\n    \"\"\"Convert flat format annotations to hierarchical format.\n\n    Args:\n        annotations_group: List of semantic annotations with the same mid\n\n    Returns:\n        Single annotation with hierarchical boundingPoly structure\n    \"\"\"\n    if len(annotations_group) == 1:\n        # Single annotation - check if it's already hierarchical\n        annotation = annotations_group[0]\n        if _is_hierarchical_format(annotation[\"boundingPoly\"]):\n            return annotation\n        else:\n            # Convert flat to hierarchical\n            new_ann = annotation.copy()\n            new_ann[\"boundingPoly\"] = [annotation[\"boundingPoly\"]]\n            return new_ann\n    else:\n        # Multiple annotations with same mid - merge them\n        base_ann = annotations_group[0].copy()\n        all_bounding_poly = []\n\n        for annotation in annotations_group:\n            if _is_hierarchical_format(annotation[\"boundingPoly\"]):\n                # Already hierarchical - add each polygon group\n                all_bounding_poly.extend(annotation[\"boundingPoly\"])\n            else:\n                # Flat format - add as single polygon group\n                all_bounding_poly.append(annotation[\"boundingPoly\"])\n\n        base_ann[\"boundingPoly\"] = all_bounding_poly\n        return base_ann\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.collection._group_semantic_annotations_by_mid","title":"<code>_group_semantic_annotations_by_mid(annotations)</code>  <code>private</code>","text":"<p>Group semantic annotations by their mid (for multi-part polygons).</p> Source code in <code>kili_formats/format/geojson/collection.py</code> <pre><code>def _group_semantic_annotations_by_mid(annotations) -&gt; Dict[str, Any]:\n    \"\"\"Group semantic annotations by their mid (for multi-part polygons).\"\"\"\n    grouped = defaultdict(list)\n    for annotation in annotations:\n        if annotation.get(\"type\") == \"semantic\" and \"mid\" in annotation:\n            grouped[annotation[\"mid\"]].append(annotation)\n        else:\n            # For annotations without mid or non-semantic, treat as individual\n            grouped[id(annotation)] = [annotation]  # Use object id as unique key\n    return grouped\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.collection._is_hierarchical_format","title":"<code>_is_hierarchical_format(bounding_poly)</code>  <code>private</code>","text":"<p>Check if boundingPoly is in hierarchical format.</p> <p>Hierarchical: [ [ {normalizedVertices: [...]}, ... ], ... ] Flat: [ {normalizedVertices: [...]}, ... ]</p> Source code in <code>kili_formats/format/geojson/collection.py</code> <pre><code>def _is_hierarchical_format(bounding_poly) -&gt; bool:\n    \"\"\"Check if boundingPoly is in hierarchical format.\n\n    Hierarchical: [ [ {normalizedVertices: [...]}, ... ], ... ]\n    Flat: [ {normalizedVertices: [...]}, ... ]\n    \"\"\"\n    if not bounding_poly or len(bounding_poly) == 0:\n        return False\n\n    first_element = bounding_poly[0]\n\n    # If first element is a list, it's hierarchical\n    if isinstance(first_element, list):\n        return True\n\n    # If first element is a dict with 'normalizedVertices', it's flat\n    if isinstance(first_element, dict) and \"normalizedVertices\" in first_element:\n        return False\n\n    # Default to flat format\n    return False\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.collection.features_to_feature_collection","title":"<code>features_to_feature_collection(features)</code>","text":"<p>Convert a list of features to a feature collection.</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>Sequence[Dict]</code> <p>a list of Geojson features.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A Geojson feature collection.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; features = [\n    {\n        'type': 'Feature',\n        'geometry': {\n            'type': 'Point',\n            'coordinates': [-79.0, -3.0]},\n            'id': '1',\n        }\n    },\n    {\n        'type': 'Feature',\n        'geometry': {\n            'type': 'Point',\n            'coordinates': [-79.0, -3.0]},\n            'id': '2',\n        }\n    }\n]\n&gt;&gt;&gt; features_to_feature_collection(features)\n{\n    'type': 'FeatureCollection',\n    'features': [\n        {\n            'type': 'Feature',\n            'geometry': {\n                'type': 'Point',\n                'coordinates': [-79.0, -3.0]},\n                'id': '1',\n            }\n        },\n        {\n            'type': 'Feature',\n            'geometry': {\n                'type': 'Point',\n                'coordinates': [-79.0, -3.0]},\n                'id': '2',\n            }\n        }\n    ]\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/collection.py</code> <pre><code>def features_to_feature_collection(\n    features: Sequence[Dict],\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert a list of features to a feature collection.\n\n    Args:\n        features: a list of Geojson features.\n\n    Returns:\n        A Geojson feature collection.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; features = [\n            {\n                'type': 'Feature',\n                'geometry': {\n                    'type': 'Point',\n                    'coordinates': [-79.0, -3.0]},\n                    'id': '1',\n                }\n            },\n            {\n                'type': 'Feature',\n                'geometry': {\n                    'type': 'Point',\n                    'coordinates': [-79.0, -3.0]},\n                    'id': '2',\n                }\n            }\n        ]\n        &gt;&gt;&gt; features_to_feature_collection(features)\n        {\n            'type': 'FeatureCollection',\n            'features': [\n                {\n                    'type': 'Feature',\n                    'geometry': {\n                        'type': 'Point',\n                        'coordinates': [-79.0, -3.0]},\n                        'id': '1',\n                    }\n                },\n                {\n                    'type': 'Feature',\n                    'geometry': {\n                        'type': 'Point',\n                        'coordinates': [-79.0, -3.0]},\n                        'id': '2',\n                    }\n                }\n            ]\n        }\n        ```\n    \"\"\"\n    return {\"type\": \"FeatureCollection\", \"features\": list(features)}\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.collection.geojson_feature_collection_to_kili_json_response","title":"<code>geojson_feature_collection_to_kili_json_response(feature_collection)</code>","text":"<p>Convert a Geojson feature collection to a Kili label json response.</p> <p>Parameters:</p> Name Type Description Default <code>feature_collection</code> <code>Dict[str, Any]</code> <p>a Geojson feature collection.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A Kili label json response.</p> <p>Warning</p> <p>This method requires the <code>kili</code> key to be present in the geojson features' properties. In particular, the <code>kili</code> dictionary of a feature must contain the <code>categories</code> and <code>type</code> of the annotation. It must also contain the <code>job</code> name.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; feature_collection = {\n    'type': 'FeatureCollection',\n    'features': [\n        {\n            'type': 'Feature',\n            'geometry': {\n                ...\n            },\n            'properties': {\n                'kili': {\n                    'categories': [{'name': 'A'}],\n                    'type': 'marker',\n                    'job': 'POINT_DETECTION_JOB'\n                }\n            }\n        },\n    ]\n}\n&gt;&gt;&gt; geojson_feature_collection_to_kili_json_response(feature_collection)\n{\n    'POINT_DETECTION_JOB': {\n        'annotations': [\n            {\n                'categories': [{'name': 'A'}],\n                'type': 'marker',\n                'point': ...\n            }\n        ]\n    }\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/collection.py</code> <pre><code>def geojson_feature_collection_to_kili_json_response(\n    feature_collection: Dict[str, Any],\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert a Geojson feature collection to a Kili label json response.\n\n    Args:\n        feature_collection: a Geojson feature collection.\n\n    Returns:\n        A Kili label json response.\n\n    !!! Warning\n        This method requires the `kili` key to be present in the geojson features' properties.\n        In particular, the `kili` dictionary of a feature must contain the `categories` and `type` of the annotation.\n        It must also contain the `job` name.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; feature_collection = {\n            'type': 'FeatureCollection',\n            'features': [\n                {\n                    'type': 'Feature',\n                    'geometry': {\n                        ...\n                    },\n                    'properties': {\n                        'kili': {\n                            'categories': [{'name': 'A'}],\n                            'type': 'marker',\n                            'job': 'POINT_DETECTION_JOB'\n                        }\n                    }\n                },\n            ]\n        }\n        &gt;&gt;&gt; geojson_feature_collection_to_kili_json_response(feature_collection)\n        {\n            'POINT_DETECTION_JOB': {\n                'annotations': [\n                    {\n                        'categories': [{'name': 'A'}],\n                        'type': 'marker',\n                        'point': ...\n                    }\n                ]\n            }\n        }\n        ```\n    \"\"\"\n    assert (\n        feature_collection[\"type\"] == \"FeatureCollection\"\n    ), f\"Feature collection type must be `FeatureCollection`, got: {feature_collection['type']}\"\n\n    annotation_tool_to_converter = {\n        \"rectangle\": geojson_polygon_feature_to_kili_bbox_annotation,\n        \"marker\": geojson_point_feature_to_kili_point_annotation,\n        \"polygon\": geojson_polygon_feature_to_kili_polygon_annotation,\n        \"polyline\": geojson_linestring_feature_to_kili_line_annotation,\n        \"semantic\": geojson_polygon_feature_to_kili_segmentation_annotation,\n    }\n\n    json_response = {}\n\n    for feature in feature_collection[\"features\"]:\n        if feature.get(\"properties\").get(\"kili\", {}).get(\"job\") is None:\n            raise ValueError(f\"Job name is missing in the GeoJson feature {feature}\")\n\n        job_name = feature[\"properties\"][\"kili\"][\"job\"]\n\n        if feature.get(\"geometry\") is None:\n            # non localised annotation\n            if feature.get(\"properties\").get(\"kili\", {}).get(\"text\") is not None:\n                # transcription job\n                json_response[job_name] = {\"text\": feature[\"properties\"][\"kili\"][\"text\"]}\n            elif feature.get(\"properties\").get(\"kili\", {}).get(\"categories\") is not None:\n                # classification job\n                json_response[job_name] = {\n                    \"categories\": feature[\"properties\"][\"kili\"][\"categories\"]\n                }\n            else:\n                raise ValueError(\"Invalid kili property in non localised feature\")\n            continue\n\n        geometry_type = feature[\"geometry\"][\"type\"]\n\n        if geometry_type == \"GeometryCollection\":\n            kili_annotations = geojson_geometrycollection_feature_to_kili_annotations(feature)\n        elif geometry_type == \"MultiPoint\":\n            kili_annotations = geojson_multipoint_feature_to_kili_point_annotations(feature)\n        elif geometry_type == \"MultiLineString\":\n            kili_annotations = geojson_multilinestring_feature_to_kili_line_annotations(feature)\n        else:\n            if feature.get(\"properties\").get(\"kili\", {}).get(\"type\") is None:\n                raise ValueError(f\"Annotation `type` is missing in the GeoJson feature {feature}\")\n\n            annotation_tool = feature[\"properties\"][\"kili\"][\"type\"]\n\n            if annotation_tool not in annotation_tool_to_converter:\n                raise ValueError(f\"Annotation tool {annotation_tool} is not supported.\")\n\n            kili_annotation = annotation_tool_to_converter[annotation_tool](feature)\n            kili_annotations = (\n                kili_annotation if isinstance(kili_annotation, list) else [kili_annotation]\n            )\n\n        if job_name not in json_response:\n            json_response[job_name] = {}\n        if \"annotations\" not in json_response[job_name]:\n            json_response[job_name][\"annotations\"] = []\n\n        json_response[job_name][\"annotations\"].extend(kili_annotations)\n\n    return json_response\n</code></pre>"},{"location":"sdk/label_utils/#kili_formats.format.geojson.collection.kili_json_response_to_feature_collection","title":"<code>kili_json_response_to_feature_collection(json_response)</code>","text":"<p>Convert a Kili label json response to a Geojson feature collection.</p> <p>Parameters:</p> Name Type Description Default <code>json_response</code> <code>Dict[str, Any]</code> <p>a Kili label json response.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A Geojson feature collection.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; json_response = {\n    'job_1': {\n        'annotations': [...]\n    },\n    'job_2': {\n        'annotations': [...]\n    }\n}\n&gt;&gt;&gt; kili_json_response_to_feature_collection(json_response)\n{\n    'type': 'FeatureCollection',\n    'features': [\n        {\n            'type': 'Feature',\n            'geometry': {\n                ...\n            }\n        },\n        {\n            'type': 'Feature',\n            'geometry': {\n                ...\n            }\n        }\n    ]\n}\n</code></pre> Source code in <code>kili_formats/format/geojson/collection.py</code> <pre><code>def kili_json_response_to_feature_collection(json_response: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Convert a Kili label json response to a Geojson feature collection.\n\n    Args:\n        json_response: a Kili label json response.\n\n    Returns:\n        A Geojson feature collection.\n\n    !!! Example\n        ```python\n        &gt;&gt;&gt; json_response = {\n            'job_1': {\n                'annotations': [...]\n            },\n            'job_2': {\n                'annotations': [...]\n            }\n        }\n        &gt;&gt;&gt; kili_json_response_to_feature_collection(json_response)\n        {\n            'type': 'FeatureCollection',\n            'features': [\n                {\n                    'type': 'Feature',\n                    'geometry': {\n                        ...\n                    }\n                },\n                {\n                    'type': 'Feature',\n                    'geometry': {\n                        ...\n                    }\n                }\n            ]\n        }\n        ```\n    \"\"\"\n    features = []\n\n    annotation_tool_to_converter = {\n        \"rectangle\": kili_bbox_annotation_to_geojson_polygon_feature,  # bbox\n        \"marker\": kili_point_annotation_to_geojson_point_feature,  # point\n        \"polygon\": kili_polygon_annotation_to_geojson_polygon_feature,  # polygon\n        \"polyline\": kili_line_annotation_to_geojson_linestring_feature,  # line\n        \"semantic\": kili_segmentation_annotation_to_geojson_polygon_feature,  # semantic\n    }\n\n    jobs_skipped = []\n    ann_tools_not_supported = set()\n    for job_name, job_response in json_response.items():\n        if \"text\" in job_response:\n            features.append(\n                kili_transcription_annotation_to_geojson_non_localised_feature(\n                    job_response, job_name\n                ),\n            )\n            continue\n\n        if \"categories\" in job_response:\n            features.append(\n                kili_classification_annotation_to_geojson_non_localised_feature(\n                    job_response, job_name\n                ),\n            )\n            continue\n\n        if \"annotations\" not in job_response:\n            jobs_skipped.append(job_name)\n            continue\n\n        # Group semantic annotations by mid before processing\n        annotations = job_response[\"annotations\"]\n        semantic_annotations = [\n            annotation for annotation in annotations if annotation.get(\"type\") == \"semantic\"\n        ]\n        non_semantic_annotations = [\n            annotation for annotation in annotations if annotation.get(\"type\") != \"semantic\"\n        ]\n\n        # Process non-semantic annotations normally\n        for annotation in non_semantic_annotations:\n            annotation_tool = annotation.get(\"type\")\n            if annotation_tool not in annotation_tool_to_converter:\n                ann_tools_not_supported.add(annotation_tool)\n                continue\n\n            converter = annotation_tool_to_converter[annotation_tool]\n\n            try:\n                feature = converter(annotation, job_name=job_name)\n                features.append(feature)\n            except ConversionError as error:\n                warnings.warn(\n                    error.args[0],\n                    stacklevel=2,\n                )\n                continue\n\n        # Process semantic annotations with grouping\n        if semantic_annotations:\n            grouped_semantic = _group_semantic_annotations_by_mid(semantic_annotations)\n\n            for mid_or_id, annotations_group in grouped_semantic.items():\n                try:\n                    # Convert to hierarchical format if needed\n                    merged_annotation = _convert_flat_to_hierarchical_format(annotations_group)\n\n                    # Convert to GeoJSON\n                    feature = kili_segmentation_annotation_to_geojson_polygon_feature(\n                        merged_annotation, job_name=job_name\n                    )\n                    features.append(feature)\n                except ConversionError as error:\n                    warnings.warn(\n                        error.args[0],\n                        stacklevel=2,\n                    )\n                    continue\n                except Exception as error:\n                    warnings.warn(\n                        f\"Error converting semantic annotation: {error}\",\n                        stacklevel=2,\n                    )\n                    continue\n\n    if jobs_skipped:\n        warnings.warn(f\"Jobs {jobs_skipped} cannot be exported to GeoJson format.\", stacklevel=2)\n    if ann_tools_not_supported:\n        warnings.warn(\n            f\"Annotation tools {ann_tools_not_supported} are not supported and will be skipped.\",\n            stacklevel=2,\n        )\n    return features_to_feature_collection(features)\n</code></pre>"},{"location":"sdk/llm/","title":"LLM module","text":"Source code in <code>kili/llm/presentation/client/llm.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass LlmClientMethods:\n    def __init__(self, kili_api_gateway: KiliAPIGateway):\n        self.kili_api_gateway = kili_api_gateway\n\n    def import_conversations(\n        self,\n        project_id: str,\n        conversations: List[Conversation],\n    ):\n        \"\"\"Import conversations into a LLM Static project.\n\n        Args:\n            project_id: Identifier of the project.\n            conversations: List of conversations to import. Each conversation should be a dictionary with the following keys\n                - `chatItems`: List of chat items in the conversation. Each chat item should be a dictionary with the following keys\n                    - `content`: (required) Content of the chat item.\n                    - `externalId`: (required) Identifier of the chat item (must be unique).\n                    - `modelName`: Name of the model that generated the chat item. Required only for ASSISTANT chat items.\n                    - `role`: (required) Role of the chat item, one of `SYSTEM`, `USER` or `ASSISTANT`.\n                - `externalId`: (required) Identifier of the conversation (must be unique).\n                - `label`: (optional) Label associated with the conversation. Should be a dictionary with the following keys\n                    - `conversation`\n                    - `completion`\n                    - `round`\n                - `labeler`: (optional) Email of the labeler associated with the conversation.\n                - `metadata`: (optional) Additional metadata associated with the conversation.\n\n        Returns:\n            A dict containing following keys\n            - `numberOfUploadedAssets`: Number of assets uploaded.\n            - `warnings`: List of detailed warnings generated during the import process, for each conversation.\n        \"\"\"\n        return self.kili_api_gateway.import_conversations(\n            project_id=project_id, conversations=conversations\n        )\n\n    def export(\n        self,\n        project_id: str,\n        disable_tqdm: Optional[bool] = False,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        include_sent_back_labels: Optional[bool] = False,\n        label_type_in: Optional[List[LabelType]] = None,\n        status_in: Optional[List[AssetStatus]] = None,\n        step_name_in: Optional[List[str]] = None,\n        step_status_in: Optional[List[StatusInStep]] = None,\n    ) -&gt; Optional[Union[List[Conversation], List[Dict[str, Union[List[str], str]]]]]:\n        \"\"\"Returns an export of llm conversations with valid labels.\n\n        Args:\n            project_id: Identifier of the project.\n            asset_ids: Optional list of the assets internal IDs from which to export the labels.\n            disable_tqdm: Disable the progress bar if True.\n            external_ids: Optional list of the assets external IDs from which to export the labels.\n            include_sent_back_labels: Include sent back labels if True.\n            label_type_in: Optional types of label to fetch, by default [\"DEFAULT\", \"REVIEW\"].\n            status_in: Returned assets should have a status that belongs to that list, if given.\n                Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED`.\n            step_name_in: Returned assets are in a step whose name belong to that list, if given.\n                Only applicable if the project is in WorkflowV2.\n            step_status_in: Returned assets have the status of their step that belongs to that list, if given.\n                Possible choices: `TO_DO`, `DOING`, `PARTIALLY_DONE`, `REDO`, `DONE`, `SKIPPED`.\n                Only applicable if the project is in WorkflowV2.\n        !!! Example\n            ```python\n            kili.llm.export(\"your_project_id\")\n            ```\n        \"\"\"\n        if asset_ids and external_ids:\n            raise ValueError(\"You cannot provide both asset_ids and external_ids\")\n\n        if external_ids is not None and asset_ids is None:\n            id_map = AssetUseCasesUtils(self.kili_api_gateway).infer_ids_from_external_ids(\n                asset_external_ids=cast(List[AssetExternalId], external_ids),\n                project_id=ProjectId(project_id),\n            )\n            resolved_asset_ids = [id_map[AssetExternalId(i)] for i in external_ids]\n        else:\n            resolved_asset_ids = (\n                list(AssetId(asset_id) for asset_id in asset_ids) if asset_ids else None\n            )\n\n        label_type_in = label_type_in or [\"DEFAULT\", \"REVIEW\"]\n\n        step_id_in = None\n\n        if status_in is not None or step_name_in is not None or step_status_in is not None:\n            project_use_cases = ProjectUseCases(self.kili_api_gateway)\n            (\n                project_steps,\n                project_workflow_version,\n            ) = project_use_cases.get_project_steps_and_version(project_id)\n            check_asset_workflow_arguments(\n                project_workflow_version=project_workflow_version,\n                asset_workflow_filters={\n                    \"skipped\": None,\n                    \"status_in\": status_in,\n                    \"step_name_in\": step_name_in,\n                    \"step_status_in\": step_status_in,\n                },\n            )\n\n            if project_workflow_version == \"V2\" and step_name_in is not None:\n                step_id_in = extract_step_ids_from_project_steps(\n                    project_steps=project_steps,\n                    step_name_in=step_name_in,\n                )\n\n        asset_filter = AssetFilters(\n            project_id=ProjectId(project_id),\n            asset_id_in=resolved_asset_ids,\n            label_type_in=label_type_in,\n            status_in=status_in,\n            step_id_in=step_id_in,\n            step_status_in=step_status_in,\n        )\n\n        try:\n            return export(\n                self.kili_api_gateway,\n                project_id=ProjectId(project_id),\n                asset_filter=asset_filter,\n                disable_tqdm=disable_tqdm,\n                include_sent_back_labels=include_sent_back_labels,\n                label_type_in=label_type_in,\n            )\n        except NoCompatibleJobError as excp:\n            warnings.warn(str(excp), stacklevel=2)\n            return None\n\n    def create_model(self, organization_id: str, model: dict) -&gt; ModelDict:\n        \"\"\"Create a new model in an organization.\n\n        Args:\n            organization_id: Identifier of the organization.\n            model: A dictionary representing the model to create, containing:\n                - `name`: Name of the model.\n                - `type`: Type of the model, one of:\n                    - `\"AZURE_OPEN_AI\"`\n                    - `\"OPEN_AI_SDK\"`\n                - `credentials`: Credentials required for the model, depending on the type:\n                    - For `\"AZURE_OPEN_AI\"` type:\n                        - `api_key`: The API key for Azure OpenAI.\n                        - `deployment_id`: The deployment ID within Azure.\n                        - `endpoint`: The endpoint URL of the Azure OpenAI service.\n                    - For `\"OPEN_AI_SDK\"` type:\n                        - `api_key`: The API key for OpenAI SDK.\n                        - `endpoint`: The endpoint URL of the OpenAI SDK service.\n\n        Returns:\n            A dictionary containing the created model's details.\n\n        Examples:\n            &gt;&gt;&gt; # Example of creating an OpenAI SDK model\n            &gt;&gt;&gt; model_data = {\n            ...     \"name\": \"My OpenAI SDK Model\",\n            ...     \"type\": \"OPEN_AI_SDK\",\n            ...     \"credentials\": {\n            ...         \"api_key\": \"your_open_ai_api_key\",\n            ...         \"endpoint\": \"your_open_ai_endpoint\"\n            ...     }\n            ... }\n            &gt;&gt;&gt; kili.llm.create_model(organization_id=\"your_organization_id\", model=model_data)\n        \"\"\"\n        credentials_data = model[\"credentials\"]\n        model_type = ModelType(model[\"type\"])\n\n        if model_type == ModelType.AZURE_OPEN_AI:\n            credentials = AzureOpenAICredentials(**credentials_data)\n        elif model_type == ModelType.OPEN_AI_SDK:\n            credentials = OpenAISDKCredentials(**credentials_data)\n        else:\n            raise ValueError(f\"Unsupported model type: {model['type']}\")\n\n        model_input = ModelToCreateInput(\n            credentials=credentials,\n            name=model[\"name\"],\n            type=model_type,\n            organization_id=organization_id,\n        )\n        return self.kili_api_gateway.create_model(model=model_input)\n\n    def models(self, organization_id: str, fields: Optional[List[str]] = None) -&gt; List[ModelDict]:\n        \"\"\"List models in an organization.\n\n        Args:\n            organization_id: Identifier of the organization.\n            fields: All the fields to request among the possible fields for the models.\n                Defaults to [\"id\", \"credentials\", \"name\", \"type\"].\n\n        Returns:\n            A list of models.\n\n        Examples:\n            &gt;&gt;&gt; kili.llm.models(organization_id=\"your_organization_id\")\n        \"\"\"\n        converted_filters = OrganizationModelFilters(\n            organization_id=organization_id,\n        )\n\n        return list(self.kili_api_gateway.list_models(filters=converted_filters, fields=fields))\n\n    def model(self, model_id: str, fields: Optional[List[str]] = None) -&gt; ModelDict:\n        \"\"\"Retrieve a specific model.\n\n        Args:\n            model_id: Identifier of the model.\n            fields: All the fields to request among the possible fields for the models.\n                Defaults to [\"id\", \"credentials\", \"name\", \"type\"].\n\n        Returns:\n            A dictionary representing the model.\n\n        Examples:\n            &gt;&gt;&gt; kili.llm.model(model_id=\"your_model_id\")\n        \"\"\"\n        return self.kili_api_gateway.get_model(\n            model_id=model_id,\n            fields=fields,\n        )\n\n    def update_properties_in_model(self, model_id: str, model: dict) -&gt; ModelDict:\n        \"\"\"Update properties of an existing model.\n\n        Args:\n            model_id: Identifier of the model to update.\n            model: A dictionary containing the properties to update, which may include:\n                - `name`: New name of the model.\n                - `credentials`: Updated credentials for the model, depending on the type:\n                    - For `\"AZURE_OPEN_AI\"` type:\n                        - `api_key`: The API key for Azure OpenAI.\n                        - `deployment_id`: The deployment ID within Azure.\n                        - `endpoint`: The endpoint URL of the Azure OpenAI service.\n                    - For `\"OPEN_AI_SDK\"` type:\n                        - `api_key`: The API key for OpenAI SDK.\n                        - `endpoint`: The endpoint URL of the OpenAI SDK service.\n\n        Returns:\n            A dictionary containing the updated model's details.\n\n        Examples:\n            &gt;&gt;&gt; # Update the name of a model\n            &gt;&gt;&gt; kili.llm.update_properties_in_model(\n            ...     model_id=\"your_model_id\",\n            ...     model={\"name\": \"Updated Model Name\"}\n            ... )\n        \"\"\"\n        credentials_data = model.get(\"credentials\")\n        credentials = None\n\n        if credentials_data:\n            existing_model = self.kili_api_gateway.get_model(\n                model_id=model_id, fields=[\"id\", \"type\"]\n            )\n            if not existing_model:\n                raise ValueError(f\"Model with id {model_id} not found\")\n            model_type = ModelType(existing_model[\"type\"])\n\n            if model_type == ModelType.AZURE_OPEN_AI:\n                credentials = AzureOpenAICredentials(**credentials_data)\n            elif model_type == ModelType.OPEN_AI_SDK:\n                credentials = OpenAISDKCredentials(**credentials_data)\n            else:\n                raise ValueError(f\"Unsupported model type: {model_type}\")\n\n        model_input = ModelToUpdateInput(\n            credentials=credentials,\n            name=model.get(\"name\"),\n        )\n        return self.kili_api_gateway.update_properties_in_model(\n            model_id=model_id, model=model_input\n        )\n\n    def delete_model(self, model_id: str) -&gt; bool:\n        \"\"\"Delete a model from an organization.\n\n        Args:\n            model_id: Identifier of the model to delete.\n\n        Returns:\n            A dictionary indicating the result of the deletion.\n\n        Examples:\n            &gt;&gt;&gt; kili.llm.delete_model(model_id=\"your_model_id\")\n        \"\"\"\n        return self.kili_api_gateway.delete_model(model_id=model_id)\n\n    def create_project_model(\n        self, project_id: str, model_id: str, configuration: dict\n    ) -&gt; ProjectModelDict:\n        \"\"\"Associate a model with a project.\n\n        Args:\n            project_id: Identifier of the project.\n            model_id: Identifier of the model to associate.\n            configuration: Configuration parameters for the project model.\n\n        Returns:\n            A dictionary containing the created project model's details.\n\n        Examples:\n            &gt;&gt;&gt; configuration = {\n            ...     # Configuration details specific to your use case\n            ... }\n            &gt;&gt;&gt; kili.llm.create_project_model(\n            ...     project_id=\"your_project_id\",\n            ...     model_id=\"your_model_id\",\n            ...     configuration={\"temperature\": 0.7}\n            ... )\n        \"\"\"\n        project_model_input = ProjectModelToCreateInput(\n            project_id=project_id, model_id=model_id, configuration=configuration\n        )\n        return self.kili_api_gateway.create_project_model(project_model=project_model_input)\n\n    def project_models(\n        self, project_id: str, filters: Optional[Dict] = None, fields: Optional[List[str]] = None\n    ) -&gt; List[ProjectModelDict]:\n        \"\"\"List models associated with a project.\n\n        Args:\n            project_id: Identifier of the project.\n            filters: Optional filters to apply. Possible keys:\n                - `model_id`: Identifier of a specific model to filter by.\n            fields: All the fields to request among the possible fields for the project models.\n                Defaults to [\"configuration\", \"id\", \"model.credentials\", \"model.name\", \"model.type\"].\n\n        Returns:\n            A list of project models.\n\n        Examples:\n            &gt;&gt;&gt; kili.llm.project_models(project_id=\"your_project_id\")\n        \"\"\"\n        converted_filters = ProjectModelFilters(\n            project_id=project_id,\n            model_id=filters[\"model_id\"] if filters and \"model_id\" in filters else None,\n        )\n\n        return list(\n            self.kili_api_gateway.list_project_models(\n                filters=converted_filters,\n                fields=fields,\n            )\n        )\n\n    def update_project_model(self, project_model_id: str, configuration: dict) -&gt; ProjectModelDict:\n        \"\"\"Update the configuration of a project model.\n\n        Args:\n            project_model_id: Identifier of the project model to update.\n            configuration: New configuration parameters.\n\n        Returns:\n            A dictionary containing the updated project model's details.\n\n        Examples:\n            &gt;&gt;&gt; configuration = {\n            ...     # Updated configuration details\n            ... }\n            &gt;&gt;&gt; kili.llm.update_project_model(\n            ...     project_model_id=\"your_project_model_id\",\n            ...     configuration=configuration\n            ... )\n        \"\"\"\n        project_model_input = ProjectModelToUpdateInput(configuration=configuration)\n        return self.kili_api_gateway.update_project_model(\n            project_model_id=project_model_id, project_model=project_model_input\n        )\n\n    def delete_project_model(self, project_model_id: str) -&gt; bool:\n        \"\"\"Delete a project model.\n\n        Args:\n            project_model_id: Identifier of the project model to delete.\n\n        Returns:\n            A dictionary indicating the result of the deletion.\n\n        Examples:\n            &gt;&gt;&gt; kili.llm.delete_project_model(project_model_id=\"your_project_model_id\")\n        \"\"\"\n        return self.kili_api_gateway.delete_project_model(project_model_id)\n\n    def list_chat_items(self, asset_id: str) -&gt; List[ChatItem]:\n        \"\"\"List chat items associated with an asset.\n\n        Args:\n            asset_id: Identifier of the asset.\n\n        Returns:\n            A list of chat items associated with the asset.\n\n        Examples:\n            &gt;&gt;&gt; kili.llm.list_chat_items(asset_id=\"your_asset_id\")\n        \"\"\"\n        return self.kili_api_gateway.list_chat_items(asset_id=asset_id)\n\n    def create_conversation(\n        self, project_id: str, initial_prompt: str, system_prompt: Optional[str] = None\n    ) -&gt; List[ChatItem]:\n        \"\"\"Create a new conversation in an LLM project starting with a user's prompt.\n\n        This method initiates a new conversation in the specified project by:\n        - Creating an LLM asset and label associated with the current user.\n        - Adding the user's prompt as the first chat item.\n        - Automatically generating assistant responses using the project's models.\n\n        Args:\n            project_id: The identifier of the project where the conversation will be created.\n            initial_prompt: The initial prompt or message from the user to start the conversation.\n            system_prompt: Optional system prompt to guide the assistant's responses.\n\n        Returns:\n            A list of chat items in the conversation, including the user's prompts and the assistant's responses.\n\n        Examples:\n            &gt;&gt;&gt; PROMPT = \"Hello, how can I improve my coding skills?\"\n            &gt;&gt;&gt; chat_items = kili.llm.create_conversation(project_id=\"your_project_id\", prompt=PROMPT)\n\n        Notes:\n            - The first chat item corresponds to the user's prompt.\n            - The subsequent chat items are assistant responses generated by the project's models.\n            - An LLM asset and a label are created in the project with labelType \"PREDICTION\".\n        \"\"\"\n        user_id = self.kili_api_gateway.get_current_user([\"id\"])[\"id\"]\n        llm_asset = self.kili_api_gateway.create_llm_asset(\n            project_id=project_id,\n            author_id=user_id,\n            label_type=\"PREDICTION\",\n        )\n        asset_id = llm_asset[\"id\"]\n        label_id = llm_asset[\"latestLabel\"][\"id\"]\n\n        system_chat_item = []\n        if system_prompt:\n            system_chat_item = self.kili_api_gateway.create_chat_item(\n                asset_id=asset_id, label_id=label_id, prompt=system_prompt, role=ChatItemRole.SYSTEM\n            )\n\n        parent_id = system_chat_item[0][\"id\"] if system_chat_item else None\n        prompt_chat_item = self.kili_api_gateway.create_chat_item(\n            asset_id=asset_id,\n            label_id=label_id,\n            prompt=initial_prompt,\n            role=ChatItemRole.USER,\n            parent_id=parent_id,\n        )\n\n        return system_chat_item + prompt_chat_item\n</code></pre>"},{"location":"sdk/llm/#kili.llm.presentation.client.llm.LlmClientMethods.create_conversation","title":"<code>create_conversation(self, project_id, initial_prompt, system_prompt=None)</code>","text":"<p>Create a new conversation in an LLM project starting with a user's prompt.</p> <p>This method initiates a new conversation in the specified project by: - Creating an LLM asset and label associated with the current user. - Adding the user's prompt as the first chat item. - Automatically generating assistant responses using the project's models.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The identifier of the project where the conversation will be created.</p> required <code>initial_prompt</code> <code>str</code> <p>The initial prompt or message from the user to start the conversation.</p> required <code>system_prompt</code> <code>Optional[str]</code> <p>Optional system prompt to guide the assistant's responses.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[kili_formats.types.ChatItem]</code> <p>A list of chat items in the conversation, including the user's prompts and the assistant's responses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PROMPT = \"Hello, how can I improve my coding skills?\"\n&gt;&gt;&gt; chat_items = kili.llm.create_conversation(project_id=\"your_project_id\", prompt=PROMPT)\n</code></pre> <p>Notes</p> <ul> <li>The first chat item corresponds to the user's prompt.</li> <li>The subsequent chat items are assistant responses generated by the project's models.</li> <li>An LLM asset and a label are created in the project with labelType \"PREDICTION\".</li> </ul> Source code in <code>kili/llm/presentation/client/llm.py</code> <pre><code>def create_conversation(\n    self, project_id: str, initial_prompt: str, system_prompt: Optional[str] = None\n) -&gt; List[ChatItem]:\n    \"\"\"Create a new conversation in an LLM project starting with a user's prompt.\n\n    This method initiates a new conversation in the specified project by:\n    - Creating an LLM asset and label associated with the current user.\n    - Adding the user's prompt as the first chat item.\n    - Automatically generating assistant responses using the project's models.\n\n    Args:\n        project_id: The identifier of the project where the conversation will be created.\n        initial_prompt: The initial prompt or message from the user to start the conversation.\n        system_prompt: Optional system prompt to guide the assistant's responses.\n\n    Returns:\n        A list of chat items in the conversation, including the user's prompts and the assistant's responses.\n\n    Examples:\n        &gt;&gt;&gt; PROMPT = \"Hello, how can I improve my coding skills?\"\n        &gt;&gt;&gt; chat_items = kili.llm.create_conversation(project_id=\"your_project_id\", prompt=PROMPT)\n\n    Notes:\n        - The first chat item corresponds to the user's prompt.\n        - The subsequent chat items are assistant responses generated by the project's models.\n        - An LLM asset and a label are created in the project with labelType \"PREDICTION\".\n    \"\"\"\n    user_id = self.kili_api_gateway.get_current_user([\"id\"])[\"id\"]\n    llm_asset = self.kili_api_gateway.create_llm_asset(\n        project_id=project_id,\n        author_id=user_id,\n        label_type=\"PREDICTION\",\n    )\n    asset_id = llm_asset[\"id\"]\n    label_id = llm_asset[\"latestLabel\"][\"id\"]\n\n    system_chat_item = []\n    if system_prompt:\n        system_chat_item = self.kili_api_gateway.create_chat_item(\n            asset_id=asset_id, label_id=label_id, prompt=system_prompt, role=ChatItemRole.SYSTEM\n        )\n\n    parent_id = system_chat_item[0][\"id\"] if system_chat_item else None\n    prompt_chat_item = self.kili_api_gateway.create_chat_item(\n        asset_id=asset_id,\n        label_id=label_id,\n        prompt=initial_prompt,\n        role=ChatItemRole.USER,\n        parent_id=parent_id,\n    )\n\n    return system_chat_item + prompt_chat_item\n</code></pre>"},{"location":"sdk/llm/#kili.llm.presentation.client.llm.LlmClientMethods.create_model","title":"<code>create_model(self, organization_id, model)</code>","text":"<p>Create a new model in an organization.</p> <p>Parameters:</p> Name Type Description Default <code>organization_id</code> <code>str</code> <p>Identifier of the organization.</p> required <code>model</code> <code>dict</code> <p>A dictionary representing the model to create, containing: - <code>name</code>: Name of the model. - <code>type</code>: Type of the model, one of:     - <code>\"AZURE_OPEN_AI\"</code>     - <code>\"OPEN_AI_SDK\"</code> - <code>credentials</code>: Credentials required for the model, depending on the type:     - For <code>\"AZURE_OPEN_AI\"</code> type:         - <code>api_key</code>: The API key for Azure OpenAI.         - <code>deployment_id</code>: The deployment ID within Azure.         - <code>endpoint</code>: The endpoint URL of the Azure OpenAI service.     - For <code>\"OPEN_AI_SDK\"</code> type:         - <code>api_key</code>: The API key for OpenAI SDK.         - <code>endpoint</code>: The endpoint URL of the OpenAI SDK service.</p> required <p>Returns:</p> Type Description <code>ModelDict</code> <p>A dictionary containing the created model's details.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Example of creating an OpenAI SDK model\n&gt;&gt;&gt; model_data = {\n...     \"name\": \"My OpenAI SDK Model\",\n...     \"type\": \"OPEN_AI_SDK\",\n...     \"credentials\": {\n...         \"api_key\": \"your_open_ai_api_key\",\n...         \"endpoint\": \"your_open_ai_endpoint\"\n...     }\n... }\n&gt;&gt;&gt; kili.llm.create_model(organization_id=\"your_organization_id\", model=model_data)\n</code></pre> Source code in <code>kili/llm/presentation/client/llm.py</code> <pre><code>def create_model(self, organization_id: str, model: dict) -&gt; ModelDict:\n    \"\"\"Create a new model in an organization.\n\n    Args:\n        organization_id: Identifier of the organization.\n        model: A dictionary representing the model to create, containing:\n            - `name`: Name of the model.\n            - `type`: Type of the model, one of:\n                - `\"AZURE_OPEN_AI\"`\n                - `\"OPEN_AI_SDK\"`\n            - `credentials`: Credentials required for the model, depending on the type:\n                - For `\"AZURE_OPEN_AI\"` type:\n                    - `api_key`: The API key for Azure OpenAI.\n                    - `deployment_id`: The deployment ID within Azure.\n                    - `endpoint`: The endpoint URL of the Azure OpenAI service.\n                - For `\"OPEN_AI_SDK\"` type:\n                    - `api_key`: The API key for OpenAI SDK.\n                    - `endpoint`: The endpoint URL of the OpenAI SDK service.\n\n    Returns:\n        A dictionary containing the created model's details.\n\n    Examples:\n        &gt;&gt;&gt; # Example of creating an OpenAI SDK model\n        &gt;&gt;&gt; model_data = {\n        ...     \"name\": \"My OpenAI SDK Model\",\n        ...     \"type\": \"OPEN_AI_SDK\",\n        ...     \"credentials\": {\n        ...         \"api_key\": \"your_open_ai_api_key\",\n        ...         \"endpoint\": \"your_open_ai_endpoint\"\n        ...     }\n        ... }\n        &gt;&gt;&gt; kili.llm.create_model(organization_id=\"your_organization_id\", model=model_data)\n    \"\"\"\n    credentials_data = model[\"credentials\"]\n    model_type = ModelType(model[\"type\"])\n\n    if model_type == ModelType.AZURE_OPEN_AI:\n        credentials = AzureOpenAICredentials(**credentials_data)\n    elif model_type == ModelType.OPEN_AI_SDK:\n        credentials = OpenAISDKCredentials(**credentials_data)\n    else:\n        raise ValueError(f\"Unsupported model type: {model['type']}\")\n\n    model_input = ModelToCreateInput(\n        credentials=credentials,\n        name=model[\"name\"],\n        type=model_type,\n        organization_id=organization_id,\n    )\n    return self.kili_api_gateway.create_model(model=model_input)\n</code></pre>"},{"location":"sdk/llm/#kili.llm.presentation.client.llm.LlmClientMethods.create_project_model","title":"<code>create_project_model(self, project_id, model_id, configuration)</code>","text":"<p>Associate a model with a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>model_id</code> <code>str</code> <p>Identifier of the model to associate.</p> required <code>configuration</code> <code>dict</code> <p>Configuration parameters for the project model.</p> required <p>Returns:</p> Type Description <code>ProjectModelDict</code> <p>A dictionary containing the created project model's details.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; configuration = {\n...     # Configuration details specific to your use case\n... }\n&gt;&gt;&gt; kili.llm.create_project_model(\n...     project_id=\"your_project_id\",\n...     model_id=\"your_model_id\",\n...     configuration={\"temperature\": 0.7}\n... )\n</code></pre> Source code in <code>kili/llm/presentation/client/llm.py</code> <pre><code>def create_project_model(\n    self, project_id: str, model_id: str, configuration: dict\n) -&gt; ProjectModelDict:\n    \"\"\"Associate a model with a project.\n\n    Args:\n        project_id: Identifier of the project.\n        model_id: Identifier of the model to associate.\n        configuration: Configuration parameters for the project model.\n\n    Returns:\n        A dictionary containing the created project model's details.\n\n    Examples:\n        &gt;&gt;&gt; configuration = {\n        ...     # Configuration details specific to your use case\n        ... }\n        &gt;&gt;&gt; kili.llm.create_project_model(\n        ...     project_id=\"your_project_id\",\n        ...     model_id=\"your_model_id\",\n        ...     configuration={\"temperature\": 0.7}\n        ... )\n    \"\"\"\n    project_model_input = ProjectModelToCreateInput(\n        project_id=project_id, model_id=model_id, configuration=configuration\n    )\n    return self.kili_api_gateway.create_project_model(project_model=project_model_input)\n</code></pre>"},{"location":"sdk/llm/#kili.llm.presentation.client.llm.LlmClientMethods.delete_model","title":"<code>delete_model(self, model_id)</code>","text":"<p>Delete a model from an organization.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>str</code> <p>Identifier of the model to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A dictionary indicating the result of the deletion.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.llm.delete_model(model_id=\"your_model_id\")\n</code></pre> Source code in <code>kili/llm/presentation/client/llm.py</code> <pre><code>def delete_model(self, model_id: str) -&gt; bool:\n    \"\"\"Delete a model from an organization.\n\n    Args:\n        model_id: Identifier of the model to delete.\n\n    Returns:\n        A dictionary indicating the result of the deletion.\n\n    Examples:\n        &gt;&gt;&gt; kili.llm.delete_model(model_id=\"your_model_id\")\n    \"\"\"\n    return self.kili_api_gateway.delete_model(model_id=model_id)\n</code></pre>"},{"location":"sdk/llm/#kili.llm.presentation.client.llm.LlmClientMethods.delete_project_model","title":"<code>delete_project_model(self, project_model_id)</code>","text":"<p>Delete a project model.</p> <p>Parameters:</p> Name Type Description Default <code>project_model_id</code> <code>str</code> <p>Identifier of the project model to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A dictionary indicating the result of the deletion.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.llm.delete_project_model(project_model_id=\"your_project_model_id\")\n</code></pre> Source code in <code>kili/llm/presentation/client/llm.py</code> <pre><code>def delete_project_model(self, project_model_id: str) -&gt; bool:\n    \"\"\"Delete a project model.\n\n    Args:\n        project_model_id: Identifier of the project model to delete.\n\n    Returns:\n        A dictionary indicating the result of the deletion.\n\n    Examples:\n        &gt;&gt;&gt; kili.llm.delete_project_model(project_model_id=\"your_project_model_id\")\n    \"\"\"\n    return self.kili_api_gateway.delete_project_model(project_model_id)\n</code></pre>"},{"location":"sdk/llm/#kili.llm.presentation.client.llm.LlmClientMethods.export","title":"<code>export(self, project_id, disable_tqdm=False, asset_ids=None, external_ids=None, include_sent_back_labels=False, label_type_in=None, status_in=None, step_name_in=None, step_status_in=None)</code>","text":"<p>Returns an export of llm conversations with valid labels.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_ids</code> <code>Optional[List[str]]</code> <p>Optional list of the assets internal IDs from which to export the labels.</p> <code>None</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>Disable the progress bar if True.</p> <code>False</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>Optional list of the assets external IDs from which to export the labels.</p> <code>None</code> <code>include_sent_back_labels</code> <code>Optional[bool]</code> <p>Include sent back labels if True.</p> <code>False</code> <code>label_type_in</code> <code>Optional[List[Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW']]]</code> <p>Optional types of label to fetch, by default [\"DEFAULT\", \"REVIEW\"].</p> <code>None</code> <code>status_in</code> <code>Optional[List[Literal['TODO', 'ONGOING', 'LABELED', 'REVIEWED', 'TO_REVIEW']]]</code> <p>Returned assets should have a status that belongs to that list, if given. Possible choices: <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO_REVIEW</code> or <code>REVIEWED</code>.</p> <code>None</code> <code>step_name_in</code> <code>Optional[List[str]]</code> <p>Returned assets are in a step whose name belong to that list, if given. Only applicable if the project is in WorkflowV2.</p> <code>None</code> <code>step_status_in</code> <code>Optional[List[Literal['TO_DO', 'DOING', 'PARTIALLY_DONE', 'REDO', 'DONE', 'SKIPPED']]]</code> <p>Returned assets have the status of their step that belongs to that list, if given. Possible choices: <code>TO_DO</code>, <code>DOING</code>, <code>PARTIALLY_DONE</code>, <code>REDO</code>, <code>DONE</code>, <code>SKIPPED</code>. Only applicable if the project is in WorkflowV2.</p> <code>None</code> <p>Example</p> <pre><code>kili.llm.export(\"your_project_id\")\n</code></pre> Source code in <code>kili/llm/presentation/client/llm.py</code> <pre><code>def export(\n    self,\n    project_id: str,\n    disable_tqdm: Optional[bool] = False,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    include_sent_back_labels: Optional[bool] = False,\n    label_type_in: Optional[List[LabelType]] = None,\n    status_in: Optional[List[AssetStatus]] = None,\n    step_name_in: Optional[List[str]] = None,\n    step_status_in: Optional[List[StatusInStep]] = None,\n) -&gt; Optional[Union[List[Conversation], List[Dict[str, Union[List[str], str]]]]]:\n    \"\"\"Returns an export of llm conversations with valid labels.\n\n    Args:\n        project_id: Identifier of the project.\n        asset_ids: Optional list of the assets internal IDs from which to export the labels.\n        disable_tqdm: Disable the progress bar if True.\n        external_ids: Optional list of the assets external IDs from which to export the labels.\n        include_sent_back_labels: Include sent back labels if True.\n        label_type_in: Optional types of label to fetch, by default [\"DEFAULT\", \"REVIEW\"].\n        status_in: Returned assets should have a status that belongs to that list, if given.\n            Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED`.\n        step_name_in: Returned assets are in a step whose name belong to that list, if given.\n            Only applicable if the project is in WorkflowV2.\n        step_status_in: Returned assets have the status of their step that belongs to that list, if given.\n            Possible choices: `TO_DO`, `DOING`, `PARTIALLY_DONE`, `REDO`, `DONE`, `SKIPPED`.\n            Only applicable if the project is in WorkflowV2.\n    !!! Example\n        ```python\n        kili.llm.export(\"your_project_id\")\n        ```\n    \"\"\"\n    if asset_ids and external_ids:\n        raise ValueError(\"You cannot provide both asset_ids and external_ids\")\n\n    if external_ids is not None and asset_ids is None:\n        id_map = AssetUseCasesUtils(self.kili_api_gateway).infer_ids_from_external_ids(\n            asset_external_ids=cast(List[AssetExternalId], external_ids),\n            project_id=ProjectId(project_id),\n        )\n        resolved_asset_ids = [id_map[AssetExternalId(i)] for i in external_ids]\n    else:\n        resolved_asset_ids = (\n            list(AssetId(asset_id) for asset_id in asset_ids) if asset_ids else None\n        )\n\n    label_type_in = label_type_in or [\"DEFAULT\", \"REVIEW\"]\n\n    step_id_in = None\n\n    if status_in is not None or step_name_in is not None or step_status_in is not None:\n        project_use_cases = ProjectUseCases(self.kili_api_gateway)\n        (\n            project_steps,\n            project_workflow_version,\n        ) = project_use_cases.get_project_steps_and_version(project_id)\n        check_asset_workflow_arguments(\n            project_workflow_version=project_workflow_version,\n            asset_workflow_filters={\n                \"skipped\": None,\n                \"status_in\": status_in,\n                \"step_name_in\": step_name_in,\n                \"step_status_in\": step_status_in,\n            },\n        )\n\n        if project_workflow_version == \"V2\" and step_name_in is not None:\n            step_id_in = extract_step_ids_from_project_steps(\n                project_steps=project_steps,\n                step_name_in=step_name_in,\n            )\n\n    asset_filter = AssetFilters(\n        project_id=ProjectId(project_id),\n        asset_id_in=resolved_asset_ids,\n        label_type_in=label_type_in,\n        status_in=status_in,\n        step_id_in=step_id_in,\n        step_status_in=step_status_in,\n    )\n\n    try:\n        return export(\n            self.kili_api_gateway,\n            project_id=ProjectId(project_id),\n            asset_filter=asset_filter,\n            disable_tqdm=disable_tqdm,\n            include_sent_back_labels=include_sent_back_labels,\n            label_type_in=label_type_in,\n        )\n    except NoCompatibleJobError as excp:\n        warnings.warn(str(excp), stacklevel=2)\n        return None\n</code></pre>"},{"location":"sdk/llm/#kili.llm.presentation.client.llm.LlmClientMethods.import_conversations","title":"<code>import_conversations(self, project_id, conversations)</code>","text":"<p>Import conversations into a LLM Static project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>conversations</code> <code>List[kili_formats.types.Conversation]</code> <p>List of conversations to import. Each conversation should be a dictionary with the following keys - <code>chatItems</code>: List of chat items in the conversation. Each chat item should be a dictionary with the following keys     - <code>content</code>: (required) Content of the chat item.     - <code>externalId</code>: (required) Identifier of the chat item (must be unique).     - <code>modelName</code>: Name of the model that generated the chat item. Required only for ASSISTANT chat items.     - <code>role</code>: (required) Role of the chat item, one of <code>SYSTEM</code>, <code>USER</code> or <code>ASSISTANT</code>. - <code>externalId</code>: (required) Identifier of the conversation (must be unique). - <code>label</code>: (optional) Label associated with the conversation. Should be a dictionary with the following keys     - <code>conversation</code>     - <code>completion</code>     - <code>round</code> - <code>labeler</code>: (optional) Email of the labeler associated with the conversation. - <code>metadata</code>: (optional) Additional metadata associated with the conversation.</p> required <p>Returns:</p> Type Description <code>A dict containing following keys - `numberOfUploadedAssets`</code> <p>Number of assets uploaded. - <code>warnings</code>: List of detailed warnings generated during the import process, for each conversation.</p> Source code in <code>kili/llm/presentation/client/llm.py</code> <pre><code>def import_conversations(\n    self,\n    project_id: str,\n    conversations: List[Conversation],\n):\n    \"\"\"Import conversations into a LLM Static project.\n\n    Args:\n        project_id: Identifier of the project.\n        conversations: List of conversations to import. Each conversation should be a dictionary with the following keys\n            - `chatItems`: List of chat items in the conversation. Each chat item should be a dictionary with the following keys\n                - `content`: (required) Content of the chat item.\n                - `externalId`: (required) Identifier of the chat item (must be unique).\n                - `modelName`: Name of the model that generated the chat item. Required only for ASSISTANT chat items.\n                - `role`: (required) Role of the chat item, one of `SYSTEM`, `USER` or `ASSISTANT`.\n            - `externalId`: (required) Identifier of the conversation (must be unique).\n            - `label`: (optional) Label associated with the conversation. Should be a dictionary with the following keys\n                - `conversation`\n                - `completion`\n                - `round`\n            - `labeler`: (optional) Email of the labeler associated with the conversation.\n            - `metadata`: (optional) Additional metadata associated with the conversation.\n\n    Returns:\n        A dict containing following keys\n        - `numberOfUploadedAssets`: Number of assets uploaded.\n        - `warnings`: List of detailed warnings generated during the import process, for each conversation.\n    \"\"\"\n    return self.kili_api_gateway.import_conversations(\n        project_id=project_id, conversations=conversations\n    )\n</code></pre>"},{"location":"sdk/llm/#kili.llm.presentation.client.llm.LlmClientMethods.list_chat_items","title":"<code>list_chat_items(self, asset_id)</code>","text":"<p>List chat items associated with an asset.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id</code> <code>str</code> <p>Identifier of the asset.</p> required <p>Returns:</p> Type Description <code>List[kili_formats.types.ChatItem]</code> <p>A list of chat items associated with the asset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.llm.list_chat_items(asset_id=\"your_asset_id\")\n</code></pre> Source code in <code>kili/llm/presentation/client/llm.py</code> <pre><code>def list_chat_items(self, asset_id: str) -&gt; List[ChatItem]:\n    \"\"\"List chat items associated with an asset.\n\n    Args:\n        asset_id: Identifier of the asset.\n\n    Returns:\n        A list of chat items associated with the asset.\n\n    Examples:\n        &gt;&gt;&gt; kili.llm.list_chat_items(asset_id=\"your_asset_id\")\n    \"\"\"\n    return self.kili_api_gateway.list_chat_items(asset_id=asset_id)\n</code></pre>"},{"location":"sdk/llm/#kili.llm.presentation.client.llm.LlmClientMethods.model","title":"<code>model(self, model_id, fields=None)</code>","text":"<p>Retrieve a specific model.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>str</code> <p>Identifier of the model.</p> required <code>fields</code> <code>Optional[List[str]]</code> <p>All the fields to request among the possible fields for the models. Defaults to [\"id\", \"credentials\", \"name\", \"type\"].</p> <code>None</code> <p>Returns:</p> Type Description <code>ModelDict</code> <p>A dictionary representing the model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.llm.model(model_id=\"your_model_id\")\n</code></pre> Source code in <code>kili/llm/presentation/client/llm.py</code> <pre><code>def model(self, model_id: str, fields: Optional[List[str]] = None) -&gt; ModelDict:\n    \"\"\"Retrieve a specific model.\n\n    Args:\n        model_id: Identifier of the model.\n        fields: All the fields to request among the possible fields for the models.\n            Defaults to [\"id\", \"credentials\", \"name\", \"type\"].\n\n    Returns:\n        A dictionary representing the model.\n\n    Examples:\n        &gt;&gt;&gt; kili.llm.model(model_id=\"your_model_id\")\n    \"\"\"\n    return self.kili_api_gateway.get_model(\n        model_id=model_id,\n        fields=fields,\n    )\n</code></pre>"},{"location":"sdk/llm/#kili.llm.presentation.client.llm.LlmClientMethods.models","title":"<code>models(self, organization_id, fields=None)</code>","text":"<p>List models in an organization.</p> <p>Parameters:</p> Name Type Description Default <code>organization_id</code> <code>str</code> <p>Identifier of the organization.</p> required <code>fields</code> <code>Optional[List[str]]</code> <p>All the fields to request among the possible fields for the models. Defaults to [\"id\", \"credentials\", \"name\", \"type\"].</p> <code>None</code> <p>Returns:</p> Type Description <code>List[kili.domain.llm.ModelDict]</code> <p>A list of models.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.llm.models(organization_id=\"your_organization_id\")\n</code></pre> Source code in <code>kili/llm/presentation/client/llm.py</code> <pre><code>def models(self, organization_id: str, fields: Optional[List[str]] = None) -&gt; List[ModelDict]:\n    \"\"\"List models in an organization.\n\n    Args:\n        organization_id: Identifier of the organization.\n        fields: All the fields to request among the possible fields for the models.\n            Defaults to [\"id\", \"credentials\", \"name\", \"type\"].\n\n    Returns:\n        A list of models.\n\n    Examples:\n        &gt;&gt;&gt; kili.llm.models(organization_id=\"your_organization_id\")\n    \"\"\"\n    converted_filters = OrganizationModelFilters(\n        organization_id=organization_id,\n    )\n\n    return list(self.kili_api_gateway.list_models(filters=converted_filters, fields=fields))\n</code></pre>"},{"location":"sdk/llm/#kili.llm.presentation.client.llm.LlmClientMethods.project_models","title":"<code>project_models(self, project_id, filters=None, fields=None)</code>","text":"<p>List models associated with a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>filters</code> <code>Optional[Dict]</code> <p>Optional filters to apply. Possible keys: - <code>model_id</code>: Identifier of a specific model to filter by.</p> <code>None</code> <code>fields</code> <code>Optional[List[str]]</code> <p>All the fields to request among the possible fields for the project models. Defaults to [\"configuration\", \"id\", \"model.credentials\", \"model.name\", \"model.type\"].</p> <code>None</code> <p>Returns:</p> Type Description <code>List[kili.domain.llm.ProjectModelDict]</code> <p>A list of project models.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.llm.project_models(project_id=\"your_project_id\")\n</code></pre> Source code in <code>kili/llm/presentation/client/llm.py</code> <pre><code>def project_models(\n    self, project_id: str, filters: Optional[Dict] = None, fields: Optional[List[str]] = None\n) -&gt; List[ProjectModelDict]:\n    \"\"\"List models associated with a project.\n\n    Args:\n        project_id: Identifier of the project.\n        filters: Optional filters to apply. Possible keys:\n            - `model_id`: Identifier of a specific model to filter by.\n        fields: All the fields to request among the possible fields for the project models.\n            Defaults to [\"configuration\", \"id\", \"model.credentials\", \"model.name\", \"model.type\"].\n\n    Returns:\n        A list of project models.\n\n    Examples:\n        &gt;&gt;&gt; kili.llm.project_models(project_id=\"your_project_id\")\n    \"\"\"\n    converted_filters = ProjectModelFilters(\n        project_id=project_id,\n        model_id=filters[\"model_id\"] if filters and \"model_id\" in filters else None,\n    )\n\n    return list(\n        self.kili_api_gateway.list_project_models(\n            filters=converted_filters,\n            fields=fields,\n        )\n    )\n</code></pre>"},{"location":"sdk/llm/#kili.llm.presentation.client.llm.LlmClientMethods.update_project_model","title":"<code>update_project_model(self, project_model_id, configuration)</code>","text":"<p>Update the configuration of a project model.</p> <p>Parameters:</p> Name Type Description Default <code>project_model_id</code> <code>str</code> <p>Identifier of the project model to update.</p> required <code>configuration</code> <code>dict</code> <p>New configuration parameters.</p> required <p>Returns:</p> Type Description <code>ProjectModelDict</code> <p>A dictionary containing the updated project model's details.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; configuration = {\n...     # Updated configuration details\n... }\n&gt;&gt;&gt; kili.llm.update_project_model(\n...     project_model_id=\"your_project_model_id\",\n...     configuration=configuration\n... )\n</code></pre> Source code in <code>kili/llm/presentation/client/llm.py</code> <pre><code>def update_project_model(self, project_model_id: str, configuration: dict) -&gt; ProjectModelDict:\n    \"\"\"Update the configuration of a project model.\n\n    Args:\n        project_model_id: Identifier of the project model to update.\n        configuration: New configuration parameters.\n\n    Returns:\n        A dictionary containing the updated project model's details.\n\n    Examples:\n        &gt;&gt;&gt; configuration = {\n        ...     # Updated configuration details\n        ... }\n        &gt;&gt;&gt; kili.llm.update_project_model(\n        ...     project_model_id=\"your_project_model_id\",\n        ...     configuration=configuration\n        ... )\n    \"\"\"\n    project_model_input = ProjectModelToUpdateInput(configuration=configuration)\n    return self.kili_api_gateway.update_project_model(\n        project_model_id=project_model_id, project_model=project_model_input\n    )\n</code></pre>"},{"location":"sdk/llm/#kili.llm.presentation.client.llm.LlmClientMethods.update_properties_in_model","title":"<code>update_properties_in_model(self, model_id, model)</code>","text":"<p>Update properties of an existing model.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>str</code> <p>Identifier of the model to update.</p> required <code>model</code> <code>dict</code> <p>A dictionary containing the properties to update, which may include: - <code>name</code>: New name of the model. - <code>credentials</code>: Updated credentials for the model, depending on the type:     - For <code>\"AZURE_OPEN_AI\"</code> type:         - <code>api_key</code>: The API key for Azure OpenAI.         - <code>deployment_id</code>: The deployment ID within Azure.         - <code>endpoint</code>: The endpoint URL of the Azure OpenAI service.     - For <code>\"OPEN_AI_SDK\"</code> type:         - <code>api_key</code>: The API key for OpenAI SDK.         - <code>endpoint</code>: The endpoint URL of the OpenAI SDK service.</p> required <p>Returns:</p> Type Description <code>ModelDict</code> <p>A dictionary containing the updated model's details.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Update the name of a model\n&gt;&gt;&gt; kili.llm.update_properties_in_model(\n...     model_id=\"your_model_id\",\n...     model={\"name\": \"Updated Model Name\"}\n... )\n</code></pre> Source code in <code>kili/llm/presentation/client/llm.py</code> <pre><code>def update_properties_in_model(self, model_id: str, model: dict) -&gt; ModelDict:\n    \"\"\"Update properties of an existing model.\n\n    Args:\n        model_id: Identifier of the model to update.\n        model: A dictionary containing the properties to update, which may include:\n            - `name`: New name of the model.\n            - `credentials`: Updated credentials for the model, depending on the type:\n                - For `\"AZURE_OPEN_AI\"` type:\n                    - `api_key`: The API key for Azure OpenAI.\n                    - `deployment_id`: The deployment ID within Azure.\n                    - `endpoint`: The endpoint URL of the Azure OpenAI service.\n                - For `\"OPEN_AI_SDK\"` type:\n                    - `api_key`: The API key for OpenAI SDK.\n                    - `endpoint`: The endpoint URL of the OpenAI SDK service.\n\n    Returns:\n        A dictionary containing the updated model's details.\n\n    Examples:\n        &gt;&gt;&gt; # Update the name of a model\n        &gt;&gt;&gt; kili.llm.update_properties_in_model(\n        ...     model_id=\"your_model_id\",\n        ...     model={\"name\": \"Updated Model Name\"}\n        ... )\n    \"\"\"\n    credentials_data = model.get(\"credentials\")\n    credentials = None\n\n    if credentials_data:\n        existing_model = self.kili_api_gateway.get_model(\n            model_id=model_id, fields=[\"id\", \"type\"]\n        )\n        if not existing_model:\n            raise ValueError(f\"Model with id {model_id} not found\")\n        model_type = ModelType(existing_model[\"type\"])\n\n        if model_type == ModelType.AZURE_OPEN_AI:\n            credentials = AzureOpenAICredentials(**credentials_data)\n        elif model_type == ModelType.OPEN_AI_SDK:\n            credentials = OpenAISDKCredentials(**credentials_data)\n        else:\n            raise ValueError(f\"Unsupported model type: {model_type}\")\n\n    model_input = ModelToUpdateInput(\n        credentials=credentials,\n        name=model.get(\"name\"),\n    )\n    return self.kili_api_gateway.update_properties_in_model(\n        model_id=model_id, model=model_input\n    )\n</code></pre>"},{"location":"sdk/notification/","title":"Notification module","text":"<p>Methods attached to the Kili client, to run actions on notifications.</p> Source code in <code>kili/presentation/client/notification.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass NotificationClientMethods(BaseClientMethods):\n    \"\"\"Methods attached to the Kili client, to run actions on notifications.\"\"\"\n\n    @overload\n    def notifications(\n        self,\n        fields: ListOrTuple[str] = (\n            \"createdAt\",\n            \"hasBeenSeen\",\n            \"id\",\n            \"message\",\n            \"status\",\n            \"userID\",\n        ),\n        first: Optional[int] = None,\n        has_been_seen: Optional[bool] = None,\n        notification_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def notifications(\n        self,\n        fields: ListOrTuple[str] = (\n            \"createdAt\",\n            \"hasBeenSeen\",\n            \"id\",\n            \"message\",\n            \"status\",\n            \"userID\",\n        ),\n        first: Optional[int] = None,\n        has_been_seen: Optional[bool] = None,\n        notification_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def notifications(\n        self,\n        fields: ListOrTuple[str] = (\n            \"createdAt\",\n            \"hasBeenSeen\",\n            \"id\",\n            \"message\",\n            \"status\",\n            \"userID\",\n        ),\n        first: Optional[int] = None,\n        has_been_seen: Optional[bool] = None,\n        notification_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a generator or a list of notifications respecting a set of criteria.\n\n        Args:\n            fields: All the fields to request among the possible fields for the notifications\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/notification) for all possible fields.\n            first: Number of notifications to query\n            has_been_seen: If the notifications returned should have been seen.\n            notification_id: If given, will return the notification which has this id\n            skip: Number of notifications to skip (they are ordered by their date of creation,\n                first to last).\n            user_id: If given, returns the notifications of a specific user\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the notifications is returned.\n\n        Returns:\n            An iterable of notifications.\n        \"\"\"\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        filters = NotificationFilter(\n            has_been_seen=has_been_seen,\n            id=NotificationId(notification_id) if notification_id else None,\n            user=UserFilter(id=UserId(user_id)) if user_id else None,\n        )\n        notifications_gen = NotificationUseCases(self.kili_api_gateway).list_notifications(\n            options=options, fields=fields, filters=filters\n        )\n        if as_generator:\n            return notifications_gen\n        return list(notifications_gen)\n\n    @typechecked\n    def count_notifications(\n        self,\n        has_been_seen: Optional[bool] = None,\n        user_id: Optional[str] = None,\n        notification_id: Optional[str] = None,\n    ) -&gt; int:\n        \"\"\"Count the number of notifications.\n\n        Args:\n            has_been_seen: Filter on notifications that have been seen.\n            user_id: Filter on the notifications of a specific user.\n            notification_id: Filter on a specific notification.\n\n        Returns:\n            The number of notifications with the parameters provided\n        \"\"\"\n        filters = NotificationFilter(\n            has_been_seen=has_been_seen,\n            id=NotificationId(notification_id) if notification_id else None,\n            user=UserFilter(id=UserId(user_id)) if user_id else None,\n        )\n        return NotificationUseCases(self.kili_api_gateway).count_notifications(filters=filters)\n</code></pre>"},{"location":"sdk/notification/#kili.presentation.client.notification.NotificationClientMethods.count_notifications","title":"<code>count_notifications(self, has_been_seen=None, user_id=None, notification_id=None)</code>","text":"<p>Count the number of notifications.</p> <p>Parameters:</p> Name Type Description Default <code>has_been_seen</code> <code>Optional[bool]</code> <p>Filter on notifications that have been seen.</p> <code>None</code> <code>user_id</code> <code>Optional[str]</code> <p>Filter on the notifications of a specific user.</p> <code>None</code> <code>notification_id</code> <code>Optional[str]</code> <p>Filter on a specific notification.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of notifications with the parameters provided</p> Source code in <code>kili/presentation/client/notification.py</code> <pre><code>def count_notifications(\n    self,\n    has_been_seen: Optional[bool] = None,\n    user_id: Optional[str] = None,\n    notification_id: Optional[str] = None,\n) -&gt; int:\n    \"\"\"Count the number of notifications.\n\n    Args:\n        has_been_seen: Filter on notifications that have been seen.\n        user_id: Filter on the notifications of a specific user.\n        notification_id: Filter on a specific notification.\n\n    Returns:\n        The number of notifications with the parameters provided\n    \"\"\"\n    filters = NotificationFilter(\n        has_been_seen=has_been_seen,\n        id=NotificationId(notification_id) if notification_id else None,\n        user=UserFilter(id=UserId(user_id)) if user_id else None,\n    )\n    return NotificationUseCases(self.kili_api_gateway).count_notifications(filters=filters)\n</code></pre>"},{"location":"sdk/notification/#kili.presentation.client.notification.NotificationClientMethods.notifications","title":"<code>notifications(self, fields=('createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID'), first=None, has_been_seen=None, notification_id=None, skip=0, user_id=None, disable_tqdm=None, *, as_generator=False)</code>","text":"<p>Get a generator or a list of notifications respecting a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the notifications See the documentation for all possible fields.</p> <code>('createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID')</code> <code>first</code> <code>Optional[int]</code> <p>Number of notifications to query</p> <code>None</code> <code>has_been_seen</code> <code>Optional[bool]</code> <p>If the notifications returned should have been seen.</p> <code>None</code> <code>notification_id</code> <code>Optional[str]</code> <p>If given, will return the notification which has this id</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of notifications to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>user_id</code> <code>Optional[str]</code> <p>If given, returns the notifications of a specific user</p> <code>None</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>None</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the notifications is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>An iterable of notifications.</p> Source code in <code>kili/presentation/client/notification.py</code> <pre><code>def notifications(\n    self,\n    fields: ListOrTuple[str] = (\n        \"createdAt\",\n        \"hasBeenSeen\",\n        \"id\",\n        \"message\",\n        \"status\",\n        \"userID\",\n    ),\n    first: Optional[int] = None,\n    has_been_seen: Optional[bool] = None,\n    notification_id: Optional[str] = None,\n    skip: int = 0,\n    user_id: Optional[str] = None,\n    disable_tqdm: Optional[bool] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a generator or a list of notifications respecting a set of criteria.\n\n    Args:\n        fields: All the fields to request among the possible fields for the notifications\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/notification) for all possible fields.\n        first: Number of notifications to query\n        has_been_seen: If the notifications returned should have been seen.\n        notification_id: If given, will return the notification which has this id\n        skip: Number of notifications to skip (they are ordered by their date of creation,\n            first to last).\n        user_id: If given, returns the notifications of a specific user\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the notifications is returned.\n\n    Returns:\n        An iterable of notifications.\n    \"\"\"\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    filters = NotificationFilter(\n        has_been_seen=has_been_seen,\n        id=NotificationId(notification_id) if notification_id else None,\n        user=UserFilter(id=UserId(user_id)) if user_id else None,\n    )\n    notifications_gen = NotificationUseCases(self.kili_api_gateway).list_notifications(\n        options=options, fields=fields, filters=filters\n    )\n    if as_generator:\n        return notifications_gen\n    return list(notifications_gen)\n</code></pre>"},{"location":"sdk/organization/","title":"Organization module","text":"<p>Organization client methods.</p> Source code in <code>kili/presentation/client/organization.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass OrganizationClientMethods(BaseClientMethods):\n    \"\"\"Organization client methods.\"\"\"\n\n    @overload\n    def organizations(\n        self,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\"id\", \"name\"),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def organizations(\n        self,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\"id\", \"name\"),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def organizations(\n        self,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\"id\", \"name\"),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a generator or a list of organizations that match a set of criteria.\n\n        Args:\n            email: Email of a user of the organization\n            organization_id: Identifier of the organization\n            fields: All the fields to request among the possible fields for the organizations.\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/organization) for all possible fields.\n            first: Maximum number of organizations to return.\n            skip: Number of skipped organizations (they are ordered by creation date)\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the organizations is returned.\n\n        Returns:\n            An iterable of organizations.\n\n        Examples:\n            &gt;&gt;&gt; kili.organizations(organization_id=organization_id, fields=['users.email'])\n            [{'users': [{'email': 'john@doe.com'}]}]\n        \"\"\"\n        organization_use_cases = OrganizationUseCases(self.kili_api_gateway)\n        organization_gen = organization_use_cases.list_organizations(\n            OrganizationFilters(\n                email=email,\n                organization_id=OrganizationId(organization_id) if organization_id else None,\n            ),\n            fields,\n            QueryOptions(disable_tqdm=disable_tqdm, first=first, skip=skip),\n        )\n\n        if as_generator:\n            return organization_gen\n        return list(organization_gen)\n\n    @typechecked\n    def count_organizations(\n        self, email: Optional[str] = None, organization_id: Optional[str] = None\n    ) -&gt; int:\n        \"\"\"Count organizations that match a set of criteria.\n\n        Args:\n            email: Email of a user of the organization\n            organization_id: Identifier of the organization\n\n        Returns:\n            An integer corresponding to the number of organizations that match the criteria.\n        \"\"\"\n        where = OrganizationFilters(\n            email=email,\n            organization_id=OrganizationId(organization_id) if organization_id else None,\n        )\n        return OrganizationUseCases(self.kili_api_gateway).count_organizations(where)\n\n    @typechecked\n    def organization_metrics(\n        self,\n        organization_id: str,\n        start_date: Optional[datetime] = None,\n        end_date: Optional[datetime] = None,\n        fields: ListOrTuple[str] = (\n            \"numberOfAnnotations\",\n            \"numberOfHours\",\n            \"numberOfLabeledAssets\",\n        ),\n    ) -&gt; Dict:\n        \"\"\"Get organization metrics.\n\n        Args:\n            organization_id: Identifier of the organization\n            start_date: Start date of the metrics computation\n            end_date: End date of the metrics computation\n            fields: Fields to request for the organization metrics.\n\n        Returns:\n            A dictionary containing the metrics of the organization.\n        \"\"\"\n        if start_date is None:\n            start_date = datetime.now(tz=pytz.UTC)\n        if end_date is None:\n            end_date = datetime.now(tz=pytz.UTC)\n        filters = OrganizationMetricsFilters(\n            id=OrganizationId(organization_id), start_datetime=start_date, end_datetime=end_date\n        )\n\n        return OrganizationUseCases(self.kili_api_gateway).get_organization_metrics(filters, fields)\n</code></pre>"},{"location":"sdk/organization/#kili.presentation.client.organization.OrganizationClientMethods.count_organizations","title":"<code>count_organizations(self, email=None, organization_id=None)</code>","text":"<p>Count organizations that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>Optional[str]</code> <p>Email of a user of the organization</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the organization</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>An integer corresponding to the number of organizations that match the criteria.</p> Source code in <code>kili/presentation/client/organization.py</code> <pre><code>def count_organizations(\n    self, email: Optional[str] = None, organization_id: Optional[str] = None\n) -&gt; int:\n    \"\"\"Count organizations that match a set of criteria.\n\n    Args:\n        email: Email of a user of the organization\n        organization_id: Identifier of the organization\n\n    Returns:\n        An integer corresponding to the number of organizations that match the criteria.\n    \"\"\"\n    where = OrganizationFilters(\n        email=email,\n        organization_id=OrganizationId(organization_id) if organization_id else None,\n    )\n    return OrganizationUseCases(self.kili_api_gateway).count_organizations(where)\n</code></pre>"},{"location":"sdk/organization/#kili.presentation.client.organization.OrganizationClientMethods.organization_metrics","title":"<code>organization_metrics(self, organization_id, start_date=None, end_date=None, fields=('numberOfAnnotations', 'numberOfHours', 'numberOfLabeledAssets'))</code>","text":"<p>Get organization metrics.</p> <p>Parameters:</p> Name Type Description Default <code>organization_id</code> <code>str</code> <p>Identifier of the organization</p> required <code>start_date</code> <code>Optional[datetime.datetime]</code> <p>Start date of the metrics computation</p> <code>None</code> <code>end_date</code> <code>Optional[datetime.datetime]</code> <p>End date of the metrics computation</p> <code>None</code> <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Fields to request for the organization metrics.</p> <code>('numberOfAnnotations', 'numberOfHours', 'numberOfLabeledAssets')</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary containing the metrics of the organization.</p> Source code in <code>kili/presentation/client/organization.py</code> <pre><code>def organization_metrics(\n    self,\n    organization_id: str,\n    start_date: Optional[datetime] = None,\n    end_date: Optional[datetime] = None,\n    fields: ListOrTuple[str] = (\n        \"numberOfAnnotations\",\n        \"numberOfHours\",\n        \"numberOfLabeledAssets\",\n    ),\n) -&gt; Dict:\n    \"\"\"Get organization metrics.\n\n    Args:\n        organization_id: Identifier of the organization\n        start_date: Start date of the metrics computation\n        end_date: End date of the metrics computation\n        fields: Fields to request for the organization metrics.\n\n    Returns:\n        A dictionary containing the metrics of the organization.\n    \"\"\"\n    if start_date is None:\n        start_date = datetime.now(tz=pytz.UTC)\n    if end_date is None:\n        end_date = datetime.now(tz=pytz.UTC)\n    filters = OrganizationMetricsFilters(\n        id=OrganizationId(organization_id), start_datetime=start_date, end_datetime=end_date\n    )\n\n    return OrganizationUseCases(self.kili_api_gateway).get_organization_metrics(filters, fields)\n</code></pre>"},{"location":"sdk/organization/#kili.presentation.client.organization.OrganizationClientMethods.organizations","title":"<code>organizations(self, email=None, organization_id=None, fields=('id', 'name'), first=None, skip=0, disable_tqdm=None, *, as_generator=False)</code>","text":"<p>Get a generator or a list of organizations that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>Optional[str]</code> <p>Email of a user of the organization</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the organization</p> <code>None</code> <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the organizations. See the documentation for all possible fields.</p> <code>('id', 'name')</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of organizations to return.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of skipped organizations (they are ordered by creation date)</p> <code>0</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>None</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the organizations is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>An iterable of organizations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.organizations(organization_id=organization_id, fields=['users.email'])\n[{'users': [{'email': 'john@doe.com'}]}]\n</code></pre> Source code in <code>kili/presentation/client/organization.py</code> <pre><code>def organizations(\n    self,\n    email: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    fields: ListOrTuple[str] = (\"id\", \"name\"),\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: Optional[bool] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a generator or a list of organizations that match a set of criteria.\n\n    Args:\n        email: Email of a user of the organization\n        organization_id: Identifier of the organization\n        fields: All the fields to request among the possible fields for the organizations.\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/organization) for all possible fields.\n        first: Maximum number of organizations to return.\n        skip: Number of skipped organizations (they are ordered by creation date)\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the organizations is returned.\n\n    Returns:\n        An iterable of organizations.\n\n    Examples:\n        &gt;&gt;&gt; kili.organizations(organization_id=organization_id, fields=['users.email'])\n        [{'users': [{'email': 'john@doe.com'}]}]\n    \"\"\"\n    organization_use_cases = OrganizationUseCases(self.kili_api_gateway)\n    organization_gen = organization_use_cases.list_organizations(\n        OrganizationFilters(\n            email=email,\n            organization_id=OrganizationId(organization_id) if organization_id else None,\n        ),\n        fields,\n        QueryOptions(disable_tqdm=disable_tqdm, first=first, skip=skip),\n    )\n\n    if as_generator:\n        return organization_gen\n    return list(organization_gen)\n</code></pre>"},{"location":"sdk/plugins/","title":"Plugin module","text":""},{"location":"sdk/plugins/#plugins-structure","title":"Plugins structure","text":"<p>A plugin is an uploaded Python script triggered by an event. It can be defined as either :</p> <ul> <li>a single <code>python</code> file with everything inside</li> <li>a plugin module (a folder) containing multiple <code>python</code> files and a non mandatory <code>requirements.txt</code> file listing all the dependencies you need for you plugin (providing <code>requirements.txt</code> is not available for On-Premise deployments - see details below).</li> </ul> <p>In the case of the module type plugin, at the root of the folder a file named <code>main.py</code> is strictly necessary, as it serves as the entrypoint of the plugin. In this <code>main.py</code> file, you can import what you need from other <code>python</code> files in the folder. The structure of the folder can be the following (the only constraint being the presence of the <code>main.py</code> file):</p> <pre><code>plugin_folder\n|__ main.py\n|__ other_file.py\n|__ requirements.txt\n|\n|___helpers\n    |__ helper.py\n</code></pre> <p>The plugin you are going to upload has to contain a <code>class PluginHandler(PluginCore)</code> (in the case of the module type plugin it has to be inside <code>main.py</code>) that implements two methods for the different types of events:</p> <ul> <li><code>on_submit</code></li> <li><code>on_review</code></li> </ul> <p>These methods have a predefined set of parameters:</p> <ul> <li>the <code>label</code> submitted (a dictionary containing the fields of the GraphQL type Label)</li> <li>the <code>asset_id</code> of the asset labeled</li> </ul> <p>You can add custom methods in your class as well.</p> <p>Moreover, some attributes are directly available in the class:</p> <ul> <li><code>self.kili</code></li> <li><code>self.project_id</code></li> </ul> <p>Therefore, the skeleton of the plugin (of <code>main.py</code> in the case of the module type plugin) should look like this:</p> <pre><code>from typing import Dict\nimport numpy as np\n\nfrom kili.plugins import PluginCore\n\ndef custom_function():\n    # Do something...\n\nclass PluginHandler(PluginCore):\n    \"\"\"Custom plugin\"\"\"\n\n    def custom_method(self):\n        # Do something...\n\n    def on_review(self, label: Dict, asset_id: str) -&gt; None:\n        \"\"\"Dedicated handler for Review action\"\"\"\n        # Do something...\n\n    def on_submit(self, label: Dict, asset_id: str) -&gt; None:\n        \"\"\"Dedicated handler for Submit action\"\"\"\n        # Do something...\n</code></pre> <p>Note</p> <p>The plugins run has some limitations, it can use a maximum of 512 MB of ram and will timeout after 60 sec of run.</p>"},{"location":"sdk/plugins/#on-premise-deployment-details","title":"On-Premise deployment details","text":"<p>The plugins for the on-premise deployments work exactly the same as the plugins for the SaaS version of Kili, with only a few small exceptions :</p> <ol> <li>It's not possible to add custom python packages to your plugin with the help of the <code>requirements.txt</code> file, but we selected a list of the most useful packages that you can directly use, including :<ul> <li><code>numpy</code>, <code>pandas</code>, <code>scikit-learn</code>, <code>opencv-python-headless</code>, <code>Pillow</code>, <code>requests</code>, <code>uuid</code> and of course <code>kili</code></li> </ul> </li> <li>In order to save the logs during the execution of your plugin, you should only use the provided logger in the plugin class (the simple <code>print</code> function will not save the log). For an example, see the code below:</li> </ol> <pre><code>from logging import Logger\nfrom typing import Dict\nfrom kili.plugins import PluginCore\n\ndef custom_function(label: Dict, logger: Logger):\n    logger.info(\"Custom function called\")\n    # Do something...\n\nclass PluginHandler(PluginCore):\n    \"\"\"Custom plugin\"\"\"\n\n    def on_submit(self, label: Dict, asset_id: str) -&gt; None:\n        \"\"\"Dedicated handler for Submit action\"\"\"\n        self.logger.info(\"On Submit called\")\n        custom_function(label, self.logger)\n</code></pre>"},{"location":"sdk/plugins/#model-for-plugins","title":"Model for Plugins","text":"<p>Kili Plugin core class.</p> <p>Parameters:</p> Name Type Description Default <code>kili</code> <code>Kili</code> <p>kili instance that plugins can make use of</p> required <code>project_id</code> <code>str</code> <p>the project on which plugin is ran</p> required <p>Implements:</p> <pre><code>on_submit(self, label: Dict, asset_id: str)\non_review(self, label: Dict, asset_id: str)\non_custom_interface_click(self, label: Dict, asset_id: str)\non_project_updated(self, settings_updated: List[Dict])\non_send_back_to_queue(self, asset_id: str)\non_event(self, payload: Dict)\n</code></pre> <p>Warning</p> <p>if using a custom init, be sure to call super().init()</p> Source code in <code>kili/services/plugins/model.py</code> <pre><code>class PluginCore:\n    \"\"\"Kili Plugin core class.\n\n    Args:\n        kili: kili instance that plugins can make use of\n        project_id: the project on which plugin is ran\n\n    Implements:\n\n        on_submit(self, label: Dict, asset_id: str)\n        on_review(self, label: Dict, asset_id: str)\n        on_custom_interface_click(self, label: Dict, asset_id: str)\n        on_project_updated(self, settings_updated: List[Dict])\n        on_send_back_to_queue(self, asset_id: str)\n        on_event(self, payload: Dict)\n\n    !!! warning\n        if using a custom init, be sure to call super().__init__()\n    \"\"\"\n\n    logger: logging.Logger\n    kili: Kili\n    project_id: str\n\n    def __init__(\n        self, kili: Kili, project_id: str, logger: Optional[logging.Logger] = None\n    ) -&gt; None:\n        self.kili = kili\n        self.project_id = project_id\n        if logger:\n            self.logger = logger\n        else:\n            self.logger = get_logger()\n\n    def on_submit(\n        self,\n        label: Dict,\n        asset_id: str,\n    ) -&gt; None:\n        \"\"\"Handler for the submit action, triggered when a default label is submitted into Kili.\n\n        Args:\n            label: Label submitted to Kili: a dictionary containing the following fields:\n                `id`, `labelType`, `numberOfAnnotations`, `authorId`, `modelName`, `jsonResponse`,\n                `secondsToLabel`, `isSentBackToQueue`, `search` and some technical fields:\n                `createdAt`, `updatedAt`, `version`, `isLatestReviewLabelForUser`,\n                `isLatestLabelForUser`, `isLatestDefaultLabelForUser`,\n                `readPermissionsFromProject`.\n            asset_id: Id of the asset on which the label was submitted\n\n        !!! example\n            ```python\n            def on_submit(self, label: Dict, asset_id: str):\n                json_response = label.get('jsonResponse')\n                if label_is_respecting_business_rule(json_response):\n                    return\n                else:\n                    self.kili.send_back_to_queue(asset_ids=[asset_id])\n            ```\n        \"\"\"\n        # pylint: disable=unused-argument\n        self.logger.warning(\"Method not implemented. Define a custom on_submit on your plugin\")\n\n    def on_review(\n        self,\n        label: Dict,\n        asset_id: str,\n    ) -&gt; None:\n        \"\"\"Handler for the review action, triggered when a default label is reviewed on Kili.\n\n        Args:\n            label: Label submitted to Kili: a dictionary containing the following fields:\n                `id`, `labelType`, `numberOfAnnotations`, `authorId`, `modelName`, `jsonResponse`,\n                `secondsToLabel`, `isSentBackToQueue` and `search` (dictionary that has a field `id`\n                representing the id of the original label that was reviewed). It also contains some\n                technical fields: `createdAt`, `updatedAt`, `version`, `isLatestReviewLabelForUser`,\n                `isLatestLabelForUser`, `isLatestDefaultLabelForUser`, `readPermissionsFromProject`.\n            asset_id: Id of the asset on which the label was submitted\n\n        !!! example\n            ```python\n            def on_review(self, label: Dict, asset_id: str):\n                json_response = label.get('jsonResponse')\n                if label_is_respecting_business_rule(json_response):\n                    return\n                else:\n                    self.kili.send_back_to_queue(asset_ids=[asset_id])\n            ```\n        \"\"\"\n        # pylint: disable=unused-argument\n        self.logger.warning(\"Method not implemented. Define a custom on_review on your plugin\")\n\n    def on_custom_interface_click(\n        self,\n        label: Dict,\n        asset_id: str,\n    ) -&gt; None:\n        \"\"\"Handler for the custom interface click action.\n\n        !!! warning\n            This handler is in beta and is still in active development,\n            it should be used with caution.\n\n        Args:\n            label: Label submitted to Kili: a dictionary containing the following fields:\n                `id`, `jsonResponse`.\n            asset_id: id of the asset on which the action is called\n\n        !!! example\n            ```python\n            def on_custom_interface_click(self, label: Dict, asset_id: str):\n                json_response = label.get('jsonResponse')`\n                label_id = label.get('id')\n                issue = label_is_respecting_business_rule(json_response)\n                if !issue:\n                    return\n                else:\n                    self.kili.create_issues(\n                            project_id=self.project_id,\n                            label_id_array=[label_id],\n                            text_array=[issue]\n                        )\n            ```\n        \"\"\"\n        # pylint: disable=unused-argument\n        self.logger.warning(\"Handler is in active development.\")\n\n    def on_project_updated(\n        self,\n        settings_updated: List[Dict],\n    ) -&gt; None:\n        \"\"\"Handler for the project updated action.\n\n        Triggered when a project setting is updated on Kili.\n\n        !!! warning\n            This handler is in beta and is still in active development,\n            it should be used with caution.\n\n        Args:\n            settings_updated: Settings updated on the project a list of\n                dictionary containing the following fields:\n                `key`, `newValue`, `oldValue`.\n                !!! note\n                    key is one of the following: 'canNavigateBetweenAssets',\n                    'canSkipAsset', 'consensusTotCoverage', 'description',\n                    'inputType', 'instructions', 'isAnonymized', 'jsonInterface',\n                    'metadataTypes', 'minConsensusSize', 'reviewCoverage',\n                    'title', 'archivedAt', 'useHoneyPot'\n\n        !!! example\n            ```python\n            def on_project_updated(self, settings_updated: List[Dict]):\n                for setting in settings_updated:\n                    self.logger.info(setting)\n                    # this will print:\n                    # {'key': 'description', 'newValue': 'new desc', 'oldValue': 'old desc'}\n            ```\n        \"\"\"\n        # pylint: disable=unused-argument\n        self.logger.warning(\"Handler is in active development.\")\n\n    def on_send_back_to_queue(\n        self,\n        asset_id: str,\n    ) -&gt; None:\n        \"\"\"Handler for send back to queue.\n\n        Triggered when an asset is sent back to queue\n\n        !!! warning\n            This handler is in beta and is still in active development,\n            it should be used with caution.\n\n        Args:\n            asset_id: Id of the asset on which was sent back to queue\n\n        !!! example\n            ```python\n            def on_send_back_to_queue(self, asset_id: str):\n                self.logger.info(f\"Asset {asset_id} was sent back to queue\")\n            ```\n        \"\"\"\n        # pylint: disable=unused-argument\n        self.logger.warning(\"Handler is in active development.\")\n\n    def on_event(\n        self,\n        payload: Dict,\n    ) -&gt; None:\n        \"\"\"Handler for all events, triggered when an event is triggered.\n\n        Args:\n            payload: Dict.\n        \"\"\"\n        # pylint: disable=unused-argument\n        self.logger.warning(\"Method not implemented. Define a custom on_event on your plugin\")\n</code></pre>"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore.on_custom_interface_click","title":"<code>on_custom_interface_click(self, label, asset_id)</code>","text":"<p>Handler for the custom interface click action.</p> <p>Warning</p> <p>This handler is in beta and is still in active development, it should be used with caution.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Dict</code> <p>Label submitted to Kili: a dictionary containing the following fields: <code>id</code>, <code>jsonResponse</code>.</p> required <code>asset_id</code> <code>str</code> <p>id of the asset on which the action is called</p> required <p>Example</p> <pre><code>def on_custom_interface_click(self, label: Dict, asset_id: str):\n    json_response = label.get('jsonResponse')`\n    label_id = label.get('id')\n    issue = label_is_respecting_business_rule(json_response)\n    if !issue:\n        return\n    else:\n        self.kili.create_issues(\n                project_id=self.project_id,\n                label_id_array=[label_id],\n                text_array=[issue]\n            )\n</code></pre> Source code in <code>kili/services/plugins/model.py</code> <pre><code>def on_custom_interface_click(\n    self,\n    label: Dict,\n    asset_id: str,\n) -&gt; None:\n    \"\"\"Handler for the custom interface click action.\n\n    !!! warning\n        This handler is in beta and is still in active development,\n        it should be used with caution.\n\n    Args:\n        label: Label submitted to Kili: a dictionary containing the following fields:\n            `id`, `jsonResponse`.\n        asset_id: id of the asset on which the action is called\n\n    !!! example\n        ```python\n        def on_custom_interface_click(self, label: Dict, asset_id: str):\n            json_response = label.get('jsonResponse')`\n            label_id = label.get('id')\n            issue = label_is_respecting_business_rule(json_response)\n            if !issue:\n                return\n            else:\n                self.kili.create_issues(\n                        project_id=self.project_id,\n                        label_id_array=[label_id],\n                        text_array=[issue]\n                    )\n        ```\n    \"\"\"\n    # pylint: disable=unused-argument\n    self.logger.warning(\"Handler is in active development.\")\n</code></pre>"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore.on_event","title":"<code>on_event(self, payload)</code>","text":"<p>Handler for all events, triggered when an event is triggered.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>Dict</code> <p>Dict.</p> required Source code in <code>kili/services/plugins/model.py</code> <pre><code>def on_event(\n    self,\n    payload: Dict,\n) -&gt; None:\n    \"\"\"Handler for all events, triggered when an event is triggered.\n\n    Args:\n        payload: Dict.\n    \"\"\"\n    # pylint: disable=unused-argument\n    self.logger.warning(\"Method not implemented. Define a custom on_event on your plugin\")\n</code></pre>"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore.on_project_updated","title":"<code>on_project_updated(self, settings_updated)</code>","text":"<p>Handler for the project updated action.</p> <p>Triggered when a project setting is updated on Kili.</p> <p>Warning</p> <p>This handler is in beta and is still in active development, it should be used with caution.</p> <p>Parameters:</p> Name Type Description Default <code>settings_updated</code> <code>List[Dict]</code> <p>Settings updated on the project a list of dictionary containing the following fields: <code>key</code>, <code>newValue</code>, <code>oldValue</code>.</p> <p>Note</p> <p>key is one of the following: 'canNavigateBetweenAssets', 'canSkipAsset', 'consensusTotCoverage', 'description', 'inputType', 'instructions', 'isAnonymized', 'jsonInterface', 'metadataTypes', 'minConsensusSize', 'reviewCoverage', 'title', 'archivedAt', 'useHoneyPot'</p> required <p>Example</p> <pre><code>def on_project_updated(self, settings_updated: List[Dict]):\n    for setting in settings_updated:\n        self.logger.info(setting)\n        # this will print:\n        # {'key': 'description', 'newValue': 'new desc', 'oldValue': 'old desc'}\n</code></pre> Source code in <code>kili/services/plugins/model.py</code> <pre><code>def on_project_updated(\n    self,\n    settings_updated: List[Dict],\n) -&gt; None:\n    \"\"\"Handler for the project updated action.\n\n    Triggered when a project setting is updated on Kili.\n\n    !!! warning\n        This handler is in beta and is still in active development,\n        it should be used with caution.\n\n    Args:\n        settings_updated: Settings updated on the project a list of\n            dictionary containing the following fields:\n            `key`, `newValue`, `oldValue`.\n            !!! note\n                key is one of the following: 'canNavigateBetweenAssets',\n                'canSkipAsset', 'consensusTotCoverage', 'description',\n                'inputType', 'instructions', 'isAnonymized', 'jsonInterface',\n                'metadataTypes', 'minConsensusSize', 'reviewCoverage',\n                'title', 'archivedAt', 'useHoneyPot'\n\n    !!! example\n        ```python\n        def on_project_updated(self, settings_updated: List[Dict]):\n            for setting in settings_updated:\n                self.logger.info(setting)\n                # this will print:\n                # {'key': 'description', 'newValue': 'new desc', 'oldValue': 'old desc'}\n        ```\n    \"\"\"\n    # pylint: disable=unused-argument\n    self.logger.warning(\"Handler is in active development.\")\n</code></pre>"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore.on_review","title":"<code>on_review(self, label, asset_id)</code>","text":"<p>Handler for the review action, triggered when a default label is reviewed on Kili.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Dict</code> <p>Label submitted to Kili: a dictionary containing the following fields: <code>id</code>, <code>labelType</code>, <code>numberOfAnnotations</code>, <code>authorId</code>, <code>modelName</code>, <code>jsonResponse</code>, <code>secondsToLabel</code>, <code>isSentBackToQueue</code> and <code>search</code> (dictionary that has a field <code>id</code> representing the id of the original label that was reviewed). It also contains some technical fields: <code>createdAt</code>, <code>updatedAt</code>, <code>version</code>, <code>isLatestReviewLabelForUser</code>, <code>isLatestLabelForUser</code>, <code>isLatestDefaultLabelForUser</code>, <code>readPermissionsFromProject</code>.</p> required <code>asset_id</code> <code>str</code> <p>Id of the asset on which the label was submitted</p> required <p>Example</p> <pre><code>def on_review(self, label: Dict, asset_id: str):\n    json_response = label.get('jsonResponse')\n    if label_is_respecting_business_rule(json_response):\n        return\n    else:\n        self.kili.send_back_to_queue(asset_ids=[asset_id])\n</code></pre> Source code in <code>kili/services/plugins/model.py</code> <pre><code>def on_review(\n    self,\n    label: Dict,\n    asset_id: str,\n) -&gt; None:\n    \"\"\"Handler for the review action, triggered when a default label is reviewed on Kili.\n\n    Args:\n        label: Label submitted to Kili: a dictionary containing the following fields:\n            `id`, `labelType`, `numberOfAnnotations`, `authorId`, `modelName`, `jsonResponse`,\n            `secondsToLabel`, `isSentBackToQueue` and `search` (dictionary that has a field `id`\n            representing the id of the original label that was reviewed). It also contains some\n            technical fields: `createdAt`, `updatedAt`, `version`, `isLatestReviewLabelForUser`,\n            `isLatestLabelForUser`, `isLatestDefaultLabelForUser`, `readPermissionsFromProject`.\n        asset_id: Id of the asset on which the label was submitted\n\n    !!! example\n        ```python\n        def on_review(self, label: Dict, asset_id: str):\n            json_response = label.get('jsonResponse')\n            if label_is_respecting_business_rule(json_response):\n                return\n            else:\n                self.kili.send_back_to_queue(asset_ids=[asset_id])\n        ```\n    \"\"\"\n    # pylint: disable=unused-argument\n    self.logger.warning(\"Method not implemented. Define a custom on_review on your plugin\")\n</code></pre>"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore.on_send_back_to_queue","title":"<code>on_send_back_to_queue(self, asset_id)</code>","text":"<p>Handler for send back to queue.</p> <p>Triggered when an asset is sent back to queue</p> <p>Warning</p> <p>This handler is in beta and is still in active development, it should be used with caution.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id</code> <code>str</code> <p>Id of the asset on which was sent back to queue</p> required <p>Example</p> <pre><code>def on_send_back_to_queue(self, asset_id: str):\n    self.logger.info(f\"Asset {asset_id} was sent back to queue\")\n</code></pre> Source code in <code>kili/services/plugins/model.py</code> <pre><code>def on_send_back_to_queue(\n    self,\n    asset_id: str,\n) -&gt; None:\n    \"\"\"Handler for send back to queue.\n\n    Triggered when an asset is sent back to queue\n\n    !!! warning\n        This handler is in beta and is still in active development,\n        it should be used with caution.\n\n    Args:\n        asset_id: Id of the asset on which was sent back to queue\n\n    !!! example\n        ```python\n        def on_send_back_to_queue(self, asset_id: str):\n            self.logger.info(f\"Asset {asset_id} was sent back to queue\")\n        ```\n    \"\"\"\n    # pylint: disable=unused-argument\n    self.logger.warning(\"Handler is in active development.\")\n</code></pre>"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore.on_submit","title":"<code>on_submit(self, label, asset_id)</code>","text":"<p>Handler for the submit action, triggered when a default label is submitted into Kili.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Dict</code> <p>Label submitted to Kili: a dictionary containing the following fields: <code>id</code>, <code>labelType</code>, <code>numberOfAnnotations</code>, <code>authorId</code>, <code>modelName</code>, <code>jsonResponse</code>, <code>secondsToLabel</code>, <code>isSentBackToQueue</code>, <code>search</code> and some technical fields: <code>createdAt</code>, <code>updatedAt</code>, <code>version</code>, <code>isLatestReviewLabelForUser</code>, <code>isLatestLabelForUser</code>, <code>isLatestDefaultLabelForUser</code>, <code>readPermissionsFromProject</code>.</p> required <code>asset_id</code> <code>str</code> <p>Id of the asset on which the label was submitted</p> required <p>Example</p> <pre><code>def on_submit(self, label: Dict, asset_id: str):\n    json_response = label.get('jsonResponse')\n    if label_is_respecting_business_rule(json_response):\n        return\n    else:\n        self.kili.send_back_to_queue(asset_ids=[asset_id])\n</code></pre> Source code in <code>kili/services/plugins/model.py</code> <pre><code>def on_submit(\n    self,\n    label: Dict,\n    asset_id: str,\n) -&gt; None:\n    \"\"\"Handler for the submit action, triggered when a default label is submitted into Kili.\n\n    Args:\n        label: Label submitted to Kili: a dictionary containing the following fields:\n            `id`, `labelType`, `numberOfAnnotations`, `authorId`, `modelName`, `jsonResponse`,\n            `secondsToLabel`, `isSentBackToQueue`, `search` and some technical fields:\n            `createdAt`, `updatedAt`, `version`, `isLatestReviewLabelForUser`,\n            `isLatestLabelForUser`, `isLatestDefaultLabelForUser`,\n            `readPermissionsFromProject`.\n        asset_id: Id of the asset on which the label was submitted\n\n    !!! example\n        ```python\n        def on_submit(self, label: Dict, asset_id: str):\n            json_response = label.get('jsonResponse')\n            if label_is_respecting_business_rule(json_response):\n                return\n            else:\n                self.kili.send_back_to_queue(asset_ids=[asset_id])\n        ```\n    \"\"\"\n    # pylint: disable=unused-argument\n    self.logger.warning(\"Method not implemented. Define a custom on_submit on your plugin\")\n</code></pre>"},{"location":"sdk/plugins/#queries","title":"Queries","text":"<p>Set of Plugins queries.</p> Source code in <code>kili/entrypoints/queries/plugins/__init__.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass QueriesPlugins(BaseOperationEntrypointMixin):\n    \"\"\"Set of Plugins queries.\"\"\"\n\n    # pylint: disable=too-many-arguments\n\n    @typechecked\n    def get_plugin_build_errors(\n        self,\n        plugin_name: str,\n        start_date: Optional[datetime] = None,\n        limit: int = 100,\n        skip: int = 0,\n    ) -&gt; str:\n        # pylint: disable=line-too-long\n        \"\"\"Get paginated build errors of a plugin.\n\n        Args:\n            plugin_name: Name of the plugin\n            start_date: Datetime used to get the build errors from, if not provided, it will be the plugin's creation date\n            limit: Limit for pagination, if not provided, it will be 100\n            skip: Skip for pagination, if not provided, it will be 0\n        Returns:\n            A result array which contains the build errors of the plugin,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.get_plugin_build_errors(plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n        \"\"\"\n        where = PluginBuildErrorsWhere(plugin_name=plugin_name, start_date=start_date)\n        options = QueryOptions(\n            first=limit, skip=skip, disable_tqdm=False\n        )  # disable tqm is not implemented for this query\n        pretty_result = PluginQuery(self.graphql_client, self.http_client).get_build_errors(\n            where, options\n        )\n        return json.dumps(pretty_result, sort_keys=True, indent=4)\n\n    @typechecked\n    def get_plugin_logs(\n        self,\n        project_id: str,\n        plugin_name: str,\n        start_date: Optional[datetime] = None,\n        limit: int = 100,\n        skip: int = 0,\n    ) -&gt; str:\n        \"\"\"Get paginated logs of a plugin on a project.\n\n        Args:\n            project_id: Identifier of the project\n            plugin_name: Name of the plugin\n            start_date: Datetime used to get the logs from, if not provided, it will be the plugin's creation date\n            limit: Limit for pagination, if not provided, it will be 100\n            skip: Skip for pagination, if not provided, it will be 0\n        Returns:\n            A result array which contains the logs of the plugin,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.get_plugin_logs(project_id=\"my_project_id\", plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n        \"\"\"\n        where = PluginLogsWhere(\n            project_id=project_id, plugin_name=plugin_name, start_date=start_date\n        )\n        options = QueryOptions(\n            first=limit, skip=skip, disable_tqdm=False\n        )  # disable tqm is not implemented for this query\n        pretty_result = PluginQuery(self.graphql_client, self.http_client).get_logs(where, options)\n        return json.dumps(pretty_result, sort_keys=True, indent=4)\n\n    @typechecked\n    def get_plugin_status(\n        self,\n        plugin_name: str,\n        verbose: bool = True,\n    ) -&gt; str:\n        \"\"\"Update a plugin with new code.\n\n        Args:\n            plugin_name: Name of the plugin\n            verbose: If false, minimal logs are displayed\n\n        Returns:\n            The status of the plugin if query was successful or an error message otherwise.\n\n        Examples:\n            &gt;&gt;&gt; kili.get_plugin_status(plugin_name=\"my_plugin_name\")\n        \"\"\"\n        return PluginUploader(\n            self,  # pyright: ignore[reportGeneralTypeIssues]\n            \"\",\n            plugin_name,\n            verbose,\n            self.http_client,\n            event_matcher=None,\n        ).get_plugin_runner_status()\n\n    @typechecked\n    def list_plugins(\n        self,\n        fields: ListOrTuple[str] = (\"name\", \"projectIds\", \"id\", \"createdAt\", \"updatedAt\"),\n    ) -&gt; List[Dict]:\n        # pylint: disable=line-too-long\n        \"\"\"List all plugins from your organization.\n\n        Args:\n            fields: All the fields to request among the possible fields for the plugins\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/plugin) for all possible fields.\n\n        Returns:\n            A result array which contains all the plugins from your organization,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.list_plugins()\n            &gt;&gt;&gt; kili.list_plugins(fields=['name'])\n        \"\"\"\n        return PluginQuery(self.graphql_client, self.http_client).list(fields=fields)\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.queries.plugins.__init__.QueriesPlugins.get_plugin_build_errors","title":"<code>get_plugin_build_errors(self, plugin_name, start_date=None, limit=100, skip=0)</code>","text":"<p>Get paginated build errors of a plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>start_date</code> <code>Optional[datetime.datetime]</code> <p>Datetime used to get the build errors from, if not provided, it will be the plugin's creation date</p> <code>None</code> <code>limit</code> <code>int</code> <p>Limit for pagination, if not provided, it will be 100</p> <code>100</code> <code>skip</code> <code>int</code> <p>Skip for pagination, if not provided, it will be 0</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>A result array which contains the build errors of the plugin,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.get_plugin_build_errors(plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n</code></pre> Source code in <code>kili/entrypoints/queries/plugins/__init__.py</code> <pre><code>def get_plugin_build_errors(\n    self,\n    plugin_name: str,\n    start_date: Optional[datetime] = None,\n    limit: int = 100,\n    skip: int = 0,\n) -&gt; str:\n    # pylint: disable=line-too-long\n    \"\"\"Get paginated build errors of a plugin.\n\n    Args:\n        plugin_name: Name of the plugin\n        start_date: Datetime used to get the build errors from, if not provided, it will be the plugin's creation date\n        limit: Limit for pagination, if not provided, it will be 100\n        skip: Skip for pagination, if not provided, it will be 0\n    Returns:\n        A result array which contains the build errors of the plugin,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.get_plugin_build_errors(plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n    \"\"\"\n    where = PluginBuildErrorsWhere(plugin_name=plugin_name, start_date=start_date)\n    options = QueryOptions(\n        first=limit, skip=skip, disable_tqdm=False\n    )  # disable tqm is not implemented for this query\n    pretty_result = PluginQuery(self.graphql_client, self.http_client).get_build_errors(\n        where, options\n    )\n    return json.dumps(pretty_result, sort_keys=True, indent=4)\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.queries.plugins.__init__.QueriesPlugins.get_plugin_logs","title":"<code>get_plugin_logs(self, project_id, plugin_name, start_date=None, limit=100, skip=0)</code>","text":"<p>Get paginated logs of a plugin on a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>start_date</code> <code>Optional[datetime.datetime]</code> <p>Datetime used to get the logs from, if not provided, it will be the plugin's creation date</p> <code>None</code> <code>limit</code> <code>int</code> <p>Limit for pagination, if not provided, it will be 100</p> <code>100</code> <code>skip</code> <code>int</code> <p>Skip for pagination, if not provided, it will be 0</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>A result array which contains the logs of the plugin,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.get_plugin_logs(project_id=\"my_project_id\", plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n</code></pre> Source code in <code>kili/entrypoints/queries/plugins/__init__.py</code> <pre><code>def get_plugin_logs(\n    self,\n    project_id: str,\n    plugin_name: str,\n    start_date: Optional[datetime] = None,\n    limit: int = 100,\n    skip: int = 0,\n) -&gt; str:\n    \"\"\"Get paginated logs of a plugin on a project.\n\n    Args:\n        project_id: Identifier of the project\n        plugin_name: Name of the plugin\n        start_date: Datetime used to get the logs from, if not provided, it will be the plugin's creation date\n        limit: Limit for pagination, if not provided, it will be 100\n        skip: Skip for pagination, if not provided, it will be 0\n    Returns:\n        A result array which contains the logs of the plugin,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.get_plugin_logs(project_id=\"my_project_id\", plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n    \"\"\"\n    where = PluginLogsWhere(\n        project_id=project_id, plugin_name=plugin_name, start_date=start_date\n    )\n    options = QueryOptions(\n        first=limit, skip=skip, disable_tqdm=False\n    )  # disable tqm is not implemented for this query\n    pretty_result = PluginQuery(self.graphql_client, self.http_client).get_logs(where, options)\n    return json.dumps(pretty_result, sort_keys=True, indent=4)\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.queries.plugins.__init__.QueriesPlugins.get_plugin_status","title":"<code>get_plugin_status(self, plugin_name, verbose=True)</code>","text":"<p>Update a plugin with new code.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The status of the plugin if query was successful or an error message otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.get_plugin_status(plugin_name=\"my_plugin_name\")\n</code></pre> Source code in <code>kili/entrypoints/queries/plugins/__init__.py</code> <pre><code>def get_plugin_status(\n    self,\n    plugin_name: str,\n    verbose: bool = True,\n) -&gt; str:\n    \"\"\"Update a plugin with new code.\n\n    Args:\n        plugin_name: Name of the plugin\n        verbose: If false, minimal logs are displayed\n\n    Returns:\n        The status of the plugin if query was successful or an error message otherwise.\n\n    Examples:\n        &gt;&gt;&gt; kili.get_plugin_status(plugin_name=\"my_plugin_name\")\n    \"\"\"\n    return PluginUploader(\n        self,  # pyright: ignore[reportGeneralTypeIssues]\n        \"\",\n        plugin_name,\n        verbose,\n        self.http_client,\n        event_matcher=None,\n    ).get_plugin_runner_status()\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.queries.plugins.__init__.QueriesPlugins.list_plugins","title":"<code>list_plugins(self, fields=('name', 'projectIds', 'id', 'createdAt', 'updatedAt'))</code>","text":"<p>List all plugins from your organization.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the plugins See the documentation for all possible fields.</p> <code>('name', 'projectIds', 'id', 'createdAt', 'updatedAt')</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>A result array which contains all the plugins from your organization,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.list_plugins()\n&gt;&gt;&gt; kili.list_plugins(fields=['name'])\n</code></pre> Source code in <code>kili/entrypoints/queries/plugins/__init__.py</code> <pre><code>def list_plugins(\n    self,\n    fields: ListOrTuple[str] = (\"name\", \"projectIds\", \"id\", \"createdAt\", \"updatedAt\"),\n) -&gt; List[Dict]:\n    # pylint: disable=line-too-long\n    \"\"\"List all plugins from your organization.\n\n    Args:\n        fields: All the fields to request among the possible fields for the plugins\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/plugin) for all possible fields.\n\n    Returns:\n        A result array which contains all the plugins from your organization,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.list_plugins()\n        &gt;&gt;&gt; kili.list_plugins(fields=['name'])\n    \"\"\"\n    return PluginQuery(self.graphql_client, self.http_client).list(fields=fields)\n</code></pre>"},{"location":"sdk/plugins/#mutations","title":"Mutations","text":"<p>Set of Plugins mutations.</p> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass MutationsPlugins(BaseOperationEntrypointMixin):\n    \"\"\"Set of Plugins mutations.\"\"\"\n\n    @typechecked\n    def upload_plugin(\n        self,\n        plugin_path: Optional[str] = None,\n        plugin_name: Optional[str] = None,\n        verbose: bool = True,\n        event_matcher: Optional[List[str]] = None,\n        **kwargs,  # pylint: disable=missing-param-doc\n    ) -&gt; LiteralString:\n        \"\"\"Uploads a plugin.\n\n        Args:\n            plugin_path: Path to your plugin. Either:\n\n                - a folder containing a main.py (mandatory) and a requirements.txt (optional)\n                - a .py file\n            plugin_name: name of your plugin, if not provided, it will be the name from your file\n            event_matcher: List of events for which the plugin should be called.\n            verbose: If false, minimal logs are displayed\n\n        Returns:\n            A string which indicates if the mutation was successful, or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/folder\")\n            &gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/file.py\")\n        \"\"\"\n        if kwargs.get(\"file_path\"):\n            raise TypeError(\n                '\"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\"'\n                \" instead\"\n            )\n\n        if not plugin_path:\n            raise TypeError('\"plugin_path is nullish, please provide a value')\n\n        return PluginUploader(\n            self,  # pyright: ignore[reportGeneralTypeIssues]\n            plugin_path,\n            plugin_name,\n            verbose,\n            self.http_client,\n            event_matcher,\n        ).create_plugin()\n\n    @typechecked\n    def create_webhook(\n        self,\n        webhook_url: str,\n        plugin_name: str,\n        header: Optional[str] = None,\n        verbose: bool = True,\n        handler_types: Optional[List[str]] = None,\n        event_matcher: Optional[List[str]] = None,\n    ) -&gt; str:\n        # pylint: disable=line-too-long,too-many-arguments\n        \"\"\"Create a webhook linked to Kili's events.\n\n        For a complete example, refer to the notebook `webhooks_example` on kili repo.\n\n        Args:\n            webhook_url: URL receiving post requests on events on Kili. The payload will be the following:\n\n                - eventType: the type of event called\n                - logPayload:\n                    - runId: a unique identifier of the run for observability\n                    - projectId: the Kili project the webhook is called on\n                - payload: the event produced, for example for `onSubmit` event:\n                    - label: the label produced\n                    - asset_id: the asset on which the label is produced\n            plugin_name: name of your plugin\n            header: Authorization header to access the routes\n            verbose: If false, minimal logs are displayed\n            handler_types: List of actions for which the webhook should be called.\n                Possible variants: `onSubmit`, `onReview`.\n                By default, is [`onSubmit`, `onReview`].\n            event_matcher: List of events for which the webhook should be called.\n\n        Returns:\n            A string which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.create_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n        \"\"\"\n        return WebhookUploader(\n            self,  # pyright: ignore[reportGeneralTypeIssues]\n            webhook_url,\n            plugin_name,\n            header,\n            verbose,\n            handler_types,\n            event_matcher,\n        ).create_webhook()\n\n    @typechecked\n    def update_webhook(\n        self,\n        new_webhook_url: str,\n        plugin_name: str,\n        new_header: Optional[str] = None,\n        verbose: bool = True,\n        handler_types: Optional[List[str]] = None,\n        event_matcher: Optional[List[str]] = None,\n    ) -&gt; str:\n        # pylint: disable=line-too-long,too-many-arguments\n        \"\"\"Update a webhook linked to Kili's events.\n\n        For a complete example, refer to the notebook `webhooks_example` on kili repo.\n\n        Args:\n            new_webhook_url: New URL receiving post requests on events on Kili. See `create_webhook` for the payload description\n            plugin_name: name of your plugin\n            new_header: Authorization header to access the routes\n            verbose: If false, minimal logs are displayed\n            handler_types: List of actions for which the webhook should be called.\n                Possible variants: `onSubmit`, `onReview`.\n                By default, is [`onSubmit`, `onReview`]\n            event_matcher: List of events for which the webhook should be called.\n\n        Returns:\n            A string which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n        \"\"\"\n        return WebhookUploader(\n            self,  # pyright: ignore[reportGeneralTypeIssues]\n            new_webhook_url,\n            plugin_name,\n            new_header,\n            verbose,\n            handler_types,\n            event_matcher,\n        ).update_webhook()\n\n    @typechecked\n    def activate_plugin_on_project(self, plugin_name: str, project_id: str) -&gt; Optional[str]:\n        \"\"\"Activates a plugin on a project.\n\n        Args:\n            plugin_name: Name of the plugin\n            project_id: Identifier of the project\n\n        Returns:\n            A string which indicates if the mutation was successful, or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.activate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n        \"\"\"\n        return activate_plugin(self, plugin_name, project_id)\n\n    @typechecked\n    def deactivate_plugin_on_project(self, plugin_name: str, project_id: str) -&gt; str:\n        \"\"\"Activates a plugin on a project.\n\n        Args:\n            plugin_name: Name of the plugin\n            project_id: Identifier of the project\n\n        Returns:\n            A string which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.deactivate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n        \"\"\"\n        return deactivate_plugin(self, plugin_name, project_id)\n\n    @typechecked\n    def delete_plugin(self, plugin_name: str) -&gt; str:\n        \"\"\"Deletes a plugin.\n\n        Args:\n            plugin_name: Name of the plugin\n\n        Returns:\n            A string which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.delete_plugin(plugin_name=\"my_plugin_name\")\n        \"\"\"\n        return delete_plugin(self, plugin_name)\n\n    @typechecked\n    def update_plugin(\n        self,\n        plugin_path: Optional[str] = None,\n        plugin_name: Optional[str] = None,\n        verbose: bool = True,\n        event_matcher: Optional[List[str]] = None,\n        **kwargs,  # pylint: disable=missing-param-doc\n    ) -&gt; LiteralString:\n        \"\"\"Update a plugin with new code.\n\n        Args:\n            plugin_path: Path to your plugin. Either:\n\n                - a folder containing a main.py (mandatory) and a requirements.txt (optional)\n                - a .py file\n            plugin_name: Name of the plugin\n            event_matcher: List of events names and/or globs for which the plugin should be called.\n            verbose: If false, minimal logs are displayed\n\n        Returns:\n            A string which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_plugin(plugin_name=\"my_plugin_name\")\n        \"\"\"\n        if kwargs.get(\"file_path\"):\n            raise TypeError(\n                '\"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\"'\n                \" instead\"\n            )\n\n        if not plugin_path:\n            raise TypeError('\"plugin_path is nullish, please provide a value')\n\n        if not plugin_name:\n            raise TypeError('\"plugin_name is nullish, please provide a value')\n\n        return PluginUploader(\n            self,  # pyright: ignore[reportGeneralTypeIssues]\n            plugin_path,\n            plugin_name,\n            verbose,\n            self.http_client,\n            event_matcher,\n        ).update_plugin()\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.mutations.plugins.__init__.MutationsPlugins.activate_plugin_on_project","title":"<code>activate_plugin_on_project(self, plugin_name, project_id)</code>","text":"<p>Activates a plugin on a project.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>A string which indicates if the mutation was successful, or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.activate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n</code></pre> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>def activate_plugin_on_project(self, plugin_name: str, project_id: str) -&gt; Optional[str]:\n    \"\"\"Activates a plugin on a project.\n\n    Args:\n        plugin_name: Name of the plugin\n        project_id: Identifier of the project\n\n    Returns:\n        A string which indicates if the mutation was successful, or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.activate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n    \"\"\"\n    return activate_plugin(self, plugin_name, project_id)\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.mutations.plugins.__init__.MutationsPlugins.create_webhook","title":"<code>create_webhook(self, webhook_url, plugin_name, header=None, verbose=True, handler_types=None, event_matcher=None)</code>","text":"<p>Create a webhook linked to Kili's events.</p> <p>For a complete example, refer to the notebook <code>webhooks_example</code> on kili repo.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_url</code> <code>str</code> <p>URL receiving post requests on events on Kili. The payload will be the following:</p> <ul> <li>eventType: the type of event called</li> <li>logPayload:<ul> <li>runId: a unique identifier of the run for observability</li> <li>projectId: the Kili project the webhook is called on</li> </ul> </li> <li>payload: the event produced, for example for <code>onSubmit</code> event:<ul> <li>label: the label produced</li> <li>asset_id: the asset on which the label is produced</li> </ul> </li> </ul> required <code>plugin_name</code> <code>str</code> <p>name of your plugin</p> required <code>header</code> <code>Optional[str]</code> <p>Authorization header to access the routes</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <code>handler_types</code> <code>Optional[List[str]]</code> <p>List of actions for which the webhook should be called. Possible variants: <code>onSubmit</code>, <code>onReview</code>. By default, is [<code>onSubmit</code>, <code>onReview</code>].</p> <code>None</code> <code>event_matcher</code> <code>Optional[List[str]]</code> <p>List of events for which the webhook should be called.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A string which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.create_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n</code></pre> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>def create_webhook(\n    self,\n    webhook_url: str,\n    plugin_name: str,\n    header: Optional[str] = None,\n    verbose: bool = True,\n    handler_types: Optional[List[str]] = None,\n    event_matcher: Optional[List[str]] = None,\n) -&gt; str:\n    # pylint: disable=line-too-long,too-many-arguments\n    \"\"\"Create a webhook linked to Kili's events.\n\n    For a complete example, refer to the notebook `webhooks_example` on kili repo.\n\n    Args:\n        webhook_url: URL receiving post requests on events on Kili. The payload will be the following:\n\n            - eventType: the type of event called\n            - logPayload:\n                - runId: a unique identifier of the run for observability\n                - projectId: the Kili project the webhook is called on\n            - payload: the event produced, for example for `onSubmit` event:\n                - label: the label produced\n                - asset_id: the asset on which the label is produced\n        plugin_name: name of your plugin\n        header: Authorization header to access the routes\n        verbose: If false, minimal logs are displayed\n        handler_types: List of actions for which the webhook should be called.\n            Possible variants: `onSubmit`, `onReview`.\n            By default, is [`onSubmit`, `onReview`].\n        event_matcher: List of events for which the webhook should be called.\n\n    Returns:\n        A string which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.create_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n    \"\"\"\n    return WebhookUploader(\n        self,  # pyright: ignore[reportGeneralTypeIssues]\n        webhook_url,\n        plugin_name,\n        header,\n        verbose,\n        handler_types,\n        event_matcher,\n    ).create_webhook()\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.mutations.plugins.__init__.MutationsPlugins.deactivate_plugin_on_project","title":"<code>deactivate_plugin_on_project(self, plugin_name, project_id)</code>","text":"<p>Activates a plugin on a project.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.deactivate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n</code></pre> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>def deactivate_plugin_on_project(self, plugin_name: str, project_id: str) -&gt; str:\n    \"\"\"Activates a plugin on a project.\n\n    Args:\n        plugin_name: Name of the plugin\n        project_id: Identifier of the project\n\n    Returns:\n        A string which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.deactivate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n    \"\"\"\n    return deactivate_plugin(self, plugin_name, project_id)\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.mutations.plugins.__init__.MutationsPlugins.delete_plugin","title":"<code>delete_plugin(self, plugin_name)</code>","text":"<p>Deletes a plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.delete_plugin(plugin_name=\"my_plugin_name\")\n</code></pre> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>def delete_plugin(self, plugin_name: str) -&gt; str:\n    \"\"\"Deletes a plugin.\n\n    Args:\n        plugin_name: Name of the plugin\n\n    Returns:\n        A string which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.delete_plugin(plugin_name=\"my_plugin_name\")\n    \"\"\"\n    return delete_plugin(self, plugin_name)\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.mutations.plugins.__init__.MutationsPlugins.update_plugin","title":"<code>update_plugin(self, plugin_path=None, plugin_name=None, verbose=True, event_matcher=None, **kwargs)</code>","text":"<p>Update a plugin with new code.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_path</code> <code>Optional[str]</code> <p>Path to your plugin. Either:</p> <ul> <li>a folder containing a main.py (mandatory) and a requirements.txt (optional)</li> <li>a .py file</li> </ul> <code>None</code> <code>plugin_name</code> <code>Optional[str]</code> <p>Name of the plugin</p> <code>None</code> <code>event_matcher</code> <code>Optional[List[str]]</code> <p>List of events names and/or globs for which the plugin should be called.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>typing_extensions.LiteralString</code> <p>A string which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_plugin(plugin_name=\"my_plugin_name\")\n</code></pre> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>def update_plugin(\n    self,\n    plugin_path: Optional[str] = None,\n    plugin_name: Optional[str] = None,\n    verbose: bool = True,\n    event_matcher: Optional[List[str]] = None,\n    **kwargs,  # pylint: disable=missing-param-doc\n) -&gt; LiteralString:\n    \"\"\"Update a plugin with new code.\n\n    Args:\n        plugin_path: Path to your plugin. Either:\n\n            - a folder containing a main.py (mandatory) and a requirements.txt (optional)\n            - a .py file\n        plugin_name: Name of the plugin\n        event_matcher: List of events names and/or globs for which the plugin should be called.\n        verbose: If false, minimal logs are displayed\n\n    Returns:\n        A string which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_plugin(plugin_name=\"my_plugin_name\")\n    \"\"\"\n    if kwargs.get(\"file_path\"):\n        raise TypeError(\n            '\"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\"'\n            \" instead\"\n        )\n\n    if not plugin_path:\n        raise TypeError('\"plugin_path is nullish, please provide a value')\n\n    if not plugin_name:\n        raise TypeError('\"plugin_name is nullish, please provide a value')\n\n    return PluginUploader(\n        self,  # pyright: ignore[reportGeneralTypeIssues]\n        plugin_path,\n        plugin_name,\n        verbose,\n        self.http_client,\n        event_matcher,\n    ).update_plugin()\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.mutations.plugins.__init__.MutationsPlugins.update_webhook","title":"<code>update_webhook(self, new_webhook_url, plugin_name, new_header=None, verbose=True, handler_types=None, event_matcher=None)</code>","text":"<p>Update a webhook linked to Kili's events.</p> <p>For a complete example, refer to the notebook <code>webhooks_example</code> on kili repo.</p> <p>Parameters:</p> Name Type Description Default <code>new_webhook_url</code> <code>str</code> <p>New URL receiving post requests on events on Kili. See <code>create_webhook</code> for the payload description</p> required <code>plugin_name</code> <code>str</code> <p>name of your plugin</p> required <code>new_header</code> <code>Optional[str]</code> <p>Authorization header to access the routes</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <code>handler_types</code> <code>Optional[List[str]]</code> <p>List of actions for which the webhook should be called. Possible variants: <code>onSubmit</code>, <code>onReview</code>. By default, is [<code>onSubmit</code>, <code>onReview</code>]</p> <code>None</code> <code>event_matcher</code> <code>Optional[List[str]]</code> <p>List of events for which the webhook should be called.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A string which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n</code></pre> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>def update_webhook(\n    self,\n    new_webhook_url: str,\n    plugin_name: str,\n    new_header: Optional[str] = None,\n    verbose: bool = True,\n    handler_types: Optional[List[str]] = None,\n    event_matcher: Optional[List[str]] = None,\n) -&gt; str:\n    # pylint: disable=line-too-long,too-many-arguments\n    \"\"\"Update a webhook linked to Kili's events.\n\n    For a complete example, refer to the notebook `webhooks_example` on kili repo.\n\n    Args:\n        new_webhook_url: New URL receiving post requests on events on Kili. See `create_webhook` for the payload description\n        plugin_name: name of your plugin\n        new_header: Authorization header to access the routes\n        verbose: If false, minimal logs are displayed\n        handler_types: List of actions for which the webhook should be called.\n            Possible variants: `onSubmit`, `onReview`.\n            By default, is [`onSubmit`, `onReview`]\n        event_matcher: List of events for which the webhook should be called.\n\n    Returns:\n        A string which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n    \"\"\"\n    return WebhookUploader(\n        self,  # pyright: ignore[reportGeneralTypeIssues]\n        new_webhook_url,\n        plugin_name,\n        new_header,\n        verbose,\n        handler_types,\n        event_matcher,\n    ).update_webhook()\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.mutations.plugins.__init__.MutationsPlugins.upload_plugin","title":"<code>upload_plugin(self, plugin_path=None, plugin_name=None, verbose=True, event_matcher=None, **kwargs)</code>","text":"<p>Uploads a plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_path</code> <code>Optional[str]</code> <p>Path to your plugin. Either:</p> <ul> <li>a folder containing a main.py (mandatory) and a requirements.txt (optional)</li> <li>a .py file</li> </ul> <code>None</code> <code>plugin_name</code> <code>Optional[str]</code> <p>name of your plugin, if not provided, it will be the name from your file</p> <code>None</code> <code>event_matcher</code> <code>Optional[List[str]]</code> <p>List of events for which the plugin should be called.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <p>Returns:</p> Type Description <code>typing_extensions.LiteralString</code> <p>A string which indicates if the mutation was successful, or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/folder\")\n&gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/file.py\")\n</code></pre> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>def upload_plugin(\n    self,\n    plugin_path: Optional[str] = None,\n    plugin_name: Optional[str] = None,\n    verbose: bool = True,\n    event_matcher: Optional[List[str]] = None,\n    **kwargs,  # pylint: disable=missing-param-doc\n) -&gt; LiteralString:\n    \"\"\"Uploads a plugin.\n\n    Args:\n        plugin_path: Path to your plugin. Either:\n\n            - a folder containing a main.py (mandatory) and a requirements.txt (optional)\n            - a .py file\n        plugin_name: name of your plugin, if not provided, it will be the name from your file\n        event_matcher: List of events for which the plugin should be called.\n        verbose: If false, minimal logs are displayed\n\n    Returns:\n        A string which indicates if the mutation was successful, or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/folder\")\n        &gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/file.py\")\n    \"\"\"\n    if kwargs.get(\"file_path\"):\n        raise TypeError(\n            '\"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\"'\n            \" instead\"\n        )\n\n    if not plugin_path:\n        raise TypeError('\"plugin_path is nullish, please provide a value')\n\n    return PluginUploader(\n        self,  # pyright: ignore[reportGeneralTypeIssues]\n        plugin_path,\n        plugin_name,\n        verbose,\n        self.http_client,\n        event_matcher,\n    ).create_plugin()\n</code></pre>"},{"location":"sdk/project/","title":"Project module","text":"<p>Methods attached to the Kili client, to run actions on projects.</p> Source code in <code>kili/presentation/client/project.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass ProjectClientMethods(BaseClientMethods):\n    \"\"\"Methods attached to the Kili client, to run actions on projects.\"\"\"\n\n    @typechecked\n    # pylint: disable=too-many-arguments\n    def create_project(\n        self,\n        title: str,\n        description: str = \"\",\n        input_type: Optional[InputType] = None,\n        json_interface: Optional[Dict] = None,\n        project_id: Optional[ProjectId] = None,\n        tags: Optional[ListOrTuple[str]] = None,\n        compliance_tags: Optional[ListOrTuple[ComplianceTag]] = None,\n        from_demo_project: Optional[DemoProjectType] = None,\n    ) -&gt; Dict[Literal[\"id\"], str]:\n        \"\"\"Create a project.\n\n        Args:\n            input_type: Currently, one of `IMAGE`, `PDF`, `TEXT` or `VIDEO`.\n            json_interface: The json parameters of the project, see Edit your interface.\n            title: Title of the project.\n            description: Description of the project.\n            project_id: Identifier of the project to copy.\n            tags: Tags to add to the project. The tags must already exist in the organization.\n            compliance_tags: Compliance tags of the project.\n                Compliance tags are used to categorize projects based on the sensitivity of\n                the data being handled and the legal constraints associated with it.\n                Possible values are: `PHI` and `PII`.\n            from_demo_project: Currently, one of:\n\n                - `DEMO_COMPUTER_VISION_TUTORIAL`\n                - `DEMO_TEXT_TUTORIAL`\n                - `DEMO_PDF_TUTORIAL`\n                - `VIDEO_FRAME_OBJECT_TRACKING`\n                - `DEMO_SEGMENTATION_COCO`\n                - `DEMO_NER`\n                - `DEMO_ID_OCR`\n                - `DEMO_REVIEWS`\n                - `DEMO_OCR`\n                - `DEMO_NER_TWEETS`\n                - `DEMO_PLASTIC`\n                - `DEMO_CHATBOT`\n                - `DEMO_PDF`\n                - `DEMO_ANIMALS`\n                - `DEMO_LLM`\n                - `DEMO_LLM_INSTR_FOLLOWING`\n                - `DEMO_SEGMENTATION`\n\n        Returns:\n            A dict with the id of the created project.\n\n        Examples:\n            &gt;&gt;&gt; kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example')\n\n        !!! example \"Recipe\"\n            For more detailed examples on how to create projects,\n                see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project).\n        \"\"\"\n        project_id = ProjectUseCases(self.kili_api_gateway).create_project(\n            input_type=input_type,\n            json_interface=json_interface,\n            title=title,\n            description=description,\n            project_id=project_id,\n            compliance_tags=compliance_tags,\n            from_demo_project=from_demo_project,\n        )\n\n        if tags is not None:\n            tag_use_cases = TagUseCases(self.kili_api_gateway)\n            tag_ids = tag_use_cases.get_tag_ids_from_labels(labels=tags)\n            tag_use_cases.tag_project(\n                project_id=project_id, tag_ids=cast(ListOrTuple[TagId], tag_ids), disable_tqdm=True\n            )\n\n        return {\"id\": project_id}\n\n    @overload\n    # pylint: disable=too-many-arguments\n    def projects(\n        self,\n        project_id: Optional[str] = None,\n        search_query: Optional[str] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        archived: Optional[bool] = None,\n        starred: Optional[bool] = None,\n        tags_in: Optional[ListOrTuple[str]] = None,\n        organization_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"consensusTotCoverage\",\n            \"id\",\n            \"inputType\",\n            \"jsonInterface\",\n            \"minConsensusSize\",\n            \"reviewCoverage\",\n            \"roles.id\",\n            \"roles.role\",\n            \"roles.user.email\",\n            \"roles.user.id\",\n            \"title\",\n        ),\n        deleted: Optional[bool] = None,\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    # pylint: disable=too-many-arguments\n    def projects(\n        self,\n        project_id: Optional[str] = None,\n        search_query: Optional[str] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        archived: Optional[bool] = None,\n        starred: Optional[bool] = None,\n        tags_in: Optional[ListOrTuple[str]] = None,\n        organization_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"consensusTotCoverage\",\n            \"id\",\n            \"inputType\",\n            \"jsonInterface\",\n            \"minConsensusSize\",\n            \"reviewCoverage\",\n            \"roles.id\",\n            \"roles.role\",\n            \"roles.user.email\",\n            \"roles.user.id\",\n            \"title\",\n        ),\n        deleted: Optional[bool] = None,\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    # pylint: disable=too-many-arguments,too-many-locals\n    def projects(\n        self,\n        project_id: Optional[str] = None,\n        search_query: Optional[str] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        archived: Optional[bool] = None,\n        starred: Optional[bool] = None,\n        tags_in: Optional[ListOrTuple[str]] = None,\n        organization_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\n            \"consensusTotCoverage\",\n            \"id\",\n            \"inputType\",\n            \"jsonInterface\",\n            \"minConsensusSize\",\n            \"reviewCoverage\",\n            \"roles.id\",\n            \"roles.role\",\n            \"roles.user.email\",\n            \"roles.user.id\",\n            \"title\",\n        ),\n        deleted: Optional[bool] = None,\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a generator or a list of projects that match a set of criteria.\n\n        Args:\n            project_id: Select a specific project through its project_id.\n            search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n            should_relaunch_kpi_computation: Deprecated, do not use.\n            updated_at_gte: Returned projects should have a label whose update date is greater or equal\n                to this date.\n            updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date.\n            archived: If `True`, only archived projects are returned, if `False`, only active projects are returned.\n                `None` disables this filter.\n            starred: If `True`, only starred projects are returned, if `False`, only unstarred projects are returned.\n                `None` disables this filter.\n            tags_in: Returned projects should have at least one of these tags.\n            organization_id: Returned projects should belong to this organization.\n            fields: All the fields to request among the possible fields for the projects.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields.\n            first: Maximum number of projects to return.\n            skip: Number of projects to skip (they are ordered by their creation).\n            disable_tqdm: If `True`, the progress bar will be disabled.\n            as_generator: If `True`, a generator on the projects is returned.\n            deleted: If `True`, all projects are returned (including deleted ones).\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            A list of projects or a generator of projects if `as_generator` is `True`.\n\n        Examples:\n            &gt;&gt;&gt; # List all my projects\n            &gt;&gt;&gt; kili.projects()\n        \"\"\"\n        tag_ids = (\n            TagUseCases(self.kili_api_gateway).get_tag_ids_from_labels(tags_in) if tags_in else None\n        )\n\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n\n        projects_gen = ProjectUseCases(self.kili_api_gateway).list_projects(\n            ProjectFilters(\n                id=ProjectId(project_id) if project_id else None,\n                archived=archived,\n                search_query=search_query,\n                should_relaunch_kpi_computation=should_relaunch_kpi_computation,\n                starred=starred,\n                updated_at_gte=updated_at_gte,\n                updated_at_lte=updated_at_lte,\n                created_at_gte=None,\n                created_at_lte=None,\n                organization_id=organization_id,\n                tag_ids=tag_ids,\n                deleted=deleted,\n            ),\n            fields,\n            options=QueryOptions(disable_tqdm=disable_tqdm, first=first, skip=skip),\n        )\n\n        if as_generator:\n            return projects_gen\n        return list(projects_gen)\n\n    @typechecked\n    # pylint: disable=too-many-arguments,too-many-locals\n    def update_properties_in_project(\n        self,\n        project_id: str,\n        can_navigate_between_assets: Optional[bool] = None,\n        can_skip_asset: Optional[bool] = None,\n        compliance_tags: Optional[ListOrTuple[ComplianceTag]] = None,\n        consensus_mark: Optional[float] = None,\n        consensus_tot_coverage: Optional[int] = None,\n        description: Optional[str] = None,\n        honeypot_mark: Optional[float] = None,\n        instructions: Optional[str] = None,\n        input_type: Optional[InputType] = None,\n        json_interface: Optional[dict] = None,\n        min_consensus_size: Optional[int] = None,\n        review_coverage: Optional[int] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        title: Optional[str] = None,\n        use_honeypot: Optional[bool] = None,\n        metadata_types: Optional[dict] = None,\n        metadata_properties: Optional[dict] = None,\n        seconds_to_label_before_auto_assign: Optional[int] = None,\n        should_auto_assign: Optional[bool] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update properties of a project.\n\n        Args:\n            project_id: Identifier of the project.\n            can_navigate_between_assets:\n                Activate / Deactivate the use of next and previous buttons in labeling interface.\n            can_skip_asset: Activate / Deactivate the use of skip button in labeling interface.\n            compliance_tags: Compliance tags of the project.\n                Compliance tags are used to categorize projects based on the sensitivity of\n                the data being handled and the legal constraints associated with it.\n                Possible values are: `PHI` and `PII`.\n            consensus_mark: Should be between 0 and 1.\n            consensus_tot_coverage: Should be between 0 and 100.\n                It is the percentage of the dataset that will be annotated several times.\n            description: Description of the project.\n            honeypot_mark: Should be between 0 and 1\n            instructions: Instructions of the project.\n            input_type: Currently, one of `IMAGE`, `PDF`, `TEXT` or `VIDEO`.\n            json_interface: The json parameters of the project, see Edit your interface.\n            min_consensus_size: Should be between 1 and 10\n                Number of people that will annotate the same asset, for consensus computation.\n            review_coverage: Allow to set the percentage of assets\n                that will be queued in the review interface.\n                Should be between 0 and 100\n            should_relaunch_kpi_computation: Technical field, added to indicate changes\n                in honeypot or consensus settings\n            title: Title of the project\n            use_honeypot: Activate / Deactivate the use of honeypot in the project\n            metadata_types: DEPRECATED. Types of the project metadata.\n                Should be a `dict` of metadata fields name as keys and metadata types as values.\n                Currently, possible types are: `string`, `number`\n            metadata_properties: Properties of the project metadata.\n                Should be a `dict` of metadata fields name as keys and metadata properties as values.\n                These are necessary for asset filtering\n                Each property is a dict with the following keys:\n                    - `type`: Type of the metadata. Currently, possible types are: `string`, `number`, `date`\n                    - `filterable`: If `True`, the metadata can be used as filters in project queue\n                    - `visibleByLabeler`: If `True`, the metadata is visible one the asset by labelers\n                    - `visibleByReviewer`: If `True`, the metadata is visible one the asset by reviewers\n            seconds_to_label_before_auto_assign: DEPRECATED, use `should_auto_assign` instead.\n            should_auto_assign: If `True`, assets are automatically assigned to users when they start annotating.\n\n        Returns:\n            A dict with the changed properties which indicates if the mutation was successful,\n                else an error message.\n\n        !!! example \"Change Metadata Properties\"\n            The metadata properties of the project have to be defined to allow for application filters on\n            metadata. It's needed to know how to interpret the values (string, number or dates).\n\n            To define the properties of a metadata field, you can use the `update_properties_in_project`\n            function with the `metadata_properties` argument. `metadata_properties` is given as a dict\n            of metadata field names as keys and metadata properties as values.\n\n            ```python\n            kili.update_properties_in_project(\n                project_id = project_id,\n                metadata_properties = {\n                    'customConsensus': {\n                        'filterable': True,\n                        'type': 'number',\n                        'visibleByLabeler': True,\n                        'visibleByReviewer': True,\n                    },\n                    'sensitiveData': {\n                        'filterable': True,\n                        'type': 'string',\n                        'visibleByLabeler': False,\n                        'visibleByReviewer': True,\n                    },\n                    'date': {\n                        'filterable': True,\n                        'type': 'date',\n                        'visibleByLabeler': False,\n                        'visibleByReviewer': True,\n                    },\n                }\n            )\n            ```\n\n            If you don't define all values for a given key when setting the metadata properties default\n            values will be used :Not providing a property or providing an unsupported one will use the\n            default values:\n            ```\n            filterable: True\n            type: 'string'\n            visibleByLabeler: True\n            visibleByReviewer: True\n            ```\n\n        !!! note \"Deprecated: Change Metadata Types\"\n            The `metadata_types` parameter is deprecated. Please use `metadata_properties` instead.\n        \"\"\"\n        if seconds_to_label_before_auto_assign is not None:\n            warnings.warn(\n                \"seconds_to_label_before_auto_assign is going to be deprecated. Please use\"\n                \" `should_auto_assign` field instead to auto assign assets\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n\n        if metadata_types is not None:\n            warnings.warn(\n                \"metadata_types is going to be deprecated. Please use\"\n                \" `metadata_properties` field instead to configure metadata properties.\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n\n        return ProjectUseCases(self.kili_api_gateway).update_properties_in_project(\n            ProjectId(project_id),\n            can_navigate_between_assets=can_navigate_between_assets,\n            can_skip_asset=can_skip_asset,\n            compliance_tags=compliance_tags,\n            consensus_mark=consensus_mark,\n            consensus_tot_coverage=consensus_tot_coverage,\n            description=description,\n            honeypot_mark=honeypot_mark,\n            instructions=instructions,\n            input_type=input_type,\n            json_interface=json_interface,\n            min_consensus_size=min_consensus_size,\n            review_coverage=review_coverage,\n            should_relaunch_kpi_computation=should_relaunch_kpi_computation,\n            use_honeypot=use_honeypot,\n            title=title,\n            metadata_types=metadata_types,\n            metadata_properties=metadata_properties,\n            should_auto_assign=should_auto_assign,\n            seconds_to_label_before_auto_assign=seconds_to_label_before_auto_assign,\n        )\n\n    @typechecked\n    # pylint: disable=too-many-arguments\n    def count_projects(\n        self,\n        project_id: Optional[str] = None,\n        search_query: Optional[str] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        archived: Optional[bool] = None,\n        deleted: Optional[bool] = None,\n        organization_id: Optional[str] = None,\n        starred: Optional[bool] = None,\n        tags_in: Optional[ListOrTuple[str]] = None,\n    ) -&gt; int:\n        # pylint: disable=line-too-long\n        \"\"\"Count the number of projects with a search_query.\n\n        Args:\n            project_id: Select a specific project through its project_id.\n            search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n            should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot\n                or consensus settings\n            updated_at_gte: Returned projects should have a label\n                whose update date is greater\n                or equal to this date.\n            updated_at_lte: Returned projects should have a label\n                whose update date is lower or equal to this date.\n            archived: If `True`, only archived projects are returned, if `False`, only active projects are returned.\n                None disable this filter.\n            deleted: If `True` all projects are counted (including deleted ones).\n            organization_id: Filter projects by organization identifier.\n            starred: If `True`, only starred projects are returned, if `False`, only non-starred projects are returned.\n                None disable this filter.\n            tags_in: Returned projects should have at least one tag that belongs to that list, if given.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            The number of projects with the parameters provided\n        \"\"\"\n        tag_ids = (\n            TagUseCases(self.kili_api_gateway).get_tag_ids_from_labels(tags_in) if tags_in else None\n        )\n        return ProjectUseCases(self.kili_api_gateway).count_projects(\n            ProjectFilters(\n                id=ProjectId(project_id) if project_id else None,\n                search_query=search_query,\n                should_relaunch_kpi_computation=should_relaunch_kpi_computation,\n                updated_at_gte=updated_at_gte,\n                updated_at_lte=updated_at_lte,\n                archived=archived,\n                deleted=deleted,\n                organization_id=organization_id,\n                starred=starred,\n                tag_ids=tag_ids,\n            )\n        )\n</code></pre> <p>Set of Project mutations.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass MutationsProject(BaseOperationEntrypointMixin):\n    \"\"\"Set of Project mutations.\"\"\"\n\n    @typechecked\n    def append_to_roles(\n        self,\n        project_id: str,\n        user_email: str,\n        role: Literal[\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"] = \"LABELER\",\n    ) -&gt; Dict:\n        \"\"\"Add a user to a project.\n\n        !!! info\n            If the user does not exist in your organization, he/she is invited and added\n                both to your organization and project. This function can also be used to change\n                the role of the user in the project.\n\n        Args:\n            project_id: Identifier of the project\n            user_email: The email of the user.\n                This email is used as the unique identifier of the user.\n            role: The role of the user.\n\n        Returns:\n            A dictionary with the project user information.\n\n\n        Examples:\n            &gt;&gt;&gt; kili.append_to_roles(project_id=project_id, user_email='john@doe.com')\n        \"\"\"\n        variables = {\n            \"data\": {\"role\": role, \"userEmail\": user_email},\n            \"where\": {\"id\": project_id},\n        }\n        result = self.graphql_client.execute(GQL_APPEND_TO_ROLES, variables)\n\n        project_data = self.format_result(\"data\", result)\n        for project_user in project_data[\"roles\"]:\n            if project_user[\"user\"][\"email\"] == user_email.lower() and project_user[\"role\"] == role:\n                return project_user\n\n        raise MutationError(\n            f\"Failed to mutate user {user_email} to role {role} for project {project_id}.\"\n        )\n\n    @typechecked\n    def update_properties_in_project_user(\n        self,\n        project_id: str,\n        user_email: str,\n        role: Literal[\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"],\n    ) -&gt; Dict:\n        \"\"\"Update properties of a role.\n\n        !!! info\n            To be able to change someone's role, you must be either of:\n\n            - an admin of the project\n            - a team manager of the project\n            - an admin of the organization\n\n        Args:\n            project_id: Identifier of the project\n            user_email: The email of the user with updated role\n            role: The new role.\n                Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER`\n\n        Returns:\n            A dictionary with the project user information.\n        \"\"\"\n        variables = {\n            \"data\": {\n                \"role\": role,\n            },\n            \"where\": {\"project\": {\"id\": project_id}, \"user\": {\"email\": user_email}},\n        }\n        result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT_USER, variables)\n        return self.format_result(\"data\", result)\n\n    @deprecated(\"use update_properties_in_project_user instead\")\n    def update_properties_in_role(\n        self, role_id: str, project_id: str, user_id: str, role: str\n    ) -&gt; Dict:\n        \"\"\"Update properties of a role.\n\n        !!! info\n            To be able to change someone's role, you must be either of:\n\n            - an admin of the project\n            - a team manager of the project\n            - an admin of the organization\n\n        Args:\n            role_id: Role identifier of the user. E.g. : 'to-be-deactivated'\n            project_id: Identifier of the project\n            user_id: The email or identifier of the user with updated role\n            role: The new role.\n                Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER`\n\n        Returns:\n            A dictionary with the project user information.\n        \"\"\"\n        variables = {\n            \"roleID\": role_id,\n            \"projectID\": project_id,\n            \"userID\": user_id,\n            \"role\": role,\n        }\n        result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_ROLE, variables)\n        return self.format_result(\"data\", result)\n\n    @typechecked\n    def delete_from_roles(\n        self,\n        role_id: Optional[str] = None,\n        user_email: Optional[str] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Dict[Literal[\"id\"], str]:\n        \"\"\"Delete users by their role_id.\n\n        Args:\n            role_id: Identifier of the project user (not the ID of the user).\n                If not provided, user_email and project_id must be provided.\n            user_email: The email of the user to remove. Required if role_id is not provided.\n            project_id: Identifier of the project. Required if role_id is not provided.\n\n        Returns:\n            A dict with the project id.\n        \"\"\"\n        variables = None\n        if role_id:\n            variables = {\"where\": {\"id\": role_id}}\n        else:\n            if user_email is None or project_id is None:\n                raise ValueError(\n                    \"If role_id is not provided, you must provide user_email and project_id.\"\n                )\n            variables = {\"where\": {\"project\": {\"id\": project_id}, \"user\": {\"email\": user_email}}}\n        result = self.graphql_client.execute(GQL_DELETE_FROM_ROLES, variables)\n        return self.format_result(\"data\", result)\n\n    @typechecked\n    def delete_project(self, project_id: str) -&gt; str:\n        \"\"\"Delete a project permanently.\n\n        Args:\n            project_id: Identifier of the project\n\n        Returns:\n            A string with the deleted project id.\n        \"\"\"\n        variables = {\"where\": {\"id\": project_id}}\n        result = self.graphql_client.execute(GQL_PROJECT_DELETE_ASYNCHRONOUSLY, variables)\n        return self.format_result(\"data\", result)\n\n    @typechecked\n    def archive_project(self, project_id: str) -&gt; Dict[Literal[\"id\"], str]:\n        \"\"\"Archive a project.\n\n        Args:\n            project_id: Identifier of the project.\n\n        Returns:\n            A dict with the id of the project.\n        \"\"\"\n        variables = {\n            \"projectID\": project_id,\n            \"archived\": True,\n        }\n\n        result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n\n        return self.format_result(\"data\", result)\n\n    @typechecked\n    def unarchive_project(self, project_id: str) -&gt; Dict[Literal[\"id\"], str]:\n        \"\"\"Unarchive a project.\n\n        Args:\n            project_id: Identifier of the project\n\n        Returns:\n            A dict with the id of the project.\n        \"\"\"\n        variables = {\n            \"projectID\": project_id,\n            \"archived\": False,\n        }\n\n        result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n        return self.format_result(\"data\", result)\n\n    @typechecked\n    def copy_project(  # pylint: disable=too-many-arguments\n        self,\n        from_project_id: str,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        copy_json_interface: bool = True,\n        copy_quality_settings: bool = True,\n        copy_members: bool = True,\n        copy_assets: bool = False,\n        copy_labels: bool = False,\n        disable_tqdm: Optional[bool] = None,\n    ) -&gt; str:\n        \"\"\"Create new project from an existing project.\n\n        Args:\n            from_project_id: Project ID to copy from.\n            title: Title for the new project. Defaults to source project\n                title if `None` is provided.\n            description: Description for the new project. Defaults to empty string\n                if `None` is provided.\n            copy_json_interface: Deprecated. Always include json interface in the copy.\n            copy_quality_settings: Deprecated. Always include quality settings in the copy.\n            copy_members: Include members in the copy.\n            copy_assets: Include assets in the copy.\n            copy_labels: Include labels in the copy.\n            disable_tqdm: Disable tqdm progress bars.\n\n        Returns:\n            The created project ID.\n\n        Examples:\n            &gt;&gt;&gt; kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\")\n        \"\"\"\n        if (not copy_json_interface) or (not copy_quality_settings):\n            raise ValueError(\n                \"The 'copy_json_interface' and 'copy_quality_settings' arguments are deprecated.\"\n            )\n\n        return ProjectCopier(self).copy_project(  # pyright: ignore[reportGeneralTypeIssues]\n            from_project_id,\n            title,\n            description,\n            copy_members,\n            copy_assets,\n            copy_labels,\n            disable_tqdm,\n        )\n\n    @typechecked\n    def update_project_anonymization(\n        self, project_id: str, should_anonymize: bool = True\n    ) -&gt; Dict[Literal[\"id\"], str]:\n        \"\"\"Anonymize the project for the labelers and reviewers.\n\n        !!! info\n            Compatible with versions of the Kili app &gt;= 2.135.0\n\n        Args:\n            project_id: Identifier of the project\n            should_anonymize: The value to be applied. Defaults to `True`.\n\n        Returns:\n            A dict with the id of the project which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_project_anonymization(project_id=project_id)\n            &gt;&gt;&gt; kili.update_project_anonymization(project_id=project_id, should_anonymize=False)\n        \"\"\"\n        variables = {\n            \"input\": {\n                \"id\": project_id,\n                \"shouldAnonymize\": should_anonymize,\n            }\n        }\n\n        result = self.graphql_client.execute(GQL_PROJECT_UPDATE_ANONYMIZATION, variables)\n        return self.format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.presentation.client.project.ProjectClientMethods.count_projects","title":"<code>count_projects(self, project_id=None, search_query=None, should_relaunch_kpi_computation=None, updated_at_gte=None, updated_at_lte=None, archived=None, deleted=None, organization_id=None, starred=None, tags_in=None)</code>","text":"<p>Count the number of projects with a search_query.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>Optional[str]</code> <p>Select a specific project through its project_id.</p> <code>None</code> <code>search_query</code> <code>Optional[str]</code> <p>Returned projects with a title or a description matching this PostgreSQL ILIKE pattern.</p> <code>None</code> <code>should_relaunch_kpi_computation</code> <code>Optional[bool]</code> <p>Technical field, added to indicate changes in honeypot or consensus settings</p> <code>None</code> <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is greater or equal to this date.</p> <code>None</code> <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is lower or equal to this date.</p> <code>None</code> <code>archived</code> <code>Optional[bool]</code> <p>If <code>True</code>, only archived projects are returned, if <code>False</code>, only active projects are returned. None disable this filter.</p> <code>None</code> <code>deleted</code> <code>Optional[bool]</code> <p>If <code>True</code> all projects are counted (including deleted ones).</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Filter projects by organization identifier.</p> <code>None</code> <code>starred</code> <code>Optional[bool]</code> <p>If <code>True</code>, only starred projects are returned, if <code>False</code>, only non-starred projects are returned. None disable this filter.</p> <code>None</code> <code>tags_in</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Returned projects should have at least one tag that belongs to that list, if given.</p> <code>None</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of projects with the parameters provided</p> Source code in <code>kili/presentation/client/project.py</code> <pre><code>def count_projects(\n    self,\n    project_id: Optional[str] = None,\n    search_query: Optional[str] = None,\n    should_relaunch_kpi_computation: Optional[bool] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n    archived: Optional[bool] = None,\n    deleted: Optional[bool] = None,\n    organization_id: Optional[str] = None,\n    starred: Optional[bool] = None,\n    tags_in: Optional[ListOrTuple[str]] = None,\n) -&gt; int:\n    # pylint: disable=line-too-long\n    \"\"\"Count the number of projects with a search_query.\n\n    Args:\n        project_id: Select a specific project through its project_id.\n        search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n        should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot\n            or consensus settings\n        updated_at_gte: Returned projects should have a label\n            whose update date is greater\n            or equal to this date.\n        updated_at_lte: Returned projects should have a label\n            whose update date is lower or equal to this date.\n        archived: If `True`, only archived projects are returned, if `False`, only active projects are returned.\n            None disable this filter.\n        deleted: If `True` all projects are counted (including deleted ones).\n        organization_id: Filter projects by organization identifier.\n        starred: If `True`, only starred projects are returned, if `False`, only non-starred projects are returned.\n            None disable this filter.\n        tags_in: Returned projects should have at least one tag that belongs to that list, if given.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        The number of projects with the parameters provided\n    \"\"\"\n    tag_ids = (\n        TagUseCases(self.kili_api_gateway).get_tag_ids_from_labels(tags_in) if tags_in else None\n    )\n    return ProjectUseCases(self.kili_api_gateway).count_projects(\n        ProjectFilters(\n            id=ProjectId(project_id) if project_id else None,\n            search_query=search_query,\n            should_relaunch_kpi_computation=should_relaunch_kpi_computation,\n            updated_at_gte=updated_at_gte,\n            updated_at_lte=updated_at_lte,\n            archived=archived,\n            deleted=deleted,\n            organization_id=organization_id,\n            starred=starred,\n            tag_ids=tag_ids,\n        )\n    )\n</code></pre>"},{"location":"sdk/project/#kili.presentation.client.project.ProjectClientMethods.create_project","title":"<code>create_project(self, title, description='', input_type=None, json_interface=None, project_id=None, tags=None, compliance_tags=None, from_demo_project=None)</code>","text":"<p>Create a project.</p> <p>Parameters:</p> Name Type Description Default <code>input_type</code> <code>Optional[Literal['IMAGE', 'GEOSPATIAL', 'PDF', 'TEXT', 'VIDEO', 'LLM_RLHF', 'LLM_INSTR_FOLLOWING', 'LLM_STATIC']]</code> <p>Currently, one of <code>IMAGE</code>, <code>PDF</code>, <code>TEXT</code> or <code>VIDEO</code>.</p> <code>None</code> <code>json_interface</code> <code>Optional[Dict]</code> <p>The json parameters of the project, see Edit your interface.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title of the project.</p> required <code>description</code> <code>str</code> <p>Description of the project.</p> <code>''</code> <code>project_id</code> <code>Optional[ProjectId]</code> <p>Identifier of the project to copy.</p> <code>None</code> <code>tags</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Tags to add to the project. The tags must already exist in the organization.</p> <code>None</code> <code>compliance_tags</code> <code>Union[List[Literal['PHI', 'PII']], Tuple[Literal['PHI', 'PII'], ...]]</code> <p>Compliance tags of the project. Compliance tags are used to categorize projects based on the sensitivity of the data being handled and the legal constraints associated with it. Possible values are: <code>PHI</code> and <code>PII</code>.</p> <code>None</code> <code>from_demo_project</code> <code>Optional[Literal['DEMO_COMPUTER_VISION_TUTORIAL', 'DEMO_TEXT_TUTORIAL', 'DEMO_PDF_TUTORIAL', 'VIDEO_FRAME_OBJECT_TRACKING', 'DEMO_SEGMENTATION_COCO', 'DEMO_NER', 'DEMO_ID_OCR', 'DEMO_REVIEWS', 'DEMO_OCR', 'DEMO_NER_TWEETS', 'DEMO_PLASTIC', 'DEMO_CHATBOT', 'DEMO_PDF', 'DEMO_ANIMALS', 'DEMO_LLM', 'DEMO_LLM_INSTR_FOLLOWING', 'DEMO_SEGMENTATION']]</code> <p>Currently, one of:</p> <ul> <li><code>DEMO_COMPUTER_VISION_TUTORIAL</code></li> <li><code>DEMO_TEXT_TUTORIAL</code></li> <li><code>DEMO_PDF_TUTORIAL</code></li> <li><code>VIDEO_FRAME_OBJECT_TRACKING</code></li> <li><code>DEMO_SEGMENTATION_COCO</code></li> <li><code>DEMO_NER</code></li> <li><code>DEMO_ID_OCR</code></li> <li><code>DEMO_REVIEWS</code></li> <li><code>DEMO_OCR</code></li> <li><code>DEMO_NER_TWEETS</code></li> <li><code>DEMO_PLASTIC</code></li> <li><code>DEMO_CHATBOT</code></li> <li><code>DEMO_PDF</code></li> <li><code>DEMO_ANIMALS</code></li> <li><code>DEMO_LLM</code></li> <li><code>DEMO_LLM_INSTR_FOLLOWING</code></li> <li><code>DEMO_SEGMENTATION</code></li> </ul> <code>None</code> <p>Returns:</p> Type Description <code>Dict[Literal['id'], str]</code> <p>A dict with the id of the created project.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example')\n</code></pre> <p>Recipe</p> <p>For more detailed examples on how to create projects,     see the recipe.</p> Source code in <code>kili/presentation/client/project.py</code> <pre><code>def create_project(\n    self,\n    title: str,\n    description: str = \"\",\n    input_type: Optional[InputType] = None,\n    json_interface: Optional[Dict] = None,\n    project_id: Optional[ProjectId] = None,\n    tags: Optional[ListOrTuple[str]] = None,\n    compliance_tags: Optional[ListOrTuple[ComplianceTag]] = None,\n    from_demo_project: Optional[DemoProjectType] = None,\n) -&gt; Dict[Literal[\"id\"], str]:\n    \"\"\"Create a project.\n\n    Args:\n        input_type: Currently, one of `IMAGE`, `PDF`, `TEXT` or `VIDEO`.\n        json_interface: The json parameters of the project, see Edit your interface.\n        title: Title of the project.\n        description: Description of the project.\n        project_id: Identifier of the project to copy.\n        tags: Tags to add to the project. The tags must already exist in the organization.\n        compliance_tags: Compliance tags of the project.\n            Compliance tags are used to categorize projects based on the sensitivity of\n            the data being handled and the legal constraints associated with it.\n            Possible values are: `PHI` and `PII`.\n        from_demo_project: Currently, one of:\n\n            - `DEMO_COMPUTER_VISION_TUTORIAL`\n            - `DEMO_TEXT_TUTORIAL`\n            - `DEMO_PDF_TUTORIAL`\n            - `VIDEO_FRAME_OBJECT_TRACKING`\n            - `DEMO_SEGMENTATION_COCO`\n            - `DEMO_NER`\n            - `DEMO_ID_OCR`\n            - `DEMO_REVIEWS`\n            - `DEMO_OCR`\n            - `DEMO_NER_TWEETS`\n            - `DEMO_PLASTIC`\n            - `DEMO_CHATBOT`\n            - `DEMO_PDF`\n            - `DEMO_ANIMALS`\n            - `DEMO_LLM`\n            - `DEMO_LLM_INSTR_FOLLOWING`\n            - `DEMO_SEGMENTATION`\n\n    Returns:\n        A dict with the id of the created project.\n\n    Examples:\n        &gt;&gt;&gt; kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example')\n\n    !!! example \"Recipe\"\n        For more detailed examples on how to create projects,\n            see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project).\n    \"\"\"\n    project_id = ProjectUseCases(self.kili_api_gateway).create_project(\n        input_type=input_type,\n        json_interface=json_interface,\n        title=title,\n        description=description,\n        project_id=project_id,\n        compliance_tags=compliance_tags,\n        from_demo_project=from_demo_project,\n    )\n\n    if tags is not None:\n        tag_use_cases = TagUseCases(self.kili_api_gateway)\n        tag_ids = tag_use_cases.get_tag_ids_from_labels(labels=tags)\n        tag_use_cases.tag_project(\n            project_id=project_id, tag_ids=cast(ListOrTuple[TagId], tag_ids), disable_tqdm=True\n        )\n\n    return {\"id\": project_id}\n</code></pre>"},{"location":"sdk/project/#kili.presentation.client.project.ProjectClientMethods.projects","title":"<code>projects(self, project_id=None, search_query=None, should_relaunch_kpi_computation=None, updated_at_gte=None, updated_at_lte=None, archived=None, starred=None, tags_in=None, organization_id=None, fields=('consensusTotCoverage', 'id', 'inputType', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title'), deleted=None, first=None, skip=0, disable_tqdm=None, *, as_generator=False)</code>","text":"<p>Get a generator or a list of projects that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>Optional[str]</code> <p>Select a specific project through its project_id.</p> <code>None</code> <code>search_query</code> <code>Optional[str]</code> <p>Returned projects with a title or a description matching this PostgreSQL ILIKE pattern.</p> <code>None</code> <code>should_relaunch_kpi_computation</code> <code>Optional[bool]</code> <p>Deprecated, do not use.</p> <code>None</code> <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is greater or equal to this date.</p> <code>None</code> <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is lower or equal to this date.</p> <code>None</code> <code>archived</code> <code>Optional[bool]</code> <p>If <code>True</code>, only archived projects are returned, if <code>False</code>, only active projects are returned. <code>None</code> disables this filter.</p> <code>None</code> <code>starred</code> <code>Optional[bool]</code> <p>If <code>True</code>, only starred projects are returned, if <code>False</code>, only unstarred projects are returned. <code>None</code> disables this filter.</p> <code>None</code> <code>tags_in</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Returned projects should have at least one of these tags.</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Returned projects should belong to this organization.</p> <code>None</code> <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the projects. See the documentation for all possible fields.</p> <code>('consensusTotCoverage', 'id', 'inputType', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title')</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of projects to return.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of projects to skip (they are ordered by their creation).</p> <code>0</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled.</p> <code>None</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the projects is returned.</p> <code>False</code> <code>deleted</code> <code>Optional[bool]</code> <p>If <code>True</code>, all projects are returned (including deleted ones).</p> <code>None</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A list of projects or a generator of projects if <code>as_generator</code> is <code>True</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # List all my projects\n&gt;&gt;&gt; kili.projects()\n</code></pre> Source code in <code>kili/presentation/client/project.py</code> <pre><code>def projects(\n    self,\n    project_id: Optional[str] = None,\n    search_query: Optional[str] = None,\n    should_relaunch_kpi_computation: Optional[bool] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n    archived: Optional[bool] = None,\n    starred: Optional[bool] = None,\n    tags_in: Optional[ListOrTuple[str]] = None,\n    organization_id: Optional[str] = None,\n    fields: ListOrTuple[str] = (\n        \"consensusTotCoverage\",\n        \"id\",\n        \"inputType\",\n        \"jsonInterface\",\n        \"minConsensusSize\",\n        \"reviewCoverage\",\n        \"roles.id\",\n        \"roles.role\",\n        \"roles.user.email\",\n        \"roles.user.id\",\n        \"title\",\n    ),\n    deleted: Optional[bool] = None,\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: Optional[bool] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a generator or a list of projects that match a set of criteria.\n\n    Args:\n        project_id: Select a specific project through its project_id.\n        search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n        should_relaunch_kpi_computation: Deprecated, do not use.\n        updated_at_gte: Returned projects should have a label whose update date is greater or equal\n            to this date.\n        updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date.\n        archived: If `True`, only archived projects are returned, if `False`, only active projects are returned.\n            `None` disables this filter.\n        starred: If `True`, only starred projects are returned, if `False`, only unstarred projects are returned.\n            `None` disables this filter.\n        tags_in: Returned projects should have at least one of these tags.\n        organization_id: Returned projects should belong to this organization.\n        fields: All the fields to request among the possible fields for the projects.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields.\n        first: Maximum number of projects to return.\n        skip: Number of projects to skip (they are ordered by their creation).\n        disable_tqdm: If `True`, the progress bar will be disabled.\n        as_generator: If `True`, a generator on the projects is returned.\n        deleted: If `True`, all projects are returned (including deleted ones).\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        A list of projects or a generator of projects if `as_generator` is `True`.\n\n    Examples:\n        &gt;&gt;&gt; # List all my projects\n        &gt;&gt;&gt; kili.projects()\n    \"\"\"\n    tag_ids = (\n        TagUseCases(self.kili_api_gateway).get_tag_ids_from_labels(tags_in) if tags_in else None\n    )\n\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n\n    projects_gen = ProjectUseCases(self.kili_api_gateway).list_projects(\n        ProjectFilters(\n            id=ProjectId(project_id) if project_id else None,\n            archived=archived,\n            search_query=search_query,\n            should_relaunch_kpi_computation=should_relaunch_kpi_computation,\n            starred=starred,\n            updated_at_gte=updated_at_gte,\n            updated_at_lte=updated_at_lte,\n            created_at_gte=None,\n            created_at_lte=None,\n            organization_id=organization_id,\n            tag_ids=tag_ids,\n            deleted=deleted,\n        ),\n        fields,\n        options=QueryOptions(disable_tqdm=disable_tqdm, first=first, skip=skip),\n    )\n\n    if as_generator:\n        return projects_gen\n    return list(projects_gen)\n</code></pre>"},{"location":"sdk/project/#kili.presentation.client.project.ProjectClientMethods.update_properties_in_project","title":"<code>update_properties_in_project(self, project_id, can_navigate_between_assets=None, can_skip_asset=None, compliance_tags=None, consensus_mark=None, consensus_tot_coverage=None, description=None, honeypot_mark=None, instructions=None, input_type=None, json_interface=None, min_consensus_size=None, review_coverage=None, should_relaunch_kpi_computation=None, title=None, use_honeypot=None, metadata_types=None, metadata_properties=None, seconds_to_label_before_auto_assign=None, should_auto_assign=None)</code>","text":"<p>Update properties of a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>can_navigate_between_assets</code> <code>Optional[bool]</code> <p>Activate / Deactivate the use of next and previous buttons in labeling interface.</p> <code>None</code> <code>can_skip_asset</code> <code>Optional[bool]</code> <p>Activate / Deactivate the use of skip button in labeling interface.</p> <code>None</code> <code>compliance_tags</code> <code>Union[List[Literal['PHI', 'PII']], Tuple[Literal['PHI', 'PII'], ...]]</code> <p>Compliance tags of the project. Compliance tags are used to categorize projects based on the sensitivity of the data being handled and the legal constraints associated with it. Possible values are: <code>PHI</code> and <code>PII</code>.</p> <code>None</code> <code>consensus_mark</code> <code>Optional[float]</code> <p>Should be between 0 and 1.</p> <code>None</code> <code>consensus_tot_coverage</code> <code>Optional[int]</code> <p>Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Description of the project.</p> <code>None</code> <code>honeypot_mark</code> <code>Optional[float]</code> <p>Should be between 0 and 1</p> <code>None</code> <code>instructions</code> <code>Optional[str]</code> <p>Instructions of the project.</p> <code>None</code> <code>input_type</code> <code>Optional[Literal['IMAGE', 'GEOSPATIAL', 'PDF', 'TEXT', 'VIDEO', 'LLM_RLHF', 'LLM_INSTR_FOLLOWING', 'LLM_STATIC']]</code> <p>Currently, one of <code>IMAGE</code>, <code>PDF</code>, <code>TEXT</code> or <code>VIDEO</code>.</p> <code>None</code> <code>json_interface</code> <code>Optional[dict]</code> <p>The json parameters of the project, see Edit your interface.</p> <code>None</code> <code>min_consensus_size</code> <code>Optional[int]</code> <p>Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation.</p> <code>None</code> <code>review_coverage</code> <code>Optional[int]</code> <p>Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100</p> <code>None</code> <code>should_relaunch_kpi_computation</code> <code>Optional[bool]</code> <p>Technical field, added to indicate changes in honeypot or consensus settings</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title of the project</p> <code>None</code> <code>use_honeypot</code> <code>Optional[bool]</code> <p>Activate / Deactivate the use of honeypot in the project</p> <code>None</code> <code>metadata_types</code> <code>Optional[dict]</code> <p>DEPRECATED. Types of the project metadata. Should be a <code>dict</code> of metadata fields name as keys and metadata types as values. Currently, possible types are: <code>string</code>, <code>number</code></p> <code>None</code> <code>metadata_properties</code> <code>Optional[dict]</code> <p>Properties of the project metadata. Should be a <code>dict</code> of metadata fields name as keys and metadata properties as values. These are necessary for asset filtering Each property is a dict with the following keys:     - <code>type</code>: Type of the metadata. Currently, possible types are: <code>string</code>, <code>number</code>, <code>date</code>     - <code>filterable</code>: If <code>True</code>, the metadata can be used as filters in project queue     - <code>visibleByLabeler</code>: If <code>True</code>, the metadata is visible one the asset by labelers     - <code>visibleByReviewer</code>: If <code>True</code>, the metadata is visible one the asset by reviewers</p> <code>None</code> <code>seconds_to_label_before_auto_assign</code> <code>Optional[int]</code> <p>DEPRECATED, use <code>should_auto_assign</code> instead.</p> <code>None</code> <code>should_auto_assign</code> <code>Optional[bool]</code> <p>If <code>True</code>, assets are automatically assigned to users when they start annotating.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dict with the changed properties which indicates if the mutation was successful,     else an error message.</p> <p>Change Metadata Properties</p> <p>The metadata properties of the project have to be defined to allow for application filters on metadata. It's needed to know how to interpret the values (string, number or dates).</p> <p>To define the properties of a metadata field, you can use the <code>update_properties_in_project</code> function with the <code>metadata_properties</code> argument. <code>metadata_properties</code> is given as a dict of metadata field names as keys and metadata properties as values.</p> <pre><code>kili.update_properties_in_project(\n    project_id = project_id,\n    metadata_properties = {\n        'customConsensus': {\n            'filterable': True,\n            'type': 'number',\n            'visibleByLabeler': True,\n            'visibleByReviewer': True,\n        },\n        'sensitiveData': {\n            'filterable': True,\n            'type': 'string',\n            'visibleByLabeler': False,\n            'visibleByReviewer': True,\n        },\n        'date': {\n            'filterable': True,\n            'type': 'date',\n            'visibleByLabeler': False,\n            'visibleByReviewer': True,\n        },\n    }\n)\n</code></pre> <p>If you don't define all values for a given key when setting the metadata properties default values will be used :Not providing a property or providing an unsupported one will use the default values: <pre><code>filterable: True\ntype: 'string'\nvisibleByLabeler: True\nvisibleByReviewer: True\n</code></pre></p> <p>Deprecated: Change Metadata Types</p> <p>The <code>metadata_types</code> parameter is deprecated. Please use <code>metadata_properties</code> instead.</p> Source code in <code>kili/presentation/client/project.py</code> <pre><code>def update_properties_in_project(\n    self,\n    project_id: str,\n    can_navigate_between_assets: Optional[bool] = None,\n    can_skip_asset: Optional[bool] = None,\n    compliance_tags: Optional[ListOrTuple[ComplianceTag]] = None,\n    consensus_mark: Optional[float] = None,\n    consensus_tot_coverage: Optional[int] = None,\n    description: Optional[str] = None,\n    honeypot_mark: Optional[float] = None,\n    instructions: Optional[str] = None,\n    input_type: Optional[InputType] = None,\n    json_interface: Optional[dict] = None,\n    min_consensus_size: Optional[int] = None,\n    review_coverage: Optional[int] = None,\n    should_relaunch_kpi_computation: Optional[bool] = None,\n    title: Optional[str] = None,\n    use_honeypot: Optional[bool] = None,\n    metadata_types: Optional[dict] = None,\n    metadata_properties: Optional[dict] = None,\n    seconds_to_label_before_auto_assign: Optional[int] = None,\n    should_auto_assign: Optional[bool] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update properties of a project.\n\n    Args:\n        project_id: Identifier of the project.\n        can_navigate_between_assets:\n            Activate / Deactivate the use of next and previous buttons in labeling interface.\n        can_skip_asset: Activate / Deactivate the use of skip button in labeling interface.\n        compliance_tags: Compliance tags of the project.\n            Compliance tags are used to categorize projects based on the sensitivity of\n            the data being handled and the legal constraints associated with it.\n            Possible values are: `PHI` and `PII`.\n        consensus_mark: Should be between 0 and 1.\n        consensus_tot_coverage: Should be between 0 and 100.\n            It is the percentage of the dataset that will be annotated several times.\n        description: Description of the project.\n        honeypot_mark: Should be between 0 and 1\n        instructions: Instructions of the project.\n        input_type: Currently, one of `IMAGE`, `PDF`, `TEXT` or `VIDEO`.\n        json_interface: The json parameters of the project, see Edit your interface.\n        min_consensus_size: Should be between 1 and 10\n            Number of people that will annotate the same asset, for consensus computation.\n        review_coverage: Allow to set the percentage of assets\n            that will be queued in the review interface.\n            Should be between 0 and 100\n        should_relaunch_kpi_computation: Technical field, added to indicate changes\n            in honeypot or consensus settings\n        title: Title of the project\n        use_honeypot: Activate / Deactivate the use of honeypot in the project\n        metadata_types: DEPRECATED. Types of the project metadata.\n            Should be a `dict` of metadata fields name as keys and metadata types as values.\n            Currently, possible types are: `string`, `number`\n        metadata_properties: Properties of the project metadata.\n            Should be a `dict` of metadata fields name as keys and metadata properties as values.\n            These are necessary for asset filtering\n            Each property is a dict with the following keys:\n                - `type`: Type of the metadata. Currently, possible types are: `string`, `number`, `date`\n                - `filterable`: If `True`, the metadata can be used as filters in project queue\n                - `visibleByLabeler`: If `True`, the metadata is visible one the asset by labelers\n                - `visibleByReviewer`: If `True`, the metadata is visible one the asset by reviewers\n        seconds_to_label_before_auto_assign: DEPRECATED, use `should_auto_assign` instead.\n        should_auto_assign: If `True`, assets are automatically assigned to users when they start annotating.\n\n    Returns:\n        A dict with the changed properties which indicates if the mutation was successful,\n            else an error message.\n\n    !!! example \"Change Metadata Properties\"\n        The metadata properties of the project have to be defined to allow for application filters on\n        metadata. It's needed to know how to interpret the values (string, number or dates).\n\n        To define the properties of a metadata field, you can use the `update_properties_in_project`\n        function with the `metadata_properties` argument. `metadata_properties` is given as a dict\n        of metadata field names as keys and metadata properties as values.\n\n        ```python\n        kili.update_properties_in_project(\n            project_id = project_id,\n            metadata_properties = {\n                'customConsensus': {\n                    'filterable': True,\n                    'type': 'number',\n                    'visibleByLabeler': True,\n                    'visibleByReviewer': True,\n                },\n                'sensitiveData': {\n                    'filterable': True,\n                    'type': 'string',\n                    'visibleByLabeler': False,\n                    'visibleByReviewer': True,\n                },\n                'date': {\n                    'filterable': True,\n                    'type': 'date',\n                    'visibleByLabeler': False,\n                    'visibleByReviewer': True,\n                },\n            }\n        )\n        ```\n\n        If you don't define all values for a given key when setting the metadata properties default\n        values will be used :Not providing a property or providing an unsupported one will use the\n        default values:\n        ```\n        filterable: True\n        type: 'string'\n        visibleByLabeler: True\n        visibleByReviewer: True\n        ```\n\n    !!! note \"Deprecated: Change Metadata Types\"\n        The `metadata_types` parameter is deprecated. Please use `metadata_properties` instead.\n    \"\"\"\n    if seconds_to_label_before_auto_assign is not None:\n        warnings.warn(\n            \"seconds_to_label_before_auto_assign is going to be deprecated. Please use\"\n            \" `should_auto_assign` field instead to auto assign assets\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n\n    if metadata_types is not None:\n        warnings.warn(\n            \"metadata_types is going to be deprecated. Please use\"\n            \" `metadata_properties` field instead to configure metadata properties.\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n\n    return ProjectUseCases(self.kili_api_gateway).update_properties_in_project(\n        ProjectId(project_id),\n        can_navigate_between_assets=can_navigate_between_assets,\n        can_skip_asset=can_skip_asset,\n        compliance_tags=compliance_tags,\n        consensus_mark=consensus_mark,\n        consensus_tot_coverage=consensus_tot_coverage,\n        description=description,\n        honeypot_mark=honeypot_mark,\n        instructions=instructions,\n        input_type=input_type,\n        json_interface=json_interface,\n        min_consensus_size=min_consensus_size,\n        review_coverage=review_coverage,\n        should_relaunch_kpi_computation=should_relaunch_kpi_computation,\n        use_honeypot=use_honeypot,\n        title=title,\n        metadata_types=metadata_types,\n        metadata_properties=metadata_properties,\n        should_auto_assign=should_auto_assign,\n        seconds_to_label_before_auto_assign=seconds_to_label_before_auto_assign,\n    )\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.append_to_roles","title":"<code>append_to_roles(self, project_id, user_email, role='LABELER')</code>","text":"<p>Add a user to a project.</p> <p>Info</p> <p>If the user does not exist in your organization, he/she is invited and added     both to your organization and project. This function can also be used to change     the role of the user in the project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>user_email</code> <code>str</code> <p>The email of the user. This email is used as the unique identifier of the user.</p> required <code>role</code> <code>Literal['ADMIN', 'TEAM_MANAGER', 'REVIEWER', 'LABELER']</code> <p>The role of the user.</p> <code>'LABELER'</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary with the project user information.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_to_roles(project_id=project_id, user_email='john@doe.com')\n</code></pre> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>def append_to_roles(\n    self,\n    project_id: str,\n    user_email: str,\n    role: Literal[\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"] = \"LABELER\",\n) -&gt; Dict:\n    \"\"\"Add a user to a project.\n\n    !!! info\n        If the user does not exist in your organization, he/she is invited and added\n            both to your organization and project. This function can also be used to change\n            the role of the user in the project.\n\n    Args:\n        project_id: Identifier of the project\n        user_email: The email of the user.\n            This email is used as the unique identifier of the user.\n        role: The role of the user.\n\n    Returns:\n        A dictionary with the project user information.\n\n\n    Examples:\n        &gt;&gt;&gt; kili.append_to_roles(project_id=project_id, user_email='john@doe.com')\n    \"\"\"\n    variables = {\n        \"data\": {\"role\": role, \"userEmail\": user_email},\n        \"where\": {\"id\": project_id},\n    }\n    result = self.graphql_client.execute(GQL_APPEND_TO_ROLES, variables)\n\n    project_data = self.format_result(\"data\", result)\n    for project_user in project_data[\"roles\"]:\n        if project_user[\"user\"][\"email\"] == user_email.lower() and project_user[\"role\"] == role:\n            return project_user\n\n    raise MutationError(\n        f\"Failed to mutate user {user_email} to role {role} for project {project_id}.\"\n    )\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.archive_project","title":"<code>archive_project(self, project_id)</code>","text":"<p>Archive a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <p>Returns:</p> Type Description <code>Dict[Literal['id'], str]</code> <p>A dict with the id of the project.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>def archive_project(self, project_id: str) -&gt; Dict[Literal[\"id\"], str]:\n    \"\"\"Archive a project.\n\n    Args:\n        project_id: Identifier of the project.\n\n    Returns:\n        A dict with the id of the project.\n    \"\"\"\n    variables = {\n        \"projectID\": project_id,\n        \"archived\": True,\n    }\n\n    result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n\n    return self.format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.copy_project","title":"<code>copy_project(self, from_project_id, title=None, description=None, copy_json_interface=True, copy_quality_settings=True, copy_members=True, copy_assets=False, copy_labels=False, disable_tqdm=None)</code>","text":"<p>Create new project from an existing project.</p> <p>Parameters:</p> Name Type Description Default <code>from_project_id</code> <code>str</code> <p>Project ID to copy from.</p> required <code>title</code> <code>Optional[str]</code> <p>Title for the new project. Defaults to source project title if <code>None</code> is provided.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Description for the new project. Defaults to empty string if <code>None</code> is provided.</p> <code>None</code> <code>copy_json_interface</code> <code>bool</code> <p>Deprecated. Always include json interface in the copy.</p> <code>True</code> <code>copy_quality_settings</code> <code>bool</code> <p>Deprecated. Always include quality settings in the copy.</p> <code>True</code> <code>copy_members</code> <code>bool</code> <p>Include members in the copy.</p> <code>True</code> <code>copy_assets</code> <code>bool</code> <p>Include assets in the copy.</p> <code>False</code> <code>copy_labels</code> <code>bool</code> <p>Include labels in the copy.</p> <code>False</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>Disable tqdm progress bars.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The created project ID.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\")\n</code></pre> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>def copy_project(  # pylint: disable=too-many-arguments\n    self,\n    from_project_id: str,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    copy_json_interface: bool = True,\n    copy_quality_settings: bool = True,\n    copy_members: bool = True,\n    copy_assets: bool = False,\n    copy_labels: bool = False,\n    disable_tqdm: Optional[bool] = None,\n) -&gt; str:\n    \"\"\"Create new project from an existing project.\n\n    Args:\n        from_project_id: Project ID to copy from.\n        title: Title for the new project. Defaults to source project\n            title if `None` is provided.\n        description: Description for the new project. Defaults to empty string\n            if `None` is provided.\n        copy_json_interface: Deprecated. Always include json interface in the copy.\n        copy_quality_settings: Deprecated. Always include quality settings in the copy.\n        copy_members: Include members in the copy.\n        copy_assets: Include assets in the copy.\n        copy_labels: Include labels in the copy.\n        disable_tqdm: Disable tqdm progress bars.\n\n    Returns:\n        The created project ID.\n\n    Examples:\n        &gt;&gt;&gt; kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\")\n    \"\"\"\n    if (not copy_json_interface) or (not copy_quality_settings):\n        raise ValueError(\n            \"The 'copy_json_interface' and 'copy_quality_settings' arguments are deprecated.\"\n        )\n\n    return ProjectCopier(self).copy_project(  # pyright: ignore[reportGeneralTypeIssues]\n        from_project_id,\n        title,\n        description,\n        copy_members,\n        copy_assets,\n        copy_labels,\n        disable_tqdm,\n    )\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.delete_from_roles","title":"<code>delete_from_roles(self, role_id=None, user_email=None, project_id=None)</code>","text":"<p>Delete users by their role_id.</p> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>Optional[str]</code> <p>Identifier of the project user (not the ID of the user). If not provided, user_email and project_id must be provided.</p> <code>None</code> <code>user_email</code> <code>Optional[str]</code> <p>The email of the user to remove. Required if role_id is not provided.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>Identifier of the project. Required if role_id is not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[Literal['id'], str]</code> <p>A dict with the project id.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>def delete_from_roles(\n    self,\n    role_id: Optional[str] = None,\n    user_email: Optional[str] = None,\n    project_id: Optional[str] = None,\n) -&gt; Dict[Literal[\"id\"], str]:\n    \"\"\"Delete users by their role_id.\n\n    Args:\n        role_id: Identifier of the project user (not the ID of the user).\n            If not provided, user_email and project_id must be provided.\n        user_email: The email of the user to remove. Required if role_id is not provided.\n        project_id: Identifier of the project. Required if role_id is not provided.\n\n    Returns:\n        A dict with the project id.\n    \"\"\"\n    variables = None\n    if role_id:\n        variables = {\"where\": {\"id\": role_id}}\n    else:\n        if user_email is None or project_id is None:\n            raise ValueError(\n                \"If role_id is not provided, you must provide user_email and project_id.\"\n            )\n        variables = {\"where\": {\"project\": {\"id\": project_id}, \"user\": {\"email\": user_email}}}\n    result = self.graphql_client.execute(GQL_DELETE_FROM_ROLES, variables)\n    return self.format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.delete_project","title":"<code>delete_project(self, project_id)</code>","text":"<p>Delete a project permanently.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string with the deleted project id.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>def delete_project(self, project_id: str) -&gt; str:\n    \"\"\"Delete a project permanently.\n\n    Args:\n        project_id: Identifier of the project\n\n    Returns:\n        A string with the deleted project id.\n    \"\"\"\n    variables = {\"where\": {\"id\": project_id}}\n    result = self.graphql_client.execute(GQL_PROJECT_DELETE_ASYNCHRONOUSLY, variables)\n    return self.format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.unarchive_project","title":"<code>unarchive_project(self, project_id)</code>","text":"<p>Unarchive a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <p>Returns:</p> Type Description <code>Dict[Literal['id'], str]</code> <p>A dict with the id of the project.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>def unarchive_project(self, project_id: str) -&gt; Dict[Literal[\"id\"], str]:\n    \"\"\"Unarchive a project.\n\n    Args:\n        project_id: Identifier of the project\n\n    Returns:\n        A dict with the id of the project.\n    \"\"\"\n    variables = {\n        \"projectID\": project_id,\n        \"archived\": False,\n    }\n\n    result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n    return self.format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.update_project_anonymization","title":"<code>update_project_anonymization(self, project_id, should_anonymize=True)</code>","text":"<p>Anonymize the project for the labelers and reviewers.</p> <p>Info</p> <p>Compatible with versions of the Kili app &gt;= 2.135.0</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>should_anonymize</code> <code>bool</code> <p>The value to be applied. Defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[Literal['id'], str]</code> <p>A dict with the id of the project which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_project_anonymization(project_id=project_id)\n&gt;&gt;&gt; kili.update_project_anonymization(project_id=project_id, should_anonymize=False)\n</code></pre> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>def update_project_anonymization(\n    self, project_id: str, should_anonymize: bool = True\n) -&gt; Dict[Literal[\"id\"], str]:\n    \"\"\"Anonymize the project for the labelers and reviewers.\n\n    !!! info\n        Compatible with versions of the Kili app &gt;= 2.135.0\n\n    Args:\n        project_id: Identifier of the project\n        should_anonymize: The value to be applied. Defaults to `True`.\n\n    Returns:\n        A dict with the id of the project which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_project_anonymization(project_id=project_id)\n        &gt;&gt;&gt; kili.update_project_anonymization(project_id=project_id, should_anonymize=False)\n    \"\"\"\n    variables = {\n        \"input\": {\n            \"id\": project_id,\n            \"shouldAnonymize\": should_anonymize,\n        }\n    }\n\n    result = self.graphql_client.execute(GQL_PROJECT_UPDATE_ANONYMIZATION, variables)\n    return self.format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.update_properties_in_project_user","title":"<code>update_properties_in_project_user(self, project_id, user_email, role)</code>","text":"<p>Update properties of a role.</p> <p>Info</p> <p>To be able to change someone's role, you must be either of:</p> <ul> <li>an admin of the project</li> <li>a team manager of the project</li> <li>an admin of the organization</li> </ul> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>user_email</code> <code>str</code> <p>The email of the user with updated role</p> required <code>role</code> <code>Literal['ADMIN', 'TEAM_MANAGER', 'REVIEWER', 'LABELER']</code> <p>The new role. Possible choices are: <code>ADMIN</code>, <code>TEAM_MANAGER</code>, <code>REVIEWER</code>, <code>LABELER</code></p> required <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary with the project user information.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>def update_properties_in_project_user(\n    self,\n    project_id: str,\n    user_email: str,\n    role: Literal[\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"],\n) -&gt; Dict:\n    \"\"\"Update properties of a role.\n\n    !!! info\n        To be able to change someone's role, you must be either of:\n\n        - an admin of the project\n        - a team manager of the project\n        - an admin of the organization\n\n    Args:\n        project_id: Identifier of the project\n        user_email: The email of the user with updated role\n        role: The new role.\n            Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER`\n\n    Returns:\n        A dictionary with the project user information.\n    \"\"\"\n    variables = {\n        \"data\": {\n            \"role\": role,\n        },\n        \"where\": {\"project\": {\"id\": project_id}, \"user\": {\"email\": user_email}},\n    }\n    result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT_USER, variables)\n    return self.format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.update_properties_in_role","title":"<code>update_properties_in_role(self, role_id, project_id, user_id, role)</code>","text":"<p>Update properties of a role.</p> <p>Info</p> <p>To be able to change someone's role, you must be either of:</p> <ul> <li>an admin of the project</li> <li>a team manager of the project</li> <li>an admin of the organization</li> </ul> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>str</code> <p>Role identifier of the user. E.g. : 'to-be-deactivated'</p> required <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>user_id</code> <code>str</code> <p>The email or identifier of the user with updated role</p> required <code>role</code> <code>str</code> <p>The new role. Possible choices are: <code>ADMIN</code>, <code>TEAM_MANAGER</code>, <code>REVIEWER</code>, <code>LABELER</code></p> required <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary with the project user information.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>@deprecated(\"use update_properties_in_project_user instead\")\ndef update_properties_in_role(\n    self, role_id: str, project_id: str, user_id: str, role: str\n) -&gt; Dict:\n    \"\"\"Update properties of a role.\n\n    !!! info\n        To be able to change someone's role, you must be either of:\n\n        - an admin of the project\n        - a team manager of the project\n        - an admin of the organization\n\n    Args:\n        role_id: Role identifier of the user. E.g. : 'to-be-deactivated'\n        project_id: Identifier of the project\n        user_id: The email or identifier of the user with updated role\n        role: The new role.\n            Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER`\n\n    Returns:\n        A dictionary with the project user information.\n    \"\"\"\n    variables = {\n        \"roleID\": role_id,\n        \"projectID\": project_id,\n        \"userID\": user_id,\n        \"role\": role,\n    }\n    result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_ROLE, variables)\n    return self.format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project_user/","title":"Project User module","text":""},{"location":"sdk/project_user/#queries","title":"Queries","text":"<p>Set of ProjectUser queries.</p> Source code in <code>kili/entrypoints/queries/project_user/__init__.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass QueriesProjectUser(BaseOperationEntrypointMixin):\n    \"\"\"Set of ProjectUser queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,redefined-builtin\n\n    @overload\n    def project_users(\n        self,\n        project_id: str,\n        email: Optional[str] = None,\n        id: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        status_in: Optional[Sequence[Literal[\"ACTIVATED\", \"ORG_ADMIN\", \"ORG_SUSPENDED\"]]] = (\n            \"ACTIVATED\",\n            \"ORG_ADMIN\",\n        ),\n        fields: ListOrTuple[str] = (\n            \"activated\",\n            \"id\",\n            \"role\",\n            \"starred\",\n            \"user.email\",\n            \"user.id\",\n            \"status\",\n        ),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def project_users(\n        self,\n        project_id: str,\n        email: Optional[str] = None,\n        id: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        status_in: Optional[Sequence[Literal[\"ACTIVATED\", \"ORG_ADMIN\", \"ORG_SUSPENDED\"]]] = (\n            \"ACTIVATED\",\n            \"ORG_ADMIN\",\n        ),\n        fields: ListOrTuple[str] = (\n            \"activated\",\n            \"id\",\n            \"role\",\n            \"starred\",\n            \"user.email\",\n            \"user.id\",\n            \"status\",\n        ),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def project_users(\n        self,\n        project_id: str,\n        email: Optional[str] = None,\n        id: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        status_in: Optional[Sequence[Literal[\"ACTIVATED\", \"ORG_ADMIN\", \"ORG_SUSPENDED\"]]] = (\n            \"ACTIVATED\",\n            \"ORG_ADMIN\",\n        ),\n        fields: ListOrTuple[str] = (\n            \"activated\",\n            \"id\",\n            \"role\",\n            \"starred\",\n            \"user.email\",\n            \"user.id\",\n            \"status\",\n        ),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n        \"\"\"Return project users (possibly with their KPIs) that match a set of criteria.\n\n        Args:\n            project_id: Identifier of the project.\n            email: Email of the user.\n            id: Identifier of the user.\n            organization_id: Identifier of the user's organization.\n            status_in: If `None`, all users are returned.\n\n                - `ORG_ADMIN`: Is an Organization Admin. Is automatically added to projects.\n                - `ACTIVATED`: Has been invited to the project. Is not an Organization Admin\n                - `ORG_SUSPENDED`: Has been suspended at the organization level. Can no longer access any projects.\n            fields: All the fields to request among the possible fields for the projectUsers.\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/project-user) for all possible fields.\n            first: Maximum number of users to return.\n            skip: Number of project users to skip.\n            disable_tqdm: If `True`, the progress bar will be disabled.\n            as_generator: If `True`, a generator on the project users is returned.\n\n        Returns:\n            An iterable with the project users that match the criteria.\n\n        Examples:\n            ```python\n            # Retrieve consensus marks of all users in project\n            &gt;&gt;&gt; kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email'])\n            ```\n        \"\"\"\n        if status_in is not None and \"status\" not in fields:\n            fields = [*fields, \"status\"]\n\n        where = ProjectUserWhere(\n            project_id=project_id,\n            email=email,\n            _id=id,\n            organization_id=organization_id,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        project_users_gen = ProjectUserQuery(self.graphql_client, self.http_client)(\n            where, fields, options\n        )\n\n        if status_in is not None:\n            status_in_set = set(status_in)\n            project_users_gen = (\n                project_user\n                for project_user in project_users_gen\n                if project_user[\"status\"] in status_in_set\n            )\n\n        if as_generator:\n            return project_users_gen\n        return list(project_users_gen)\n\n    @typechecked\n    def count_project_users(\n        self,\n        project_id: str,\n        email: Optional[str] = None,\n        id: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        status_in: Optional[Sequence[Literal[\"ACTIVATED\", \"ORG_ADMIN\", \"ORG_SUSPENDED\"]]] = (\n            \"ACTIVATED\",\n            \"ORG_ADMIN\",\n        ),\n    ) -&gt; int:\n        \"\"\"Count the number of projects and their users that match a set of criteria.\n\n        Args:\n            project_id: Identifier of the project\n            email: Email of the user\n            id: Identifier of the user\n            organization_id: Identifier of the user's organization\n            status_in: If `None`, all users are returned.\n\n                - `ORG_ADMIN`: Is an Organization Admin. Is automatically added to projects.\n                - `ACTIVATED`: Has been invited to the project. Is not an Organization Admin\n                - `ORG_SUSPENDED`: Has been suspended at the organization level. Can no longer access any projects.\n\n        Returns:\n            The number of project users with the parameters provided\n        \"\"\"\n        if status_in is None:\n            where = ProjectUserWhere(\n                project_id=project_id,\n                email=email,\n                _id=id,\n                organization_id=organization_id,\n            )\n            return ProjectUserQuery(self.graphql_client, self.http_client).count(where)\n\n        count = 0\n        for status in set(status_in):\n            where = ProjectUserWhere(\n                project_id=project_id,\n                email=email,\n                _id=id,\n                organization_id=organization_id,\n                status=status,\n            )\n            count += ProjectUserQuery(self.graphql_client, self.http_client).count(where)\n        return count\n</code></pre>"},{"location":"sdk/project_user/#kili.entrypoints.queries.project_user.__init__.QueriesProjectUser.count_project_users","title":"<code>count_project_users(self, project_id, email=None, id=None, organization_id=None, status_in=('ACTIVATED', 'ORG_ADMIN'))</code>","text":"<p>Count the number of projects and their users that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>email</code> <code>Optional[str]</code> <p>Email of the user</p> <code>None</code> <code>id</code> <code>Optional[str]</code> <p>Identifier of the user</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization</p> <code>None</code> <code>status_in</code> <code>Optional[Sequence[Literal['ACTIVATED', 'ORG_ADMIN', 'ORG_SUSPENDED']]]</code> <p>If <code>None</code>, all users are returned.</p> <ul> <li><code>ORG_ADMIN</code>: Is an Organization Admin. Is automatically added to projects.</li> <li><code>ACTIVATED</code>: Has been invited to the project. Is not an Organization Admin</li> <li><code>ORG_SUSPENDED</code>: Has been suspended at the organization level. Can no longer access any projects.</li> </ul> <code>('ACTIVATED', 'ORG_ADMIN')</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of project users with the parameters provided</p> Source code in <code>kili/entrypoints/queries/project_user/__init__.py</code> <pre><code>def count_project_users(\n    self,\n    project_id: str,\n    email: Optional[str] = None,\n    id: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    status_in: Optional[Sequence[Literal[\"ACTIVATED\", \"ORG_ADMIN\", \"ORG_SUSPENDED\"]]] = (\n        \"ACTIVATED\",\n        \"ORG_ADMIN\",\n    ),\n) -&gt; int:\n    \"\"\"Count the number of projects and their users that match a set of criteria.\n\n    Args:\n        project_id: Identifier of the project\n        email: Email of the user\n        id: Identifier of the user\n        organization_id: Identifier of the user's organization\n        status_in: If `None`, all users are returned.\n\n            - `ORG_ADMIN`: Is an Organization Admin. Is automatically added to projects.\n            - `ACTIVATED`: Has been invited to the project. Is not an Organization Admin\n            - `ORG_SUSPENDED`: Has been suspended at the organization level. Can no longer access any projects.\n\n    Returns:\n        The number of project users with the parameters provided\n    \"\"\"\n    if status_in is None:\n        where = ProjectUserWhere(\n            project_id=project_id,\n            email=email,\n            _id=id,\n            organization_id=organization_id,\n        )\n        return ProjectUserQuery(self.graphql_client, self.http_client).count(where)\n\n    count = 0\n    for status in set(status_in):\n        where = ProjectUserWhere(\n            project_id=project_id,\n            email=email,\n            _id=id,\n            organization_id=organization_id,\n            status=status,\n        )\n        count += ProjectUserQuery(self.graphql_client, self.http_client).count(where)\n    return count\n</code></pre>"},{"location":"sdk/project_user/#kili.entrypoints.queries.project_user.__init__.QueriesProjectUser.project_users","title":"<code>project_users(self, project_id, email=None, id=None, organization_id=None, status_in=('ACTIVATED', 'ORG_ADMIN'), fields=('activated', 'id', 'role', 'starred', 'user.email', 'user.id', 'status'), first=None, skip=0, disable_tqdm=None, *, as_generator=False)</code>","text":"<p>Return project users (possibly with their KPIs) that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>email</code> <code>Optional[str]</code> <p>Email of the user.</p> <code>None</code> <code>id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization.</p> <code>None</code> <code>status_in</code> <code>Optional[Sequence[Literal['ACTIVATED', 'ORG_ADMIN', 'ORG_SUSPENDED']]]</code> <p>If <code>None</code>, all users are returned.</p> <ul> <li><code>ORG_ADMIN</code>: Is an Organization Admin. Is automatically added to projects.</li> <li><code>ACTIVATED</code>: Has been invited to the project. Is not an Organization Admin</li> <li><code>ORG_SUSPENDED</code>: Has been suspended at the organization level. Can no longer access any projects.</li> </ul> <code>('ACTIVATED', 'ORG_ADMIN')</code> <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the projectUsers. See the documentation for all possible fields.</p> <code>('activated', 'id', 'role', 'starred', 'user.email', 'user.id', 'status')</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of users to return.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of project users to skip.</p> <code>0</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled.</p> <code>None</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the project users is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>An iterable with the project users that match the criteria.</p> <p>Examples:</p> <pre><code># Retrieve consensus marks of all users in project\n&gt;&gt;&gt; kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email'])\n</code></pre> Source code in <code>kili/entrypoints/queries/project_user/__init__.py</code> <pre><code>def project_users(\n    self,\n    project_id: str,\n    email: Optional[str] = None,\n    id: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    status_in: Optional[Sequence[Literal[\"ACTIVATED\", \"ORG_ADMIN\", \"ORG_SUSPENDED\"]]] = (\n        \"ACTIVATED\",\n        \"ORG_ADMIN\",\n    ),\n    fields: ListOrTuple[str] = (\n        \"activated\",\n        \"id\",\n        \"role\",\n        \"starred\",\n        \"user.email\",\n        \"user.id\",\n        \"status\",\n    ),\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: Optional[bool] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n    \"\"\"Return project users (possibly with their KPIs) that match a set of criteria.\n\n    Args:\n        project_id: Identifier of the project.\n        email: Email of the user.\n        id: Identifier of the user.\n        organization_id: Identifier of the user's organization.\n        status_in: If `None`, all users are returned.\n\n            - `ORG_ADMIN`: Is an Organization Admin. Is automatically added to projects.\n            - `ACTIVATED`: Has been invited to the project. Is not an Organization Admin\n            - `ORG_SUSPENDED`: Has been suspended at the organization level. Can no longer access any projects.\n        fields: All the fields to request among the possible fields for the projectUsers.\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/project-user) for all possible fields.\n        first: Maximum number of users to return.\n        skip: Number of project users to skip.\n        disable_tqdm: If `True`, the progress bar will be disabled.\n        as_generator: If `True`, a generator on the project users is returned.\n\n    Returns:\n        An iterable with the project users that match the criteria.\n\n    Examples:\n        ```python\n        # Retrieve consensus marks of all users in project\n        &gt;&gt;&gt; kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email'])\n        ```\n    \"\"\"\n    if status_in is not None and \"status\" not in fields:\n        fields = [*fields, \"status\"]\n\n    where = ProjectUserWhere(\n        project_id=project_id,\n        email=email,\n        _id=id,\n        organization_id=organization_id,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    project_users_gen = ProjectUserQuery(self.graphql_client, self.http_client)(\n        where, fields, options\n    )\n\n    if status_in is not None:\n        status_in_set = set(status_in)\n        project_users_gen = (\n            project_user\n            for project_user in project_users_gen\n            if project_user[\"status\"] in status_in_set\n        )\n\n    if as_generator:\n        return project_users_gen\n    return list(project_users_gen)\n</code></pre>"},{"location":"sdk/project_version/","title":"Project Version module","text":""},{"location":"sdk/project_version/#queries","title":"Queries","text":"<p>Set of ProjectVersion queries.</p> Source code in <code>kili/entrypoints/queries/project_version/__init__.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass QueriesProjectVersion(BaseOperationEntrypointMixin):\n    \"\"\"Set of ProjectVersion queries.\"\"\"\n\n    # pylint: disable=too-many-arguments\n\n    @overload\n    def project_version(\n        self,\n        project_id: str,\n        first: Optional[int] = None,\n        skip: int = 0,\n        fields: ListOrTuple[str] = (\"createdAt\", \"id\", \"content\", \"name\", \"projectId\"),\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def project_version(\n        self,\n        project_id: str,\n        first: Optional[int] = None,\n        skip: int = 0,\n        fields: ListOrTuple[str] = (\"createdAt\", \"id\", \"content\", \"name\", \"projectId\"),\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def project_version(\n        self,\n        project_id: str,\n        first: Optional[int] = None,\n        skip: int = 0,\n        fields: ListOrTuple[str] = (\"createdAt\", \"id\", \"content\", \"name\", \"projectId\"),\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        \"\"\"Get a generator or a list of project versions respecting a set of criteria.\n\n        Args:\n            project_id: Filter on Id of project\n            fields: All the fields to request among the possible fields for the project versions\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/project-version)\n                  for all possible fields.\n            first: Number of project versions to query\n            skip: Number of project versions to skip (they are ordered by their date\n                of creation, first to last).\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the project versions is returned.\n\n        Returns:\n            An iterable of dictionaries containing the project versions information.\n        \"\"\"\n        where = ProjectVersionWhere(\n            project_id=project_id,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        project_versions_gen = ProjectVersionQuery(self.graphql_client, self.http_client)(\n            where, fields, options\n        )\n\n        if as_generator:\n            return project_versions_gen\n        return list(project_versions_gen)\n\n    @typechecked\n    def count_project_versions(self, project_id: str) -&gt; int:\n        \"\"\"Count the number of project versions.\n\n        Args:\n            project_id: Filter on ID of project\n\n        Returns:\n            The number of project versions with the parameters provided\n        \"\"\"\n        where = ProjectVersionWhere(\n            project_id=project_id,\n        )\n        return ProjectVersionQuery(self.graphql_client, self.http_client).count(where)\n</code></pre>"},{"location":"sdk/project_version/#kili.entrypoints.queries.project_version.__init__.QueriesProjectVersion.count_project_versions","title":"<code>count_project_versions(self, project_id)</code>","text":"<p>Count the number of project versions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Filter on ID of project</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of project versions with the parameters provided</p> Source code in <code>kili/entrypoints/queries/project_version/__init__.py</code> <pre><code>def count_project_versions(self, project_id: str) -&gt; int:\n    \"\"\"Count the number of project versions.\n\n    Args:\n        project_id: Filter on ID of project\n\n    Returns:\n        The number of project versions with the parameters provided\n    \"\"\"\n    where = ProjectVersionWhere(\n        project_id=project_id,\n    )\n    return ProjectVersionQuery(self.graphql_client, self.http_client).count(where)\n</code></pre>"},{"location":"sdk/project_version/#kili.entrypoints.queries.project_version.__init__.QueriesProjectVersion.project_version","title":"<code>project_version(self, project_id, first=None, skip=0, fields=('createdAt', 'id', 'content', 'name', 'projectId'), disable_tqdm=None, *, as_generator=False)</code>","text":"<p>Get a generator or a list of project versions respecting a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Filter on Id of project</p> required <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the project versions See the documentation   for all possible fields.</p> <code>('createdAt', 'id', 'content', 'name', 'projectId')</code> <code>first</code> <code>Optional[int]</code> <p>Number of project versions to query</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of project versions to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>None</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the project versions is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>An iterable of dictionaries containing the project versions information.</p> Source code in <code>kili/entrypoints/queries/project_version/__init__.py</code> <pre><code>def project_version(\n    self,\n    project_id: str,\n    first: Optional[int] = None,\n    skip: int = 0,\n    fields: ListOrTuple[str] = (\"createdAt\", \"id\", \"content\", \"name\", \"projectId\"),\n    disable_tqdm: Optional[bool] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    \"\"\"Get a generator or a list of project versions respecting a set of criteria.\n\n    Args:\n        project_id: Filter on Id of project\n        fields: All the fields to request among the possible fields for the project versions\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/project-version)\n              for all possible fields.\n        first: Number of project versions to query\n        skip: Number of project versions to skip (they are ordered by their date\n            of creation, first to last).\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the project versions is returned.\n\n    Returns:\n        An iterable of dictionaries containing the project versions information.\n    \"\"\"\n    where = ProjectVersionWhere(\n        project_id=project_id,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    project_versions_gen = ProjectVersionQuery(self.graphql_client, self.http_client)(\n        where, fields, options\n    )\n\n    if as_generator:\n        return project_versions_gen\n    return list(project_versions_gen)\n</code></pre>"},{"location":"sdk/project_version/#mutations","title":"Mutations","text":"<p>Set of ProjectVersion mutations.</p> Source code in <code>kili/entrypoints/mutations/project_version/__init__.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass MutationsProjectVersion(BaseOperationEntrypointMixin):\n    \"\"\"Set of ProjectVersion mutations.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    @typechecked\n    def update_properties_in_project_version(\n        self, project_version_id: str, content: Optional[str]\n    ) -&gt; Dict:\n        \"\"\"Update properties of a project version.\n\n        Args:\n            project_version_id: Identifier of the project version\n            content: Link to download the project version\n\n        Returns:\n            A dictionary containing the updated project version.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_properties_in_project_version(\n                    project_version_id=project_version_id,\n                    content='test'\n                )\n        \"\"\"\n        variables = {\n            \"content\": content,\n            \"id\": project_version_id,\n        }\n        result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION, variables)\n        return self.format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project_version/#kili.entrypoints.mutations.project_version.__init__.MutationsProjectVersion.update_properties_in_project_version","title":"<code>update_properties_in_project_version(self, project_version_id, content)</code>","text":"<p>Update properties of a project version.</p> <p>Parameters:</p> Name Type Description Default <code>project_version_id</code> <code>str</code> <p>Identifier of the project version</p> required <code>content</code> <code>Optional[str]</code> <p>Link to download the project version</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary containing the updated project version.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_properties_in_project_version(\n        project_version_id=project_version_id,\n        content='test'\n    )\n</code></pre> Source code in <code>kili/entrypoints/mutations/project_version/__init__.py</code> <pre><code>def update_properties_in_project_version(\n    self, project_version_id: str, content: Optional[str]\n) -&gt; Dict:\n    \"\"\"Update properties of a project version.\n\n    Args:\n        project_version_id: Identifier of the project version\n        content: Link to download the project version\n\n    Returns:\n        A dictionary containing the updated project version.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_properties_in_project_version(\n                project_version_id=project_version_id,\n                content='test'\n            )\n    \"\"\"\n    variables = {\n        \"content\": content,\n        \"id\": project_version_id,\n    }\n    result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION, variables)\n    return self.format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project_workflow/","title":"Project Workflow module","text":"<p>Client presentation methods for project workflow.</p> Source code in <code>kili/presentation/client/project_workflow.py</code> <pre><code>class ProjectWorkflowClientMethods(BaseClientMethods):\n    \"\"\"Client presentation methods for project workflow.\"\"\"\n\n    @typechecked\n    def update_project_workflow(\n        self,\n        project_id: str,\n        enforce_step_separation: Optional[bool] = None,\n        create_steps: Optional[List[WorkflowStepCreate]] = None,\n        update_steps: Optional[List[WorkflowStepUpdate]] = None,\n        delete_steps: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update properties of a project workflow.\n\n        Args:\n            project_id: Id of the project.\n            enforce_step_separation: Prevents the same user from being assigned to\n                multiple steps in the workflow for a same asset,\n                ensuring independent review and labeling processes\n            create_steps: List of steps to create in the project workflow.\n            update_steps: List of steps to update in the project workflow.\n            delete_steps: List of step IDs to delete from the project workflow.\n\n        Returns:\n            A dict with the changed properties which indicates if the mutation was successful,\n                else an error message.\n        \"\"\"\n        return ProjectWorkflowUseCases(self.kili_api_gateway).update_project_workflow(\n            project_id=ProjectId(project_id),\n            enforce_step_separation=enforce_step_separation,\n            create_steps=create_steps,\n            update_steps=update_steps,\n            delete_steps=delete_steps,\n        )\n\n    @typechecked\n    def get_steps(\n        self,\n        project_id: str,\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get steps in a project workflow.\n\n        Args:\n            project_id: Id of the project.\n\n        Returns:\n            A dict with the steps of the project workflow.\n        \"\"\"\n        return ProjectWorkflowUseCases(self.kili_api_gateway).get_steps(\n            project_id=ProjectId(project_id),\n        )\n</code></pre>"},{"location":"sdk/project_workflow/#kili.presentation.client.project_workflow.ProjectWorkflowClientMethods.get_steps","title":"<code>get_steps(self, project_id)</code>","text":"<p>Get steps in a project workflow.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Id of the project.</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>A dict with the steps of the project workflow.</p> Source code in <code>kili/presentation/client/project_workflow.py</code> <pre><code>def get_steps(\n    self,\n    project_id: str,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get steps in a project workflow.\n\n    Args:\n        project_id: Id of the project.\n\n    Returns:\n        A dict with the steps of the project workflow.\n    \"\"\"\n    return ProjectWorkflowUseCases(self.kili_api_gateway).get_steps(\n        project_id=ProjectId(project_id),\n    )\n</code></pre>"},{"location":"sdk/project_workflow/#kili.presentation.client.project_workflow.ProjectWorkflowClientMethods.update_project_workflow","title":"<code>update_project_workflow(self, project_id, enforce_step_separation=None, create_steps=None, update_steps=None, delete_steps=None)</code>","text":"<p>Update properties of a project workflow.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Id of the project.</p> required <code>enforce_step_separation</code> <code>Optional[bool]</code> <p>Prevents the same user from being assigned to multiple steps in the workflow for a same asset, ensuring independent review and labeling processes</p> <code>None</code> <code>create_steps</code> <code>Optional[List[kili.domain.project.WorkflowStepCreate]]</code> <p>List of steps to create in the project workflow.</p> <code>None</code> <code>update_steps</code> <code>Optional[List[kili.domain.project.WorkflowStepUpdate]]</code> <p>List of steps to update in the project workflow.</p> <code>None</code> <code>delete_steps</code> <code>Optional[List[str]]</code> <p>List of step IDs to delete from the project workflow.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dict with the changed properties which indicates if the mutation was successful,     else an error message.</p> Source code in <code>kili/presentation/client/project_workflow.py</code> <pre><code>def update_project_workflow(\n    self,\n    project_id: str,\n    enforce_step_separation: Optional[bool] = None,\n    create_steps: Optional[List[WorkflowStepCreate]] = None,\n    update_steps: Optional[List[WorkflowStepUpdate]] = None,\n    delete_steps: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update properties of a project workflow.\n\n    Args:\n        project_id: Id of the project.\n        enforce_step_separation: Prevents the same user from being assigned to\n            multiple steps in the workflow for a same asset,\n            ensuring independent review and labeling processes\n        create_steps: List of steps to create in the project workflow.\n        update_steps: List of steps to update in the project workflow.\n        delete_steps: List of step IDs to delete from the project workflow.\n\n    Returns:\n        A dict with the changed properties which indicates if the mutation was successful,\n            else an error message.\n    \"\"\"\n    return ProjectWorkflowUseCases(self.kili_api_gateway).update_project_workflow(\n        project_id=ProjectId(project_id),\n        enforce_step_separation=enforce_step_separation,\n        create_steps=create_steps,\n        update_steps=update_steps,\n        delete_steps=delete_steps,\n    )\n</code></pre>"},{"location":"sdk/tag/","title":"Tag module","text":"<p>Methods attached to the Kili client, to run actions on tags.</p> Source code in <code>kili/presentation/client/tag.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass TagClientMethods(BaseClientMethods):\n    \"\"\"Methods attached to the Kili client, to run actions on tags.\"\"\"\n\n    @typechecked\n    def tags(\n        self,\n        project_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\"id\", \"organizationId\", \"label\", \"checkedForProjects\"),\n    ) -&gt; List[Dict]:\n        \"\"\"Get tags.\n\n        Args:\n            project_id: Id of the project to which the tags belong.\n                If not provided, tags of the organization are retrieved.\n            fields: Fields of tags to be retrieved.\n                See the [documentation](https://api-docs.kili-technology.com/types/objects/tag)\n                for all possible fields.\n\n        Returns:\n            A list of tags as dictionaries.\n        \"\"\"\n        tag_use_cases = TagUseCases(self.kili_api_gateway)\n        return (\n            tag_use_cases.get_tags_of_organization(fields=fields)\n            if project_id is None\n            else tag_use_cases.get_tags_of_project(project_id=ProjectId(project_id), fields=fields)\n        )\n\n    @typechecked\n    def tag_project(\n        self,\n        project_id: str,\n        tags: Optional[ListOrTuple[str]] = None,\n        tag_ids: Optional[ListOrTuple[str]] = None,\n        disable_tqdm: Optional[bool] = None,\n    ) -&gt; List[Dict[Literal[\"id\"], str]]:\n        \"\"\"Link tags to a project.\n\n        Args:\n            project_id: Id of the project.\n            tags: Sequence of tag labels to associate to the project.\n            tag_ids: Sequence of tag ids to associate to the project.\n                Only used if `tags` is not provided.\n            disable_tqdm: Whether to disable the progress bar.\n\n        Returns:\n            A list of dictionaries with the tag ids.\n        \"\"\"\n        tag_use_cases = TagUseCases(self.kili_api_gateway)\n\n        if tag_ids is None:\n            if tags is None:\n                raise ValueError(\"Either `tags` or `tag_ids` must be provided.\")\n            tag_ids = tag_use_cases.get_tag_ids_from_labels(\n                labels=tags  # pyright: ignore[reportGeneralTypeIssues]\n            )\n\n        return [\n            {\"id\": str(tag_id)}\n            for tag_id in tag_use_cases.tag_project(\n                project_id=ProjectId(project_id),\n                tag_ids=tag_ids,  # pyright: ignore[reportGeneralTypeIssues]\n                disable_tqdm=disable_tqdm,\n            )\n        ]\n\n    @typechecked\n    # pylint: disable=too-many-arguments\n    def untag_project(\n        self,\n        project_id: str,\n        tags: Optional[ListOrTuple[str]] = None,\n        tag_ids: Optional[ListOrTuple[str]] = None,\n        all: Optional[bool] = None,  # pylint: disable=redefined-builtin\n        disable_tqdm: Optional[bool] = None,\n    ) -&gt; List[Dict[Literal[\"id\"], str]]:\n        \"\"\"Remove tags from a project.\n\n        Args:\n            project_id: Id of the project.\n            tags: Sequence of tag labels to remove from the project.\n            tag_ids: Sequence of tag ids to remove from the project.\n            all: Whether to remove all tags from the project.\n            disable_tqdm: Whether to disable the progress bar.\n\n        Returns:\n            A list of dictionaries with the tag ids.\n\n        Raises:\n            ValueError: Either `tags` or `tag_ids` or `all` must be provided.\n        \"\"\"\n        if sum([tags is not None, tag_ids is not None, all is not None]) != 1:\n            raise ValueError(\"Only one of `tags`, `tag_ids` or `all` must be provided.\")\n\n        tag_use_cases = TagUseCases(self.kili_api_gateway)\n\n        if tag_ids is None:\n            if tags is not None:\n                tag_ids = tag_use_cases.get_tag_ids_from_labels(\n                    labels=tags  # pyright: ignore[reportGeneralTypeIssues]\n                )\n            elif all is not None:\n                tag_ids = [\n                    tag[\"id\"]\n                    for tag in tag_use_cases.get_tags_of_project(\n                        project_id=ProjectId(project_id), fields=(\"id\",)\n                    )\n                ]\n            else:\n                raise ValueError(\"Either `tags` or `tag_ids` or `all` must be provided.\")\n\n        return [\n            {\"id\": str(tag_id)}\n            for tag_id in tag_use_cases.untag_project(\n                project_id=ProjectId(project_id),\n                tag_ids=tag_ids,  # pyright: ignore[reportGeneralTypeIssues]\n                disable_tqdm=disable_tqdm,\n            )\n        ]\n\n    def update_tag(self, tag_name: str, new_tag_name: str) -&gt; Dict[Literal[\"id\"], str]:\n        \"\"\"Update a tag.\n\n        This operation is organization-wide.\n        The tag will be updated for all projects of the organization.\n\n        Args:\n            tag_name: Name of the tag to update.\n            new_tag_name: New name of the tag.\n\n        Returns:\n            The id of the updated tag.\n        \"\"\"\n        tag_use_cases = TagUseCases(self.kili_api_gateway)\n        tag_id = tag_use_cases.get_tag_ids_from_labels(labels=(tag_name,))[0]\n        return {\n            \"id\": str(\n                tag_use_cases.update_tag(tag_id=tag_id, new_tag_name=new_tag_name).updated_tag_id\n            )\n        }\n\n    def delete_tag(self, tag_name: Optional[str] = None, tag_id: Optional[str] = None) -&gt; bool:\n        \"\"\"Delete the given tag.\n\n        This operation is organization-wide.\n        The tag will no longer be proposed for projects of the organization.\n        If this tag is checked for one or more projects of the organization, it will be unchecked.\n\n        Args:\n            tag_name: Name of the tag to remove.\n            tag_id: Id of the tag to remove.\n                Use this argument if you have several tags with the same name.\n\n        Returns:\n            Whether the tag was successfully removed.\n        \"\"\"\n        tag_use_cases = TagUseCases(self.kili_api_gateway)\n        if tag_id is None:\n            if tag_name is None:\n                raise ValueError(\"Either `tag_name` or `tag_id` must be provided.\")\n            tag_id = tag_use_cases.get_tag_ids_from_labels(labels=(tag_name,))[0]\n        return tag_use_cases.delete_tag(tag_id=TagId(tag_id))\n\n    def create_tag(self, name: str, color: Optional[str] = None) -&gt; Dict[Literal[\"id\"], str]:\n        \"\"\"Create a tag.\n\n        This operation is organization-wide.\n        The tag will be proposed for projects of the organization.\n\n        Args:\n            name: Name of the tag to create.\n            color: Color of the tag to create. If not providen a default color will be used.\n\n        Returns:\n            The id of the created tag.\n        \"\"\"\n        tag_use_cases = TagUseCases(self.kili_api_gateway)\n        return tag_use_cases.create_tag(name, color)\n</code></pre>"},{"location":"sdk/tag/#kili.presentation.client.tag.TagClientMethods.create_tag","title":"<code>create_tag(self, name, color=None)</code>","text":"<p>Create a tag.</p> <p>This operation is organization-wide. The tag will be proposed for projects of the organization.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tag to create.</p> required <code>color</code> <code>Optional[str]</code> <p>Color of the tag to create. If not providen a default color will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[Literal['id'], str]</code> <p>The id of the created tag.</p> Source code in <code>kili/presentation/client/tag.py</code> <pre><code>def create_tag(self, name: str, color: Optional[str] = None) -&gt; Dict[Literal[\"id\"], str]:\n    \"\"\"Create a tag.\n\n    This operation is organization-wide.\n    The tag will be proposed for projects of the organization.\n\n    Args:\n        name: Name of the tag to create.\n        color: Color of the tag to create. If not providen a default color will be used.\n\n    Returns:\n        The id of the created tag.\n    \"\"\"\n    tag_use_cases = TagUseCases(self.kili_api_gateway)\n    return tag_use_cases.create_tag(name, color)\n</code></pre>"},{"location":"sdk/tag/#kili.presentation.client.tag.TagClientMethods.delete_tag","title":"<code>delete_tag(self, tag_name=None, tag_id=None)</code>","text":"<p>Delete the given tag.</p> <p>This operation is organization-wide. The tag will no longer be proposed for projects of the organization. If this tag is checked for one or more projects of the organization, it will be unchecked.</p> <p>Parameters:</p> Name Type Description Default <code>tag_name</code> <code>Optional[str]</code> <p>Name of the tag to remove.</p> <code>None</code> <code>tag_id</code> <code>Optional[str]</code> <p>Id of the tag to remove. Use this argument if you have several tags with the same name.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the tag was successfully removed.</p> Source code in <code>kili/presentation/client/tag.py</code> <pre><code>def delete_tag(self, tag_name: Optional[str] = None, tag_id: Optional[str] = None) -&gt; bool:\n    \"\"\"Delete the given tag.\n\n    This operation is organization-wide.\n    The tag will no longer be proposed for projects of the organization.\n    If this tag is checked for one or more projects of the organization, it will be unchecked.\n\n    Args:\n        tag_name: Name of the tag to remove.\n        tag_id: Id of the tag to remove.\n            Use this argument if you have several tags with the same name.\n\n    Returns:\n        Whether the tag was successfully removed.\n    \"\"\"\n    tag_use_cases = TagUseCases(self.kili_api_gateway)\n    if tag_id is None:\n        if tag_name is None:\n            raise ValueError(\"Either `tag_name` or `tag_id` must be provided.\")\n        tag_id = tag_use_cases.get_tag_ids_from_labels(labels=(tag_name,))[0]\n    return tag_use_cases.delete_tag(tag_id=TagId(tag_id))\n</code></pre>"},{"location":"sdk/tag/#kili.presentation.client.tag.TagClientMethods.tag_project","title":"<code>tag_project(self, project_id, tags=None, tag_ids=None, disable_tqdm=None)</code>","text":"<p>Link tags to a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Id of the project.</p> required <code>tags</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Sequence of tag labels to associate to the project.</p> <code>None</code> <code>tag_ids</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Sequence of tag ids to associate to the project. Only used if <code>tags</code> is not provided.</p> <code>None</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>Whether to disable the progress bar.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[Literal['id'], str]]</code> <p>A list of dictionaries with the tag ids.</p> Source code in <code>kili/presentation/client/tag.py</code> <pre><code>def tag_project(\n    self,\n    project_id: str,\n    tags: Optional[ListOrTuple[str]] = None,\n    tag_ids: Optional[ListOrTuple[str]] = None,\n    disable_tqdm: Optional[bool] = None,\n) -&gt; List[Dict[Literal[\"id\"], str]]:\n    \"\"\"Link tags to a project.\n\n    Args:\n        project_id: Id of the project.\n        tags: Sequence of tag labels to associate to the project.\n        tag_ids: Sequence of tag ids to associate to the project.\n            Only used if `tags` is not provided.\n        disable_tqdm: Whether to disable the progress bar.\n\n    Returns:\n        A list of dictionaries with the tag ids.\n    \"\"\"\n    tag_use_cases = TagUseCases(self.kili_api_gateway)\n\n    if tag_ids is None:\n        if tags is None:\n            raise ValueError(\"Either `tags` or `tag_ids` must be provided.\")\n        tag_ids = tag_use_cases.get_tag_ids_from_labels(\n            labels=tags  # pyright: ignore[reportGeneralTypeIssues]\n        )\n\n    return [\n        {\"id\": str(tag_id)}\n        for tag_id in tag_use_cases.tag_project(\n            project_id=ProjectId(project_id),\n            tag_ids=tag_ids,  # pyright: ignore[reportGeneralTypeIssues]\n            disable_tqdm=disable_tqdm,\n        )\n    ]\n</code></pre>"},{"location":"sdk/tag/#kili.presentation.client.tag.TagClientMethods.tags","title":"<code>tags(self, project_id=None, fields=('id', 'organizationId', 'label', 'checkedForProjects'))</code>","text":"<p>Get tags.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>Optional[str]</code> <p>Id of the project to which the tags belong. If not provided, tags of the organization are retrieved.</p> <code>None</code> <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Fields of tags to be retrieved. See the documentation for all possible fields.</p> <code>('id', 'organizationId', 'label', 'checkedForProjects')</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>A list of tags as dictionaries.</p> Source code in <code>kili/presentation/client/tag.py</code> <pre><code>def tags(\n    self,\n    project_id: Optional[str] = None,\n    fields: ListOrTuple[str] = (\"id\", \"organizationId\", \"label\", \"checkedForProjects\"),\n) -&gt; List[Dict]:\n    \"\"\"Get tags.\n\n    Args:\n        project_id: Id of the project to which the tags belong.\n            If not provided, tags of the organization are retrieved.\n        fields: Fields of tags to be retrieved.\n            See the [documentation](https://api-docs.kili-technology.com/types/objects/tag)\n            for all possible fields.\n\n    Returns:\n        A list of tags as dictionaries.\n    \"\"\"\n    tag_use_cases = TagUseCases(self.kili_api_gateway)\n    return (\n        tag_use_cases.get_tags_of_organization(fields=fields)\n        if project_id is None\n        else tag_use_cases.get_tags_of_project(project_id=ProjectId(project_id), fields=fields)\n    )\n</code></pre>"},{"location":"sdk/tag/#kili.presentation.client.tag.TagClientMethods.untag_project","title":"<code>untag_project(self, project_id, tags=None, tag_ids=None, all=None, disable_tqdm=None)</code>","text":"<p>Remove tags from a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Id of the project.</p> required <code>tags</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Sequence of tag labels to remove from the project.</p> <code>None</code> <code>tag_ids</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>Sequence of tag ids to remove from the project.</p> <code>None</code> <code>all</code> <code>Optional[bool]</code> <p>Whether to remove all tags from the project.</p> <code>None</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>Whether to disable the progress bar.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[Literal['id'], str]]</code> <p>A list of dictionaries with the tag ids.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>Either <code>tags</code> or <code>tag_ids</code> or <code>all</code> must be provided.</p> Source code in <code>kili/presentation/client/tag.py</code> <pre><code>def untag_project(\n    self,\n    project_id: str,\n    tags: Optional[ListOrTuple[str]] = None,\n    tag_ids: Optional[ListOrTuple[str]] = None,\n    all: Optional[bool] = None,  # pylint: disable=redefined-builtin\n    disable_tqdm: Optional[bool] = None,\n) -&gt; List[Dict[Literal[\"id\"], str]]:\n    \"\"\"Remove tags from a project.\n\n    Args:\n        project_id: Id of the project.\n        tags: Sequence of tag labels to remove from the project.\n        tag_ids: Sequence of tag ids to remove from the project.\n        all: Whether to remove all tags from the project.\n        disable_tqdm: Whether to disable the progress bar.\n\n    Returns:\n        A list of dictionaries with the tag ids.\n\n    Raises:\n        ValueError: Either `tags` or `tag_ids` or `all` must be provided.\n    \"\"\"\n    if sum([tags is not None, tag_ids is not None, all is not None]) != 1:\n        raise ValueError(\"Only one of `tags`, `tag_ids` or `all` must be provided.\")\n\n    tag_use_cases = TagUseCases(self.kili_api_gateway)\n\n    if tag_ids is None:\n        if tags is not None:\n            tag_ids = tag_use_cases.get_tag_ids_from_labels(\n                labels=tags  # pyright: ignore[reportGeneralTypeIssues]\n            )\n        elif all is not None:\n            tag_ids = [\n                tag[\"id\"]\n                for tag in tag_use_cases.get_tags_of_project(\n                    project_id=ProjectId(project_id), fields=(\"id\",)\n                )\n            ]\n        else:\n            raise ValueError(\"Either `tags` or `tag_ids` or `all` must be provided.\")\n\n    return [\n        {\"id\": str(tag_id)}\n        for tag_id in tag_use_cases.untag_project(\n            project_id=ProjectId(project_id),\n            tag_ids=tag_ids,  # pyright: ignore[reportGeneralTypeIssues]\n            disable_tqdm=disable_tqdm,\n        )\n    ]\n</code></pre>"},{"location":"sdk/tag/#kili.presentation.client.tag.TagClientMethods.update_tag","title":"<code>update_tag(self, tag_name, new_tag_name)</code>","text":"<p>Update a tag.</p> <p>This operation is organization-wide. The tag will be updated for all projects of the organization.</p> <p>Parameters:</p> Name Type Description Default <code>tag_name</code> <code>str</code> <p>Name of the tag to update.</p> required <code>new_tag_name</code> <code>str</code> <p>New name of the tag.</p> required <p>Returns:</p> Type Description <code>Dict[Literal['id'], str]</code> <p>The id of the updated tag.</p> Source code in <code>kili/presentation/client/tag.py</code> <pre><code>def update_tag(self, tag_name: str, new_tag_name: str) -&gt; Dict[Literal[\"id\"], str]:\n    \"\"\"Update a tag.\n\n    This operation is organization-wide.\n    The tag will be updated for all projects of the organization.\n\n    Args:\n        tag_name: Name of the tag to update.\n        new_tag_name: New name of the tag.\n\n    Returns:\n        The id of the updated tag.\n    \"\"\"\n    tag_use_cases = TagUseCases(self.kili_api_gateway)\n    tag_id = tag_use_cases.get_tag_ids_from_labels(labels=(tag_name,))[0]\n    return {\n        \"id\": str(\n            tag_use_cases.update_tag(tag_id=tag_id, new_tag_name=new_tag_name).updated_tag_id\n        )\n    }\n</code></pre>"},{"location":"sdk/user/","title":"User module","text":"<p>Methods attached to the Kili client, to run actions on users.</p> Source code in <code>kili/presentation/client/user.py</code> <pre><code>@for_all_methods(log_call, exclude=[\"__init__\"])\nclass UserClientMethods(BaseClientMethods):\n    \"\"\"Methods attached to the Kili client, to run actions on users.\"\"\"\n\n    @overload\n    def users(\n        self,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\"email\", \"id\", \"firstname\", \"lastname\"),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def users(\n        self,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\"email\", \"id\", \"firstname\", \"lastname\"),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def users(\n        self,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: ListOrTuple[str] = (\"email\", \"id\", \"firstname\", \"lastname\"),\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: Optional[bool] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a generator or a list of users given a set of criteria.\n\n        Args:\n            email: Email of the user\n            organization_id: Identifier of the user's organization\n            fields: All the fields to request among the possible fields for the users.\n                See [the documentation](https://api-docs.kili-technology.com/types/objects/user) for all possible fields.\n            first: Maximum number of users to return\n            skip: Number of skipped users (they are ordered by creation date)\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the users is returned.\n\n        Returns:\n            An iterable of users.\n\n        Examples:\n            ```\n            # List all users in my organization\n            &gt;&gt;&gt; organization = kili.organizations()[0]\n            &gt;&gt;&gt; organization_id = organization['id']\n            &gt;&gt;&gt; kili.users(organization_id=organization_id)\n            ```\n        \"\"\"\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n\n        users_gen = UserUseCases(self.kili_api_gateway).list_users(\n            filters=UserFilter(\n                email=email,\n                organization_id=OrganizationId(organization_id) if organization_id else None,\n                activated=None,\n                id=None,\n                id_in=None,\n            ),\n            fields=fields,\n            options=QueryOptions(disable_tqdm, first, skip),\n        )\n\n        if as_generator:\n            return users_gen\n        return list(users_gen)\n\n    @typechecked\n    def count_users(\n        self,\n        organization_id: Optional[str] = None,\n        email: Optional[str] = None,\n    ) -&gt; int:\n        \"\"\"Get user count based on a set of constraints.\n\n        Args:\n            organization_id: Identifier of the user's organization.\n            email: Filter by email.\n\n        Returns:\n            The number of organizations with the parameters provided.\n        \"\"\"\n        return UserUseCases(self.kili_api_gateway).count_users(\n            UserFilter(\n                email=email,\n                organization_id=OrganizationId(organization_id) if organization_id else None,\n                activated=None,\n                id=None,\n                id_in=None,\n            )\n        )\n\n    @typechecked\n    def create_user(\n        self,\n        email: str,\n        password: str,\n        organization_role: OrganizationRole,\n        firstname: Optional[str] = None,\n        lastname: Optional[str] = None,\n    ) -&gt; Dict[Literal[\"id\"], str]:\n        \"\"\"Add a user to your organization.\n\n        Args:\n            email: Email of the new user, used as user's unique identifier.\n            password: On the first sign in, he will use this password and be able to change it.\n            organization_role: One of \"ADMIN\", \"USER\".\n            firstname: First name of the new user.\n            lastname: Last name of the new user.\n\n        Returns:\n            A dictionary with the id of the new user.\n        \"\"\"\n        return UserUseCases(self.kili_api_gateway).create_user(\n            email=email.lower(),\n            password=password,\n            organization_role=organization_role,\n            firstname=firstname,\n            lastname=lastname,\n            fields=(\"id\",),\n        )\n\n    @typechecked\n    def update_password(\n        self, email: str, old_password: str, new_password_1: str, new_password_2: str\n    ) -&gt; Dict[Literal[\"id\"], str]:\n        \"\"\"Allow to modify the password that you use to connect to Kili.\n\n        This resolver only works for on-premise installations without Auth0.\n\n        Args:\n            email: Email of the person whose password has to be updated.\n            old_password: The old password\n            new_password_1: The new password\n            new_password_2: A confirmation field for the new password\n\n        Returns:\n            A dict with the user id.\n        \"\"\"\n        return UserUseCases(self.kili_api_gateway).update_password(\n            old_password=old_password,\n            new_password_1=new_password_1,\n            new_password_2=new_password_2,\n            user_filter=UserFilter(\n                email=email,\n                activated=None,\n                id=None,\n                id_in=None,\n                organization_id=None,\n            ),\n            fields=(\"id\",),\n        )\n\n    @typechecked\n    def update_properties_in_user(\n        self,\n        email: str,\n        firstname: Optional[str] = None,\n        lastname: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        organization_role: Optional[OrganizationRole] = None,\n        activated: Optional[bool] = None,\n    ) -&gt; Dict[Literal[\"id\"], str]:\n        \"\"\"Update the properties of a user.\n\n        Args:\n            email: The email is the identifier of the user.\n            firstname: Change the first name of the user.\n            lastname: Change the last name of the user.\n            organization_id: Change the organization the user is related to.\n            organization_role: Change the role of the user.\n                One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\".\n            activated: In case we want to deactivate a user, but keep it.\n\n        Returns:\n            A dict with the user id.\n        \"\"\"\n        return UserUseCases(self.kili_api_gateway).update_user(\n            user_filter=UserFilter(\n                email=email,\n                activated=None,\n                id=None,\n                id_in=None,\n                organization_id=None,\n            ),\n            firstname=firstname,\n            lastname=lastname,\n            organization_id=OrganizationId(organization_id) if organization_id else None,\n            organization_role=organization_role,\n            activated=activated,\n            fields=(\"id\",),\n        )\n</code></pre>"},{"location":"sdk/user/#kili.presentation.client.user.UserClientMethods.count_users","title":"<code>count_users(self, organization_id=None, email=None)</code>","text":"<p>Get user count based on a set of constraints.</p> <p>Parameters:</p> Name Type Description Default <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization.</p> <code>None</code> <code>email</code> <code>Optional[str]</code> <p>Filter by email.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of organizations with the parameters provided.</p> Source code in <code>kili/presentation/client/user.py</code> <pre><code>def count_users(\n    self,\n    organization_id: Optional[str] = None,\n    email: Optional[str] = None,\n) -&gt; int:\n    \"\"\"Get user count based on a set of constraints.\n\n    Args:\n        organization_id: Identifier of the user's organization.\n        email: Filter by email.\n\n    Returns:\n        The number of organizations with the parameters provided.\n    \"\"\"\n    return UserUseCases(self.kili_api_gateway).count_users(\n        UserFilter(\n            email=email,\n            organization_id=OrganizationId(organization_id) if organization_id else None,\n            activated=None,\n            id=None,\n            id_in=None,\n        )\n    )\n</code></pre>"},{"location":"sdk/user/#kili.presentation.client.user.UserClientMethods.create_user","title":"<code>create_user(self, email, password, organization_role, firstname=None, lastname=None)</code>","text":"<p>Add a user to your organization.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Email of the new user, used as user's unique identifier.</p> required <code>password</code> <code>str</code> <p>On the first sign in, he will use this password and be able to change it.</p> required <code>organization_role</code> <code>Literal['ADMIN', 'USER']</code> <p>One of \"ADMIN\", \"USER\".</p> required <code>firstname</code> <code>Optional[str]</code> <p>First name of the new user.</p> <code>None</code> <code>lastname</code> <code>Optional[str]</code> <p>Last name of the new user.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[Literal['id'], str]</code> <p>A dictionary with the id of the new user.</p> Source code in <code>kili/presentation/client/user.py</code> <pre><code>def create_user(\n    self,\n    email: str,\n    password: str,\n    organization_role: OrganizationRole,\n    firstname: Optional[str] = None,\n    lastname: Optional[str] = None,\n) -&gt; Dict[Literal[\"id\"], str]:\n    \"\"\"Add a user to your organization.\n\n    Args:\n        email: Email of the new user, used as user's unique identifier.\n        password: On the first sign in, he will use this password and be able to change it.\n        organization_role: One of \"ADMIN\", \"USER\".\n        firstname: First name of the new user.\n        lastname: Last name of the new user.\n\n    Returns:\n        A dictionary with the id of the new user.\n    \"\"\"\n    return UserUseCases(self.kili_api_gateway).create_user(\n        email=email.lower(),\n        password=password,\n        organization_role=organization_role,\n        firstname=firstname,\n        lastname=lastname,\n        fields=(\"id\",),\n    )\n</code></pre>"},{"location":"sdk/user/#kili.presentation.client.user.UserClientMethods.update_password","title":"<code>update_password(self, email, old_password, new_password_1, new_password_2)</code>","text":"<p>Allow to modify the password that you use to connect to Kili.</p> <p>This resolver only works for on-premise installations without Auth0.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Email of the person whose password has to be updated.</p> required <code>old_password</code> <code>str</code> <p>The old password</p> required <code>new_password_1</code> <code>str</code> <p>The new password</p> required <code>new_password_2</code> <code>str</code> <p>A confirmation field for the new password</p> required <p>Returns:</p> Type Description <code>Dict[Literal['id'], str]</code> <p>A dict with the user id.</p> Source code in <code>kili/presentation/client/user.py</code> <pre><code>def update_password(\n    self, email: str, old_password: str, new_password_1: str, new_password_2: str\n) -&gt; Dict[Literal[\"id\"], str]:\n    \"\"\"Allow to modify the password that you use to connect to Kili.\n\n    This resolver only works for on-premise installations without Auth0.\n\n    Args:\n        email: Email of the person whose password has to be updated.\n        old_password: The old password\n        new_password_1: The new password\n        new_password_2: A confirmation field for the new password\n\n    Returns:\n        A dict with the user id.\n    \"\"\"\n    return UserUseCases(self.kili_api_gateway).update_password(\n        old_password=old_password,\n        new_password_1=new_password_1,\n        new_password_2=new_password_2,\n        user_filter=UserFilter(\n            email=email,\n            activated=None,\n            id=None,\n            id_in=None,\n            organization_id=None,\n        ),\n        fields=(\"id\",),\n    )\n</code></pre>"},{"location":"sdk/user/#kili.presentation.client.user.UserClientMethods.update_properties_in_user","title":"<code>update_properties_in_user(self, email, firstname=None, lastname=None, organization_id=None, organization_role=None, activated=None)</code>","text":"<p>Update the properties of a user.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>The email is the identifier of the user.</p> required <code>firstname</code> <code>Optional[str]</code> <p>Change the first name of the user.</p> <code>None</code> <code>lastname</code> <code>Optional[str]</code> <p>Change the last name of the user.</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Change the organization the user is related to.</p> <code>None</code> <code>organization_role</code> <code>Optional[Literal['ADMIN', 'USER']]</code> <p>Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\".</p> <code>None</code> <code>activated</code> <code>Optional[bool]</code> <p>In case we want to deactivate a user, but keep it.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[Literal['id'], str]</code> <p>A dict with the user id.</p> Source code in <code>kili/presentation/client/user.py</code> <pre><code>def update_properties_in_user(\n    self,\n    email: str,\n    firstname: Optional[str] = None,\n    lastname: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    organization_role: Optional[OrganizationRole] = None,\n    activated: Optional[bool] = None,\n) -&gt; Dict[Literal[\"id\"], str]:\n    \"\"\"Update the properties of a user.\n\n    Args:\n        email: The email is the identifier of the user.\n        firstname: Change the first name of the user.\n        lastname: Change the last name of the user.\n        organization_id: Change the organization the user is related to.\n        organization_role: Change the role of the user.\n            One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\".\n        activated: In case we want to deactivate a user, but keep it.\n\n    Returns:\n        A dict with the user id.\n    \"\"\"\n    return UserUseCases(self.kili_api_gateway).update_user(\n        user_filter=UserFilter(\n            email=email,\n            activated=None,\n            id=None,\n            id_in=None,\n            organization_id=None,\n        ),\n        firstname=firstname,\n        lastname=lastname,\n        organization_id=OrganizationId(organization_id) if organization_id else None,\n        organization_role=organization_role,\n        activated=activated,\n        fields=(\"id\",),\n    )\n</code></pre>"},{"location":"sdk/user/#kili.presentation.client.user.UserClientMethods.users","title":"<code>users(self, email=None, organization_id=None, fields=('email', 'id', 'firstname', 'lastname'), first=None, skip=0, disable_tqdm=None, *, as_generator=False)</code>","text":"<p>Get a generator or a list of users given a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>Optional[str]</code> <p>Email of the user</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization</p> <code>None</code> <code>fields</code> <code>Union[List[str], Tuple[str, ...]]</code> <p>All the fields to request among the possible fields for the users. See the documentation for all possible fields.</p> <code>('email', 'id', 'firstname', 'lastname')</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of users to return</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of skipped users (they are ordered by creation date)</p> <code>0</code> <code>disable_tqdm</code> <code>Optional[bool]</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>None</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the users is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>An iterable of users.</p> <p>Examples:</p> <pre><code># List all users in my organization\n&gt;&gt;&gt; organization = kili.organizations()[0]\n&gt;&gt;&gt; organization_id = organization['id']\n&gt;&gt;&gt; kili.users(organization_id=organization_id)\n</code></pre> Source code in <code>kili/presentation/client/user.py</code> <pre><code>def users(\n    self,\n    email: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    fields: ListOrTuple[str] = (\"email\", \"id\", \"firstname\", \"lastname\"),\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: Optional[bool] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a generator or a list of users given a set of criteria.\n\n    Args:\n        email: Email of the user\n        organization_id: Identifier of the user's organization\n        fields: All the fields to request among the possible fields for the users.\n            See [the documentation](https://api-docs.kili-technology.com/types/objects/user) for all possible fields.\n        first: Maximum number of users to return\n        skip: Number of skipped users (they are ordered by creation date)\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the users is returned.\n\n    Returns:\n        An iterable of users.\n\n    Examples:\n        ```\n        # List all users in my organization\n        &gt;&gt;&gt; organization = kili.organizations()[0]\n        &gt;&gt;&gt; organization_id = organization['id']\n        &gt;&gt;&gt; kili.users(organization_id=organization_id)\n        ```\n    \"\"\"\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n\n    users_gen = UserUseCases(self.kili_api_gateway).list_users(\n        filters=UserFilter(\n            email=email,\n            organization_id=OrganizationId(organization_id) if organization_id else None,\n            activated=None,\n            id=None,\n            id_in=None,\n        ),\n        fields=fields,\n        options=QueryOptions(disable_tqdm, first, skip),\n    )\n\n    if as_generator:\n        return users_gen\n    return list(users_gen)\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/","title":"Basic Project Setup","text":""},{"location":"sdk/tutorials/basic_project_setup/#how-to-set-up-a-basic-kili-project","title":"How to set up a basic Kili project","text":"<p>In this tutorial, we will learn how to set up a basic Kili project.</p> <p>Here are the steps that we will follow:</p> <ol> <li>Installing and instantiating Kili</li> <li>Creating a basic Kili project</li> <li>Adding assets to project</li> <li>Adding users to project</li> </ol>"},{"location":"sdk/tutorials/basic_project_setup/#installing-and-instantiating-kili","title":"Installing and instantiating Kili","text":"<p>First, let's install and import the required modules.</p> <pre><code>%pip install kili\n</code></pre> <pre><code>from kili.client import Kili\n</code></pre> <p>Now, let's set up variables needed to create an instance of the Kili object.</p> <p>We will need your API key and Kili's API endpoint.</p> <p>If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key.</p> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/#creating-a-basic-kili-project","title":"Creating a basic Kili project","text":"<p>To create a Kili project, you must first set up its interface.</p> <p>We will create a simple image project with just one simple classification job and two categories: <code>OBJECT_A</code> and <code>OBJECT_B</code>.</p> <p>To learn more about Kili project interfaces, refer to https://docs.kili-technology.com/docs/customizing-project-interface.</p> <pre><code>interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 1,\n            \"isChild\": False,\n            \"content\": {\n                \"categories\": {\"OBJECT_A\": {\"name\": \"Object A\"}, \"OBJECT_B\": {\"name\": \"Object B\"}},\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\n\nresult = kili.create_project(\n    title=\"[Kili SDK Notebook]: Basic Project Setup\",\n    description=\"Project Description\",\n    input_type=\"IMAGE\",\n    json_interface=interface,\n)\n</code></pre> <p>For further processing, we will need to find out what our project ID is.</p> <p>We can easily retrieve it from the project creation response message:</p> <pre><code>project_id = result[\"id\"]\nprint(\"Project ID: \", project_id)\n</code></pre> <pre><code>Project ID:  clcun99cn15wx0lq4c15a4dj7\n</code></pre> <p>Now, let's add some assets to be labeled.</p> <p>We will use some free off-the-shelf examples from the Internet.</p>"},{"location":"sdk/tutorials/basic_project_setup/#adding-assets-to-project","title":"Adding assets to project","text":"<pre><code># Image urls\nurl1 = \"https://storage.googleapis.com/label-public-staging/car/car_2.jpg\"\nurl2 = \"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\"\nurl3 = \"https://storage.googleapis.com/label-public-staging/recipes/inference/black_car.jpg\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[url1, url2, url3],\n    external_id_array=[\"image_1\", \"image_2\", \"image_3\"],\n)\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/#adding-users-to-project","title":"Adding users to project","text":"<p>Now we need to add users to our project. Before we do that, we have to add them to our organization. Note that you have to be an org admin to be able to do that.</p> <p>For more info on roles in an organization, refer to https://docs.kili-technology.com/docs/user-roles-in-organization.</p> <pre><code>firstname = \"Jane\"\nlastname = \"Doe\"\nemail = \"no.such.email@no.such.domain.com\"\npassword = \"12345\"\norganization_role = \"USER\"\n\nfrom kili.exceptions import GraphQLError\n\ntry:\n    kili.create_user(email, password, organization_role, firstname, lastname)\nexcept GraphQLError as err:\n    print(str(err))\n</code></pre> <pre><code>error: \"[noOrganizationRights] You cannot use this function because it seems that you do not have access to this organization. Please contact you organization admin. -- This can be due to: User isn't admin from the organization | trace : false\"\n</code></pre> <p>If you already have users in your organization, here's how you can easily access their IDs:</p> <p>1) First, retrieve your organization ID:</p> <pre><code>org_id = kili.organizations()[0][\"id\"]\n</code></pre> <p>2) Then, based on your org ID, retrieve the full list of org users, with their e-mails:</p> <pre><code>all_org_users = kili.users(organization_id=org_id)\n\nall_emails = [i[\"email\"] for i in all_org_users]\n</code></pre> <p>3) We will use the e-mail of the new user to add our new user to our project:</p> <pre><code>user = kili.append_to_roles(project_id, \"no.such.email@no.such.domain.com\", role=\"LABELER\")\nprint(user)\n</code></pre> <pre><code>{'user': {'id': 'clcumy1fx15ci0lre0k21fnu7', 'email': 'no.such.email@no.such.domain.com'}, 'role': 'LABELER'}\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/#summary","title":"Summary","text":"<p>Done. We've successfully set up a Kili project, defined its interface, created a brand new user, and finally added our new user to the new project. Well done!</p>"},{"location":"sdk/tutorials/export_a_kili_project/","title":"Exporting a Project","text":""},{"location":"sdk/tutorials/export_a_kili_project/#how-to-export-data-from-a-kili-project","title":"How to export data from a Kili project","text":""},{"location":"sdk/tutorials/export_a_kili_project/#outline","title":"Outline","text":"<p>This tutorial explains the multiple ways to export a Kili project. It describes:</p> <ul> <li>Methods to export the labels one by one, after filtering</li> <li>The solutions for performing a full-project export</li> </ul> <p>The methods are illustrated with code snippets.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#export-methods","title":"Export methods","text":"<p>With Kili, once you have annotated enough assets, you can export the data programmatically to train a machine learning algorithm with it. There are several ways to do it:</p> <ul> <li>Fetch the assets and/or the labels one by one using <code>.assets</code> or <code>.labels</code>, perform the data transformation yourself and then write the data to one or several output files.</li> <li>Export the whole project as a dataset. To do that, use the <code>.export_labels</code> method that creates an archive containing the labels in your chosen format.</li> </ul>"},{"location":"sdk/tutorials/export_a_kili_project/#preliminary-steps","title":"Preliminary steps","text":"<p>1) Fetch the project ID from the Kili UI (in Settings / Admin):</p> <p></p> <p>2) Ensure that your Kili API key has been set as an environment variable: <pre><code>export KILI_API_KEY=&lt;YOUR_API_KEY&gt;\n</code></pre></p> <p>3) If Kili has not been installed yet, install Kili.</p> <pre><code>%pip install  kili\n</code></pre> <p>4) Import packages and instantiate <code>Kili</code>:</p> <pre><code>from pathlib import Path\n\nfrom kili.client import Kili\n\nkili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-assets-and-labels-one-by-one","title":"Exporting assets and labels one by one","text":"<p>To retrieve all assets of a project one by one, perform the following steps:</p>"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-the-latest-labels-per-asset","title":"Exporting the latest labels per asset","text":"<p>First, fetch the assets:</p> <pre><code>assets = kili.assets(\n    your_project_id,\n    fields=[\"externalId\", \"latestLabel.jsonResponse\"],\n    label_output_format=\"parsed_label\",\n)\n</code></pre> <p>Now if you print an asset, you will see that you can access its <code>latestLabel</code>:</p> <pre><code>print(assets[0])\n</code></pre> <pre><code>{'latestLabel': {'jsonResponse': {'JOB_0': {'annotations': [{'categories': [{'name': 'OBJECT_A'}], 'mid': '20230111125258113-44528', 'type': 'rectangle', 'boundingPoly': [{'normalizedVertices': [{'x': 0.6101435505380516, 'y': 0.7689773770786136}, {'x': 0.6101435505380516, 'y': 0.39426226491370664}, {'x': 0.8962087421313937, 'y': 0.39426226491370664}, {'x': 0.8962087421313937, 'y': 0.7689773770786136}]}], 'polyline': [], 'children': {}}]}}}, 'externalId': 'car_1'}\n</code></pre> <p>You can now get your label, and write the category name into a text file for example:</p> <pre><code>for asset in assets:\n    if asset[\"latestLabel\"]:  # check if asset has annotations\n        class_ = asset[\"latestLabel\"].jobs[\"JOB_0\"].annotations[0].category.name\n        with Path(asset[\"externalId\"] + \".txt\").open(\"w\", encoding=\"utf-8\") as f:\n            f.write(class_)\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-specific-labels-per-asset-through-the-method-filters","title":"Filtering specific labels per asset through the method filters","text":"<p>You can specify label filters directly in the <code>.assets</code> and the <code>.labels</code> methods. The available filters are listed in the arguments list for each one of these methods.</p> <p>When done, you can write the conversion code to get the data in the format that you need.</p> <p>Get only the assets with a consensus mark above 0.5:</p> <pre><code>assets = kili.assets(\n    your_project_id, fields=[\"externalId\", \"id\", \"consensusMark\"], consensus_mark_gt=0.5\n)\nprint(assets)\n# + asset conversion code\n</code></pre> <pre><code>[{'externalId': 'car_1', 'id': 'clcyuykzd0000bgvze2z3wk81', 'consensusMark': 0.6504290982818591}]\n</code></pre> <p>Get all the labels with a honeypot mark above 0.1:</p> <pre><code>labels = kili.labels(\n    your_project_id,\n    fields=[\"labelOf.externalId\", \"honeypotMark\", \"author.email\", \"id\"],\n    honeypot_mark_gte=0.1,\n)\nprint(labels)\n# + label conversion code\n</code></pre> <pre><code>[{'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.doe@kili-technology.com'}, 'honeypotMark': 0.16527040499137607, 'id': 'clcyuynri2fnl0krf0d7pgabo'}, {'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.smith@kili-technology.com'}, 'honeypotMark': 0.20754115450190522, 'id': 'clcyuynri2fnm0krfhx934jee'}]\n</code></pre> <p>Get all the labels added by a specific project member:</p> <pre><code>labels = kili.labels(\n    your_project_id, fields=[\"labelOf.externalId\", \"author.email\", \"id\"], user_id=john_doe_id\n)\nprint(labels)\n# + label conversion code\n</code></pre> <pre><code>[{'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.doe@kili-technology.com'}, 'id': 'clcyuynri2fnl0krf0d7pgabo'}]\n</code></pre> <p>This code will return a list of labels authored by John Doe.</p> <p>You can also use the <code>author_in</code> parameter to filter by name directly.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-specific-labels-per-asset-through-the-label-properties","title":"Filtering specific labels per asset through the label properties","text":"<p>You can also look for specific labels, for example the last \"review\" status label per user, and dump the result into a json file. You can use the field <code>\"labels.isLatestReviewLabelForUser\"</code> to check if the label is the latest per user.</p> <pre><code>import json\n\nassets = kili.assets(\n    your_project_id,\n    fields=[\"externalId\", \"labels.jsonResponse\", \"labels.isLatestReviewLabelForUser\"],\n)\n\nfor asset in assets:\n    if asset[\"labels\"]:  # check if asset has annotations\n        for label in asset[\"labels\"]:\n            if label[\"isLatestReviewLabelForUser\"] and \"JOB_0\" in label[\"jsonResponse\"]:\n                annotation = label[\"jsonResponse\"][\"JOB_0\"]\n                with Path(asset[\"externalId\"] + \".json\").open(\"w\", encoding=\"utf-8\") as f:\n                    f.write(json.dumps(annotation))\n                break  # once we find a latest label done by a reviewer, we move on to the next asset.\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-the-latest-label-per-annotator","title":"Filtering the latest label per annotator","text":"<p>When working on a project with consensus enabled, it can be useful to export the latest label made by each annotator:</p> <pre><code>import tempfile\nfrom collections import defaultdict\n\nassets = kili.assets(\n    your_project_id,\n    fields=[\n        \"externalId\",\n        \"labels.author.email\",\n        \"labels.createdAt\",\n        \"labels.labelType\",\n        \"labels.jsonResponse\",\n    ],\n)\n\nfor asset in assets:\n    if asset[\"labels\"]:\n        latest_label_by_user = defaultdict(list)\n        for label in asset[\"labels\"]:\n            if label[\"labelType\"] == \"DEFAULT\":\n                latest_label_by_user[label[\"author\"][\"email\"]].append(label)\n        latest_label_per_user = {\n            email: max(labels, key=lambda x: x[\"createdAt\"])\n            for email, labels in latest_label_by_user.items()\n        }\n        with (Path(tempfile.gettempdir()) / (asset[\"externalId\"] + \".json\")).open(\n            \"w\", encoding=\"utf-8\"\n        ) as f:\n            f.write(json.dumps(latest_label_per_user))\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-a-whole-project","title":"Exporting a whole project","text":"<p>You can export your project data from the Kili UI (see documentation), but Kili SDK also enables you to export your labels and assets into several export formats.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#available-formats","title":"Available formats","text":"Format UI Python Client Command Line Interface Kili (raw) \u2705 \u2705 \u2705 YOLO V4 \u2705 \u2705 \u2705 YOLO V5 \u2705 \u2705 \u2705 YOLO V7 \u274c \u2705 \u2705 YOLO V8 \u274c \u2705 \u2705 Pascal VOC \u2705 \u2705 \u2705 COCO \u274c \u2705 \u2705 GeoJSON \u274c \u2705 \u2705"},{"location":"sdk/tutorials/export_a_kili_project/#the-export_labels-method","title":"The <code>.export_labels</code> method","text":"<p>The <code>.export_labels</code> method enables the export of a full project. It does the following preprocessing:</p> <ul> <li>Only fetches the labels of types <code>\"DEFAULT\"</code> and <code>\"REVIEW\"</code> (see the label types explanations).</li> <li>If specified, selects a subset of asset ids.</li> <li>Exports labels to one of the standard formats (only available for a restricted set of ML tasks).</li> <li>Using various method arguments, you can decide:<ul> <li>Whether or not to include the assets in the export</li> <li>Whether to export just the latest label or all the labels</li> <li>Whether to create one folder for all the jobs or one folder per job</li> <li>Whether or not to export the label-related data into one single file</li> </ul> </li> </ul> <p>Note that some formats are by default single-file, while others use many files:</p> Format Single file Multiple files Kili \u2705 \u2705 Yolo \u274c \u2705 Pascal VOC \u274c \u2705 COCO \u2705 \u274c <p>For all the formats, in the output archive, a <code>README.kili.txt</code> file is also created. Here is an example of its contents: <pre><code>Exported Labels from KILI\n=========================\n\n- Project name: Awesome annotation project\n- Project identifier: abcdefghijklmnop\n- Project description: This project contains labels, most of which are awesome.\n- Export date: 20221125-093324\n- Exported format: kili\n- Exported labels: latest\n</code></pre></p>"},{"location":"sdk/tutorials/export_a_kili_project/#kili-format-one-file-per-asset","title":"Kili format, one file per asset","text":"<p>The following code snippet exports the whole asset payload and the associated labels, with one json file per asset, into the <code>/tmp/export.zip</code> folder.</p> <pre><code>kili.export_labels(\n    project_id=your_project_id,\n    filename=\"/tmp/export.zip\",\n    fmt=\"kili\",\n)\n</code></pre> <pre><code>Fetching assets...\n/tmp/export.zip\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#kili-format-one-file-for-the-whole-project","title":"Kili format, one file for the whole project","text":"<p>This code snippet exports the whole asset payload and the associated labels as one file for the whole project, into the <code>/tmp/export.zip</code> folder.</p> <pre><code>kili.export_labels(\n    project_id=your_project_id,\n    filename=\"/tmp/export.zip\",\n    fmt=\"kili\",\n    single_file=True,\n)\n</code></pre> <pre><code>Fetching assets...\n/tmp/export.zip\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#yolo-formats","title":"YOLO formats","text":"<p>When you have at least one object etection job, you can also export to one of the following YOLO formats: <code>\"yolo_v4\"</code>, <code>\"yolo_v5\"</code>, <code>\"yolo_v7\"</code> or <code>\"yolo_v8\"</code>. The difference between each format is the structure of the metadata YAML file, which specifies the object classes. In all the cases, one file per asset is produced, containing the last created <code>DEFAULT</code> or <code>REVIEW</code> label.</p> <p>For bouding boxes, each YOLO label has the following shape:</p> <pre><code>2        0.25 0.67 0.26 0.34\n^        ^    ^    ^    ^\nclass    x    y    w    h\n</code></pre> <p>where:</p> <ul> <li><code>class</code> is the class index in the classes list contained in the YOLO metadata file.</li> <li><code>x</code> is the x-coordinate relative to the image width (between 0.0 and 1.0) of the center of the bounding box.</li> <li><code>y</code> is the y-coordinate relative to the image height (between 0.0 and 1.0) of the center of the bounding box.</li> <li><code>w</code> is the width relative to the image width (between 0.0 and 1.0) of the bounding box.</li> <li><code>h</code> is the height relative to the image height (between 0.0 and 1.0) of the bounding box.</li> </ul> <p>For polygons or segmentations, each YOLO label has the following shape:</p> <pre><code>2        0.25 0.67 0.26 0.34 0.4 0.5 0.6 0.7  ...\n^        ^    ^    ^    ^    ^   ^   ^   ^\nclass    x1   y1   x2   y2   x3  y3  x4  y4   ...\n</code></pre> <p>where:</p> <ul> <li><code>class</code> is the class index in the classes list contained in the YOLO metadata file.</li> <li><code>xi</code> is the x-coordinate relative to the image width (between 0.0 and 1.0) of the i-th point of the polygon.</li> <li><code>yi</code> is the y-coordinate relative to the image height (between 0.0 and 1.0) of the i-th point of the polygon.</li> </ul> <p>Here is an example of a YOLO annotation over an image:</p> <p></p> <p>Here is how to export to YOLO (in this example, YOLOv5):</p> <pre><code>kili.export_labels(\n    project_id=your_project_id,\n    filename=\"/tmp/export.zip\",\n    fmt=\"yolo_v5\",\n)\n</code></pre> <pre><code>Fetching assets...\n/tmp/export.zip\n</code></pre> <p>Note that a standard YOLO file format must also include:</p> <ul> <li>The path root to the assets</li> <li>The <code>train</code>, <code>val</code> and <code>test</code> subfolders</li> </ul> <p>Placing specific data in specific folders is the decision of an ML engineer or a Data scientist, so we are not providing a code snippet here.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#coco-format","title":"COCO format","text":"<p>To export your data into the COCO format, run the following code:</p> <pre><code>kili.export_labels(\n    project_id=your_project_id,\n    filename=\"/tmp/export.zip\",\n    fmt=\"coco\",\n)\n</code></pre> <pre><code>Fetching assets...\nConvert to coco format: 1it [00:00, 54.94it/s]\n/tmp/export.zip\n</code></pre> <p>This will create an archive containing both:</p> <ul> <li>The COCO annotation file</li> <li>The <code>data/</code> folder with all the assets</li> </ul>"},{"location":"sdk/tutorials/export_a_kili_project/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(your_project_id)\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#summary","title":"Summary","text":"<p>In this tutorial, we have seen several ways to export labels from a Kili project:</p> <ul> <li>Using <code>.assets</code> and <code>.labels</code> and their filtering arguments, a subset of assets or labels can be selected and then exported.</li> <li>Using <code>.export_labels</code>, the whole project can be exported into a standard output format.</li> </ul>"},{"location":"sdk/tutorials/finetuning_dinov2/","title":"DINOv2 Classification Pre-annotations","text":""},{"location":"sdk/tutorials/finetuning_dinov2/#how-to-fine-tune-dinov2-for-image-classification","title":"How to fine-tune DINOv2 for image classification","text":"<p>This tutorial shows how to use the DINOv2 self-supervised vision transformer model to generate pre-annotations on a defect detection use case.</p> <p>Modern foundation models (FMs) are capable of performing many diverse tasks; large language models can quickly and accurately process natural language while models focused on image processing are very good at computer vision tasks, such as object detection or classification.</p> <p>By retraining an FM on a very limited set of examples, it is possible to even further improve its performance on a specific task, such as image classification. This process is called fine-tuning.</p> <p>Throughout this tutorial, we will:</p> <ul> <li>Configure a project on Kili.</li> <li>Fine-tune the DINOv2 model using a tiny set of labeled images on Kili.</li> <li>Generate pre-annotations on a set of images to label.</li> <li>Evaluate the quality of the generated pre-annotations in the Kili interface.</li> </ul>"},{"location":"sdk/tutorials/finetuning_dinov2/#setup","title":"Setup","text":"<p>Let's first install the Kili package and all other packages required for our experiment:</p> <pre><code>%pip install kili matplotlib numpy Pillow scikit-learn torch torchvision kaggle tqdm\n</code></pre> <pre><code>import os\nimport random\nimport zipfile\nfrom copy import deepcopy\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom PIL import Image\nfrom sklearn.metrics import classification_report\nfrom torch import nn, optim\nfrom torchvision import datasets, transforms\nfrom tqdm.notebook import tqdm\n\nfrom kili.client import Kili\n</code></pre> <p>To interact with Kili using the Python SDK, it is necessary to have a Kili account and an API key.</p> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/finetuning_dinov2/#kili-project-configuration","title":"Kili project configuration","text":"<p>In this section, we will create a project from scratch with existing labels on Kili.</p> <p>If you want to use your own project, you can simply skip this section and replace the <code>project_id</code> variable by your own project ID.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#download-assets-create-project","title":"Download assets &amp; create project","text":"<p>For this tutorial, we will use a real-life image dataset of products created through the process of casting from Kaggle. You can download it from here.</p> <p>We will use the Kaggle API to download the dataset.</p> <pre><code>path_to_kaggle_api_key = Path.home() / \".kaggle\" / \"kaggle.json\"\n\nif not path_to_kaggle_api_key.is_file():\n    json_key_str = getpass.getpass(\"Enter your kaggle json api key: \")\n    path_to_kaggle_api_key.parent.mkdir(parents=True, exist_ok=True)\n    path_to_kaggle_api_key.write_text(json_key_str)\n</code></pre> <pre><code>!kaggle datasets download -d ravirajsinh45/real-life-industrial-dataset-of-casting-product\n</code></pre> <p>Once the .zip file is downloaded, we can unzip it and discover the structure of the dataset:</p> <pre><code>with zipfile.ZipFile(\"real-life-industrial-dataset-of-casting-product.zip\", \"r\") as zip_ref:\n    zip_ref.extractall(\".\")\n</code></pre> <p>We can see that the dataset has two classes of images: <code>ok_front</code> and <code>def_front</code>. <code>ok_front</code> images are images of products without defects, and <code>def_front</code> images are images of products with defects.</p> <pre><code>data_dir = Path() / \"casting_512x512\" / \"casting_512x512\"\nprint(os.listdir(data_dir))\nprint(len(os.listdir(data_dir / \"def_front\")))\nprint(len(os.listdir(data_dir / \"ok_front\")))\n</code></pre> <pre><code>['ok_front', 'def_front']\n781\n519\n</code></pre> <p>The <code>ok_front</code> class has 519 images, and the <code>def_front</code> class has 781 images.</p> <p>Let's take a look at the images:</p> <pre><code>plt.imshow(Image.open(next((data_dir / \"def_front\").iterdir())))\nplt.show()\n</code></pre> <p></p> <pre><code>plt.imshow(Image.open(next((data_dir / \"ok_front\").iterdir())))\nplt.show()\n</code></pre> <p></p> <p>We can balance the dataset and keep only <code>N</code> images in total:</p> <pre><code>N = 400\n\nfor class_name in [\"def_front\", \"ok_front\"]:\n    filepaths_to_delete = sorted(os.listdir(data_dir / class_name))[N // 2 :]\n    for filepath in filepaths_to_delete:\n        (data_dir / class_name / filepath).unlink(missing_ok=True)\n\nassert len(os.listdir(data_dir / \"def_front\")) == N // 2\nassert len(os.listdir(data_dir / \"ok_front\")) == N // 2\n</code></pre> <p>Next, we create the Kili project with its ontology showing the two categories:</p> <pre><code>project_title = \"[Kili SDK Notebook]: Demo - DINOv2 Classification\"\n\njson_interface = {\n    \"jobs\": {\n        \"CLASSIFICATION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"YES\": {\"children\": [], \"name\": \"Yes\", \"id\": \"category1\"},\n                    \"NO\": {\"children\": [], \"name\": \"No\", \"id\": \"category2\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Defect(s) in image?\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 1,\n            \"isChild\": False,\n            \"isNew\": False,\n        }\n    }\n}\n\nproject_id = kili.create_project(\n    title=project_title, json_interface=json_interface, input_type=\"IMAGE\"\n)[\"id\"]\n</code></pre> <p>We can then prepare the assets to be uploaded to Kili:</p> <pre><code># sort the assets by alternating between classes so that both\n# classes show up in the first page of the labeling interface\ncontent_array = []\niterator = zip((data_dir / \"def_front\").iterdir(), (data_dir / \"ok_front\").iterdir())\nfor filepath_def, filepath_ok in iterator:\n    content_array.append(filepath_def)\n    content_array.append(filepath_ok)\nprint(content_array[0])\n</code></pre> <pre><code>casting_512x512/casting_512x512/def_front/cast_def_0_1145.jpeg\n</code></pre> <p>The external ID of each asset is the name of the image displayed in the Kili interface:</p> <pre><code>external_id_array = []\nfor filepath in content_array:\n    class_ = \"def\" if \"_def_\" in filepath.name else \"ok\"\n    external_id = filepath.name.replace(\"cast_ok_0_\", \"\").replace(\"cast_def_0_\", \"\")\n    external_id = external_id.replace(\".jpeg\", \"_\" + class_[:1])\n    external_id_array.append(external_id)\nassert len(set(external_id_array)) == N\nprint(external_id_array[0])\n</code></pre> <pre><code>1145_d\n</code></pre> <p>The class of an image is available in the file name. We can extract it and add it to the Kili asset metadata:</p> <pre><code>output_class_array = [\"YES\" if \"def\" in filepath.name else \"NO\" for filepath in content_array]\nprint(output_class_array[0])\n</code></pre> <pre><code>YES\n</code></pre> <p>We input the ground truth in the metadata, this will be useful later on:</p> <pre><code>json_metadata_array = [{\"Ground Truth\": output_class} for output_class in output_class_array]\nprint(json_metadata_array[0])\n</code></pre> <pre><code>{'Ground Truth': 'YES'}\n</code></pre> <p>We now upload the assets to our Kili project:</p> <pre><code>kili.append_many_to_dataset(\n    project_id=project_id,\n    external_id_array=external_id_array,\n    content_array=[str(x) for x in content_array],\n    json_metadata_array=json_metadata_array,\n)\n</code></pre>"},{"location":"sdk/tutorials/finetuning_dinov2/#import-annotations","title":"Import annotations","text":"<p>In this tutorial, we will need to use ground truth annotations to fine-tune the DINOv2 model.</p> <p>We thus simulate manual labeling on some images.</p> <pre><code>nb_manually_labeled_assets = 200\n</code></pre> <pre><code>json_response_array = [\n    {\"CLASSIFICATION_JOB\": {\"categories\": [{\"confidence\": 100, \"name\": output_class}]}}\n    for output_class in output_class_array\n]\n</code></pre> <pre><code>kili.append_labels(\n    project_id=project_id,\n    asset_external_id_array=external_id_array[:nb_manually_labeled_assets],\n    json_response_array=json_response_array[:nb_manually_labeled_assets],\n    label_type=\"DEFAULT\",\n    seconds_to_label_array=[\n        random.randint(60, 300)\n        for _ in range(nb_manually_labeled_assets)  # simulate labeling time\n    ],\n)\n\n# Replace the project_id below with your own project_id!\nprint(f\"\\nAccess your project at: https://cloud.kili-technology.com/label/projects/{project_id}\")\n</code></pre> <pre><code>Access your project at: https://cloud.kili-technology.com/label/projects/cliistnwa003c0j78ay1y3qlm\n</code></pre> <p></p> <p>Now we have a configured project on our Kili organization, with some assets already manually labeled.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#model-training","title":"Model training","text":"<p>In this section, we will fine-tune the DINOv2 model using labeled images from a Kili project.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#dataset-preparation","title":"Dataset preparation","text":"<p>Here, we will use the project we created earlier, but feel free to use your own project:</p> <pre><code>project_id = project_id  # put your own Kili project id here\n</code></pre> <pre><code>nb_labeled_assets = 200  # put the number of labeled assets you want to retrieve here\n</code></pre> <pre><code>data_dir = \"./data\"\n\nlabeled_assets = kili.assets(\n    project_id=project_id,\n    fields=[\n        \"id\",\n        \"content\",\n        \"labels.jsonResponse\",\n        \"externalId\",\n        \"latestLabel.jsonResponse\",\n        \"jsonMetadata\",\n    ],\n    status_in=[\"LABELED\"],  # we retrieve assets already labeled\n    download_media=True,\n    local_media_dir=data_dir,\n    first=nb_labeled_assets,\n    label_output_format=\"parsed_label\",\n)\n\nprint(f\"\\nRetrieved {len(labeled_assets)} labeled assets.\")\n</code></pre> <pre><code>Retrieved 200 labeled assets.\n</code></pre> <p>We split the train data into the two classes:</p> <pre><code>Path(\"./data/train/YES\").mkdir(parents=True, exist_ok=True)\nPath(\"./data/train/NO\").mkdir(parents=True, exist_ok=True)\n\nfor asset in labeled_assets:\n    class_name = asset[\"latestLabel\"].jobs[\"CLASSIFICATION_JOB\"].category.name\n    filepath = Path(asset[\"content\"])\n    filepath.rename(filepath.parent / \"train\" / class_name / filepath.name)\n\nprint(os.listdir(data_dir))\nprint(len(os.listdir(data_dir + \"/train/YES\")))\nprint(len(os.listdir(data_dir + \"/train/NO\")))\n</code></pre> <pre><code>['train']\n100\n100\n</code></pre> <p>Below, we prepare the pipeline that loads the images and applies some data augmentation. Data augmentation is a technique that consists of applying random transformations to the images to artificially increase the size of the dataset. This technique is very useful when the dataset is small, since it allows the model to see more images during training.</p> <p>For example, we can apply random horizontal and vertical flips and random rotations to the images:</p> <pre><code>data_transforms = {\n    \"train\": transforms.Compose(\n        [\n            transforms.Resize(224),\n            transforms.RandomRotation(360),\n            transforms.RandomHorizontalFlip(),\n            transforms.RandomVerticalFlip(),\n            transforms.ToTensor(),\n            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]),\n        ]\n    ),\n}\n\nimage_datasets = {\n    \"train\": datasets.ImageFolder(os.path.join(data_dir, \"train\"), data_transforms[\"train\"])\n}\n\ndataloaders = {\n    \"train\": torch.utils.data.DataLoader(image_datasets[\"train\"], batch_size=8, shuffle=True)\n}\n\nclass_names = image_datasets[\"train\"].classes\n\nprint(class_names)\n</code></pre> <pre><code>['NO', 'YES']\n</code></pre>"},{"location":"sdk/tutorials/finetuning_dinov2/#model-download-fine-tuning","title":"Model download &amp; fine-tuning","text":"<p>We load the DINOv2 model from the HuggingFace library:</p> <pre><code>dinov2_vits14 = torch.hub.load(\"facebookresearch/dinov2\", \"dinov2_vits14\")\n</code></pre> <p>Let's see what is the output of this model:</p> <pre><code>input_img_tensor, class_id = next(iter(image_datasets[\"train\"]))\n\nwith torch.inference_mode():\n    output = dinov2_vits14(torch.unsqueeze(input_img_tensor, dim=0))\n\nprint(output.size())\n</code></pre> <pre><code>torch.Size([1, 384])\n</code></pre> <p>As you can see, the output is a vector of dimension 384. This is the embedding of the image.</p> <p>The embedding is a vector that represents the image in the DINOv2 model latent space. The embedding contains a compressed representation of the image, which is useful for many tasks, such as image classification.</p> <p>The embedding dimension is:</p> <ul> <li>384 for ViT-S (we are using this model in this tutorial).</li> <li>768 for ViT-B.</li> <li>1024 for ViT-L.</li> <li>1536 for ViT-g.</li> </ul> <p>To predict a class, we need to add a classification head to the DINOv2 model.</p> <p>This small neural network will take the embeddings as input, and will output a score for the binary classification.</p> <pre><code>class DinoVisionTransformerClassifier(nn.Module):\n    def __init__(self):\n        super(DinoVisionTransformerClassifier, self).__init__()\n        self.transformer = deepcopy(dinov2_vits14)\n        self.classifier = nn.Sequential(nn.Linear(384, 256), nn.ReLU(), nn.Linear(256, 1))\n\n    def forward(self, x):\n        x = self.transformer(x)\n        x = self.transformer.norm(x)\n        x = self.classifier(x)\n        return x\n\n\nmodel = DinoVisionTransformerClassifier()\n</code></pre> <p>Below, we select the device to use for training. It is recommended to use a GPU for this task:</p> <pre><code>device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\nprint(\"Device: \", device)\nmodel = model.to(device)\nmodel = model.train()\n</code></pre> <pre><code>Device:  cuda:0\n</code></pre> <p>We use a binary cross-entropy loss to train the model, with the Adam optimizer.</p> <p>The binary cross-entropy loss is a standard loss function for binary classification tasks. The loss is like the error between the predicted class and the ground truth class. The higher the loss, the worse the model is.</p> <p>To decrease the loss, we will use the Adam optimizer, which is a widely used optimizer for neural networks. It is a stochastic gradient descent method that computes adaptive learning rates for each parameter of the model.</p> <pre><code>criterion = nn.BCEWithLogitsLoss()\noptimizer = optim.Adam(model.parameters(), lr=1e-6)\n</code></pre> <p>We also define the number of epochs to train the model. An epoch is a full pass through the training data.</p> <pre><code>num_epochs = 15\n</code></pre> <pre><code>epoch_losses = []\nfor epoch in range(num_epochs):\n    print(\"Epoch: \", epoch)\n\n    batch_losses = []\n    for data in dataloaders[\"train\"]:\n        # get the input batch and the labels\n        batch_of_images, labels = data\n\n        # zero the parameter gradients\n        optimizer.zero_grad()\n\n        # model prediction\n        output = model(batch_of_images.to(device)).squeeze(dim=1)\n\n        # compute loss and do gradient descent\n        loss = criterion(output, labels.float().to(device))\n        loss.backward()\n        optimizer.step()\n\n        batch_losses.append(loss.item())\n\n    epoch_losses.append(np.mean(batch_losses))\n    print(f\"Mean epoch loss: {epoch_losses[-1]}\")\n\nprint(\"Finished training!\")\n</code></pre> <pre><code>Epoch:  0\nMean epoch loss: 0.7347773921489715\nEpoch:  1\nMean epoch loss: 0.5930992090702056\nEpoch:  2\nMean epoch loss: 0.5117795491218566\nEpoch:  3\nMean epoch loss: 0.4436239504814148\nEpoch:  4\nMean epoch loss: 0.34697133481502535\nEpoch:  5\nMean epoch loss: 0.2919022357463837\nEpoch:  6\nMean epoch loss: 0.18035753384232522\nEpoch:  7\nMean epoch loss: 0.117118861079216\nEpoch:  8\nMean epoch loss: 0.11755006849765777\nEpoch:  9\nMean epoch loss: 0.08585118860006333\nEpoch:  10\nMean epoch loss: 0.07716833263635635\nEpoch:  11\nMean epoch loss: 0.05035351105034351\nEpoch:  12\nMean epoch loss: 0.06317368872463704\nEpoch:  13\nMean epoch loss: 0.04912809677422047\nEpoch:  14\nMean epoch loss: 0.05099196014925837\nFinished training!\n</code></pre> <p>As you can see on the plot below, the loss decreases as the number of epochs increases. This means that the model has successfully learned to classify images.</p> <p>When the loss stops decreasing, it means that the model has converged and that we can stop the training. In this case, we could have stopped the training after 11 epochs.</p> <pre><code>plt.plot(epoch_losses)\nplt.title(\"Mean epoch loss\")\nplt.xlabel(\"Epoch Number\")\nplt.ylabel(\"Loss\")\nplt.show()\n</code></pre> <p></p> <p>Perfect! The model is now fine-tuned on the labeled images from Kili.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#predict-with-the-model-on-unlabeled-assets","title":"Predict with the model on unlabeled assets","text":"<p>In this section, we will use the fine-tuned model to generate pre-annotations on a set of images to label.</p> <pre><code>max_nb_assets_to_label = 200\n</code></pre> <pre><code>non_labeled_assets = kili.assets(\n    project_id=project_id,\n    fields=[\"id\", \"content\", \"externalId\", \"jsonMetadata\"],\n    status_in=[\"TODO\"],  # we choose assets to label\n    first=max_nb_assets_to_label,\n    download_media=True,\n)\nprint(\"\\nNumber of fetched assets to label: \", len(non_labeled_assets))\n</code></pre> <pre><code>Number of fetched assets to label:  200\n</code></pre> <p>The <code>kili.assets</code> method returns a list of assets represented as Python dictionaries:</p> <pre><code>non_labeled_assets[0]\n</code></pre> <pre><code>{'id': 'cliisunn100xcmkp9tsuj17ut',\n 'content': '/root/.cache/kili/projects/cliistnwa003c0j78ay1y3qlm/assets/3016_d.jpg',\n 'externalId': '3016_d',\n 'jsonMetadata': {'Ground Truth': 'YES'}}\n</code></pre> <p>We can now use the model to generate pre-annotations on the assets:</p> <pre><code>data_transforms = transforms.Compose(\n    [\n        transforms.Resize(256),\n        transforms.CenterCrop(224),\n        transforms.ToTensor(),\n        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]),\n    ]\n)\n</code></pre> <p>We switch the model to evaluation mode since we don't want to update the weights of the model anymore:</p> <pre><code>model = model.eval()\n</code></pre> <pre><code>external_id_array_non_labeled_assets = []\ny_true_non_labeled_assets = []\nembeddings_non_labeled_assets = []\ny_pred_dinov2_non_labeled_assets = []\njson_response_array_non_labeled_assets = []\n\nfor asset in tqdm(non_labeled_assets):\n    external_id_array_non_labeled_assets.append(asset[\"externalId\"])\n    y_true_non_labeled_assets.append(asset[\"jsonMetadata\"][\"Ground Truth\"])\n\n    img = Image.open(asset[\"content\"])\n\n    img_tensor = data_transforms(img)\n    img_tensor = img_tensor.unsqueeze(0)\n    input_tensor = img_tensor.to(device)\n\n    # Perform inference\n    with torch.no_grad():\n        embeddings = model.transformer(input_tensor)\n        embeddings_non_labeled_assets.append(embeddings[0].cpu().numpy())\n        x = model.transformer.norm(embeddings)\n        output_tensor = model.classifier(x)\n\n    score = output_tensor[0][0].item()\n\n    score = 1 / (1 + np.exp(-score))  # sigmoid\n\n    output_class = \"YES\" if score &gt; 0.5 else \"NO\"\n\n    y_pred_dinov2_non_labeled_assets.append(output_class)\n\n    json_response_array_non_labeled_assets.append(\n        {\n            \"CLASSIFICATION_JOB\": {\n                \"categories\": [{\"confidence\": int(round(score * 100)), \"name\": output_class}]\n            }\n        }\n    )\n</code></pre> <p>We now push the predictions to Kili as pre-annotations (prediction) and inference labels.</p> <p>The pre-annotations will be helpful for the labelers to label the assets, since those pre-annotations will be displayed in the Kili interface. It will help them to label the assets faster.</p> <p>The inference labels will be used to evaluate the quality of the model against labelers.</p> <p>You can learn more about the different kinds of labels in the Kili documentation.</p> <pre><code>kili.append_labels(\n    project_id=project_id,\n    json_response_array=json_response_array_non_labeled_assets,\n    model_name=\"DINOv2\",\n    label_type=\"INFERENCE\",\n    asset_external_id_array=external_id_array_non_labeled_assets,\n)\n\nkili.append_labels(\n    project_id=project_id,\n    json_response_array=json_response_array_non_labeled_assets,\n    model_name=\"DINOv2\",\n    label_type=\"PREDICTION\",\n    asset_external_id_array=external_id_array_non_labeled_assets,\n)\n</code></pre>"},{"location":"sdk/tutorials/finetuning_dinov2/#pre-annotations-quality-analysis","title":"Pre-annotations quality analysis","text":""},{"location":"sdk/tutorials/finetuning_dinov2/#finetuning-with-dinov2","title":"Finetuning with DINOv2","text":"<pre><code>print(classification_report(y_true_non_labeled_assets, y_pred_dinov2_non_labeled_assets))\n</code></pre> <pre><code>              precision    recall  f1-score   support\n\n          NO       0.97      0.94      0.95       100\n         YES       0.94      0.97      0.96       100\n\n    accuracy                           0.95       200\n   macro avg       0.96      0.95      0.95       200\nweighted avg       0.96      0.95      0.95       200\n</code></pre> <p>We get an accuracy of ~95% for the fine-tuned DINOv2 model on a binary classification task.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#k-nearest-neighbors","title":"K-nearest neighbors","text":"<p>We can also use the embeddings directly to find the nearest neighbors of an image, and use the class of the nearest neighbors as the predicted class.</p> <p>This method has the advantage of not requiring to fine-tune the model.</p> <p>It however takes some time to pre-compute the embeddings of all the images in the dataset.</p> <pre><code>from sklearn.neighbors import KNeighborsClassifier\n\nneigh = KNeighborsClassifier(n_neighbors=5)\n</code></pre> <pre><code>dinov2_vits14 = dinov2_vits14.to(device)\n</code></pre> <pre><code>embeddings_labeled_assets = []\ny_true_training_knn = []\n\nfor asset in tqdm(labeled_assets):\n    class_name = asset[\"jsonMetadata\"][\"Ground Truth\"]\n    y_true_training_knn.append(class_name)\n\n    filepath = asset[\"content\"].replace(\"/data/\", \"/data/train/\" + class_name + \"/\")\n    img = Image.open(filepath)\n    img_tensor = data_transforms(img)\n    img_tensor = img_tensor.unsqueeze(0)\n    input_tensor = img_tensor.to(device)\n\n    with torch.no_grad():\n        output_tensor = dinov2_vits14(input_tensor)\n    embeddings_labeled_assets.append(output_tensor[0].cpu().numpy())\n\nneigh.fit(embeddings_labeled_assets, y_true_training_knn)\n</code></pre> <pre><code>y_pred_knn = neigh.predict(embeddings_non_labeled_assets)\n</code></pre> <pre><code>print(classification_report(y_true_non_labeled_assets, y_pred_knn))\n</code></pre> <pre><code>              precision    recall  f1-score   support\n\n          NO       0.91      0.84      0.87       100\n         YES       0.85      0.92      0.88       100\n\n    accuracy                           0.88       200\n   macro avg       0.88      0.88      0.88       200\nweighted avg       0.88      0.88      0.88       200\n</code></pre> <p>As you can see, the accuracy is lower than with the fine-tuned model.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#upload-more-manual-annotations","title":"Upload more manual annotations","text":"<p>In the section above, we uploaded model-made annotations on the non-labeled assets to Kili.</p> <p>Now, we simulate manual labeling on the non-labeled assets:</p> <pre><code>gt_external_id_array = []\ngt_json_response_array = []\n\nfor asset in non_labeled_assets:\n    gt_external_id_array.append(asset[\"externalId\"])\n    gt_json_response_array.append(\n        {\n            \"CLASSIFICATION_JOB\": {\n                \"categories\": [{\"confidence\": 100, \"name\": asset[\"jsonMetadata\"][\"Ground Truth\"]}]\n            }\n        }\n    )\n</code></pre> <pre><code>kili.append_labels(\n    project_id=project_id,\n    asset_external_id_array=gt_external_id_array,\n    json_response_array=gt_json_response_array,\n    label_type=\"DEFAULT\",\n)\n</code></pre> <p>In the Kili interface, we can filter the assets based on the disagreements between human-made labels and DINOv2-generated labels:</p> <pre><code># replace the project id below with your own!\nprint(\n    f\"https://cloud.kili-technology.com/label/projects/{project_id}/explore?inferenceMarkGte=0&amp;inferenceMarkLte=0.75\"\n)\n</code></pre> <pre><code>https://cloud.kili-technology.com/label/projects/cliistnwa003c0j78ay1y3qlm/explore?inferenceMarkGte=0&amp;inferenceMarkLte=0.75\n</code></pre> <p></p> <p>In the image above, we can see that the DINOv2 prediction has classified this asset as a negative sample, when it should have been classified as a positive sample.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#conclusion","title":"Conclusion","text":"<p>In this tutorial, we have seen how to fine-tune the DINOv2 model on a very small set of labeled images, and how to use the fine-tuned model to generate pre-annotations on a set of images to label.</p> <p>We have also seen how to evaluate the quality of the generated pre-annotations, and how to use them to speed up the labeling process.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#clean-up","title":"Clean up","text":"<p>We can now delete the project we created on Kili:</p> <pre><code>kili.delete_project(project_id=project_id)\n</code></pre>"},{"location":"sdk/tutorials/import_labels_from_geojson/","title":"Import labels from GeoJSON (GIS)","text":""},{"location":"sdk/tutorials/import_labels_from_geojson/#importing-labels-from-geojson","title":"Importing Labels from GeoJSON","text":"<p>This tutorial explains how to use the <code>kili.append_labels_from_geojson_files</code> function in the Kili SDK to import geometries from GeoJSON files and convert them to annotations in your Kili projects.</p>"},{"location":"sdk/tutorials/import_labels_from_geojson/#introduction","title":"Introduction","text":"<p>GeoJSON is a widely-used open standard format for representing simple geographical features along with their non-spatial attributes. Unlike shapefiles, GeoJSON is human-readable, supports web applications natively, and always uses the WGS84 coordinate system (EPSG:4326).</p> <p>The <code>append_labels_from_geojson_files</code> function provides three flexible modes to convert GeoJSON features into Kili annotations, making it easy to import existing geographic data into your annotation projects.</p>"},{"location":"sdk/tutorials/import_labels_from_geojson/#prerequisites","title":"Prerequisites","text":"<p>Before using this feature, ensure you have:</p> <ul> <li>A Kili project of type <code>IMAGE</code> or <code>GEOSPATIAL</code></li> <li>One or more GeoJSON files (<code>.geojson</code> or <code>.json</code>)</li> <li>Understanding of your project's job structure and categories</li> </ul>"},{"location":"sdk/tutorials/import_labels_from_geojson/#function-structure","title":"Function Structure","text":"<p>The <code>append_labels_from_geojson_files</code> function accepts the following parameters:</p> Parameter Type <code>project_id</code> str <code>asset_external_id</code> str <code>geojson_file_paths</code> List[str] <code>job_names</code> Optional[List[str]] <code>category_names</code> Optional[List[str]]"},{"location":"sdk/tutorials/import_labels_from_geojson/#supported-geometry-types","title":"Supported Geometry Types","text":"<p>The function supports the following GeoJSON geometry types and their Kili annotation mappings:</p> GeoJSON Geometry Kili Annotation Type Job Tool Required Point marker marker LineString polyline polyline Polygon polygon or semantic polygon/semantic MultiPolygon semantic semantic"},{"location":"sdk/tutorials/import_labels_from_geojson/#import-modes","title":"Import Modes","text":"<p>The function supports three different import modes, providing flexibility for various use cases:</p>"},{"location":"sdk/tutorials/import_labels_from_geojson/#mode-1-geojson-with-kili-properties","title":"Mode 1: GeoJSON with Kili Properties","text":"<p>In this mode, your GeoJSON features contain <code>kili</code> metadata in their properties, specifying the job, annotation type, and categories.</p> <p>GeoJSON Structure: <pre><code>{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [2.3522, 48.8566]\n      },\n      \"properties\": {\n        \"name\": \"Eiffel Tower\",\n        \"kili\": {\n          \"job\": \"LANDMARKS\",\n          \"type\": \"marker\",\n          \"categories\": [{\"name\": \"TOWER\"}]\n        }\n      }\n    }\n  ]\n}\n</code></pre></p> <p>Python Code: <pre><code>from kili.client import Kili\n\nkili = Kili(api_key=\"your_api_key\")\n\n# Mode 1: Import with kili properties already in GeoJSON\nkili.append_labels_from_geojson_files(\n    project_id=\"your_project_id\",\n    asset_external_id=\"paris_satellite.tif\",\n    geojson_file_paths=[\"landmarks_with_kili_props.geojson\"]\n)\n</code></pre></p>"},{"location":"sdk/tutorials/import_labels_from_geojson/#mode-2-specific-jobcategory-mapping","title":"Mode 2: Specific Job/Category Mapping","text":"<p>In this mode, you explicitly specify which job and category to use for all compatible geometries in each file.</p> <p>Python Code: <pre><code># Mode 2: Map all features to specific jobs and categories\nkili.append_labels_from_geojson_files(\n    project_id=\"your_project_id\",\n    asset_external_id=\"urban_area.jp2\",\n    geojson_file_paths=[\"roads.geojson\", \"buildings.geojson\", \"parks.geojson\"],\n    job_names=[\"INFRASTRUCTURE\", \"BUILDINGS\", \"VEGETATION\"],\n    category_names=[\"ROAD\", \"RESIDENTIAL\", \"PARK\"]\n)\n</code></pre></p>"},{"location":"sdk/tutorials/import_labels_from_geojson/#mode-3-automatic-mapping","title":"Mode 3: Automatic Mapping","text":"<p>When neither kili properties nor specific mappings are provided, the function automatically maps geometries based on their type and available jobs in your project.</p> <p>Automatic Mapping Priority:</p> <ul> <li><code>Point</code> \u2192 First available job with 'marker' tool</li> <li><code>LineString</code> \u2192 First available job with 'polyline' tool</li> <li><code>Polygon</code> \u2192 First available job with 'polygon' tool (fallback to 'semantic')</li> <li><code>MultiPolygon</code> \u2192 First available job with 'semantic' tool</li> </ul> <p>Python Code: <pre><code># Mode 3: Automatic mapping based on geometry types\nkili.append_labels_from_geojson_files(\n    project_id=\"your_project_id\",\n    asset_external_id=\"geographic_data.tif\",\n    geojson_file_paths=[\"mixed_features.geojson\"]\n)\n</code></pre></p>"},{"location":"sdk/tutorials/import_labels_from_geojson/#detailed-examples","title":"Detailed Examples","text":""},{"location":"sdk/tutorials/import_labels_from_geojson/#example-1-importing-multiple-annotation-types","title":"Example 1: Importing Multiple Annotation Types","text":"<p>This example shows how to import a GeoJSON file containing different geometry types with kili properties:</p> <pre><code>from kili.client import Kili\n\nkili = Kili(api_key=\"your_api_key\")\n\n# Create a sample GeoJSON with mixed geometries\nimport json\n\ngeojson_data = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        # Point annotation\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [-73.985428, 40.758896]\n            },\n            \"properties\": {\n                \"kili\": {\n                    \"job\": \"POI_DETECTION\",\n                    \"type\": \"marker\",\n                    \"categories\": [{\"name\": \"LANDMARK\"}]\n                }\n            }\n        },\n        # LineString annotation\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [\n                    [-73.985, 40.758],\n                    [-73.983, 40.760],\n                    [-73.981, 40.762]\n                ]\n            },\n            \"properties\": {\n                \"kili\": {\n                    \"job\": \"ROAD_MAPPING\",\n                    \"type\": \"polyline\",\n                    \"categories\": [{\"name\": \"HIGHWAY\"}]\n                }\n            }\n        },\n        # Polygon annotation\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [[\n                    [-73.980, 40.755],\n                    [-73.978, 40.755],\n                    [-73.978, 40.757],\n                    [-73.980, 40.757],\n                    [-73.980, 40.755]\n                ]]\n            },\n            \"properties\": {\n                \"kili\": {\n                    \"job\": \"ZONE_DETECTION\",\n                    \"type\": \"semantic\",\n                    \"categories\": [{\"name\": \"COMMERCIAL_AREA\"}]\n                }\n            }\n        }\n    ]\n}\n\n# Save to file\nwith open(\"mixed_annotations.geojson\", \"w\") as f:\n    json.dump(geojson_data, f)\n\n# Import into Kili\nkili.append_labels_from_geojson_files(\n    project_id=\"your_project_id\",\n    asset_external_id=\"manhattan_satellite.tif\",\n    geojson_file_paths=[\"mixed_annotations.geojson\"]\n)\n</code></pre>"},{"location":"sdk/tutorials/import_labels_from_geojson/#example-2-batch-import-with-specific-mapping","title":"Example 2: Batch Import with Specific Mapping","text":"<p>This example demonstrates importing multiple GeoJSON files with specific job/category mappings:</p> <pre><code># Import different infrastructure types\nkili.append_labels_from_geojson_files(\n    project_id=\"city_planning_project\",\n    asset_external_id=\"city_orthophoto_2024.tif\",\n    geojson_file_paths=[\n        \"water_infrastructure.geojson\",\n        \"power_lines.geojson\",\n        \"green_spaces.geojson\"\n    ],\n    job_names=[\n        \"WATER_INFRASTRUCTURE\",\n        \"ELECTRICAL_GRID\",\n        \"URBAN_VEGETATION\"\n    ],\n    category_names=[\n        \"WATER_PIPELINE\",\n        \"HIGH_VOLTAGE_LINE\",\n        \"PUBLIC_PARK\"\n    ]\n)\n</code></pre>"},{"location":"sdk/tutorials/import_labels_from_geojson/#example-3-working-with-multipolygon-features","title":"Example 3: Working with MultiPolygon Features","text":"<p>MultiPolygon features are useful for representing discontinuous areas:</p> <pre><code># Create a GeoJSON with MultiPolygon for forest patches\nforest_patches = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"MultiPolygon\",\n                \"coordinates\": [\n                    # First forest patch\n                    [[\n                        [2.10, 48.80],\n                        [2.12, 48.80],\n                        [2.12, 48.82],\n                        [2.10, 48.82],\n                        [2.10, 48.80]\n                    ]],\n                    # Second forest patch\n                    [[\n                        [2.15, 48.81],\n                        [2.17, 48.81],\n                        [2.17, 48.83],\n                        [2.15, 48.83],\n                        [2.15, 48.81]\n                    ]]\n                ]\n            },\n            \"properties\": {\n                \"kili\": {\n                    \"job\": \"LAND_COVER\",\n                    \"type\": \"semantic\",\n                    \"categories\": [{\"name\": \"DECIDUOUS_FOREST\"}]\n                }\n            }\n        }\n    ]\n}\n\n# Save and import\nwith open(\"forest_patches.geojson\", \"w\") as f:\n    json.dump(forest_patches, f)\n\nkili.append_labels_from_geojson_files(\n    project_id=\"environmental_monitoring\",\n    asset_external_id=\"sentinel2_composite.tif\",\n    geojson_file_paths=[\"forest_patches.geojson\"]\n)\n</code></pre>"},{"location":"sdk/tutorials/import_labels_from_geojson/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Validate Your GeoJSON: Use online validators (see geojson.io) or the <code>geojson</code> Python library to ensure your files are valid before import.</p> </li> <li> <p>Check Job Compatibility: Ensure your Kili project has jobs with the appropriate tools for your geometry types:    <pre><code># Check project structure\nproject = kili.projects(project_id=\"your_project_id\", fields=[\"jsonInterface\"])[0]\nprint(json.dumps(project[\"jsonInterface\"][\"jobs\"], indent=2))\n</code></pre></p> </li> </ol>"},{"location":"sdk/tutorials/import_labels_from_geojson/#troubleshooting","title":"Troubleshooting","text":""},{"location":"sdk/tutorials/import_labels_from_geojson/#problem-features-not-appearing","title":"Problem: Features Not Appearing","text":"<p>Possible causes and solutions:</p> <ol> <li> <p>Incompatible geometry-job combination:    <pre><code># Check which tools are available for each job\nproject = kili.projects(project_id=\"your_project_id\", fields=[\"jsonInterface\"])[0]\nfor job_name, job_config in project[\"jsonInterface\"][\"jobs\"].items():\n    print(f\"{job_name}: {job_config.get('tools', [])}\")\n</code></pre></p> </li> <li> <p>Coordinates outside image bounds: Verify your coordinates match the geographic extent of your image.</p> </li> </ol>"},{"location":"sdk/tutorials/import_labels_from_geojson/#problem-valueerror-for-missing-job-or-category","title":"Problem: ValueError for Missing Job or Category","text":"<p>Solution: Verify exact names in your project: <pre><code># List all jobs and categories\nproject = kili.projects(project_id=\"your_project_id\", fields=[\"jsonInterface\"])[0]\nfor job_name, job_config in project[\"jsonInterface\"][\"jobs\"].items():\n    categories = job_config.get(\"content\", {}).get(\"categories\", {})\n</code></pre></p>"},{"location":"sdk/tutorials/import_labels_from_shapefiles/","title":"Import labels from shapefiles (GIS)","text":""},{"location":"sdk/tutorials/import_labels_from_shapefiles/#importing-labels-from-shapefiles","title":"Importing Labels from Shapefiles","text":"<p>This tutorial explains how to use <code>kili.append_labels_from_shapefiles</code> function in the Kili SDK to import geometries from shapefile files and convert them to annotations in your Kili projects.</p>"},{"location":"sdk/tutorials/import_labels_from_shapefiles/#introduction","title":"Introduction","text":"<p>Shapefiles are a standard geospatial data format that stores the location, shape, and attributes of geographic features. They are commonly used in Geographic Information Systems (GIS) to represent points, lines, and polygons.</p> <p>The <code>append_labels_from_shapefiles</code> function automatically converts this spatial data into Kili annotations.</p>"},{"location":"sdk/tutorials/import_labels_from_shapefiles/#prerequisites","title":"Prerequisites","text":"<p>Before using this feature, make sure you have the following:</p> <ul> <li>A Kili project of type <code>IMAGE</code> or <code>GEOSPATIAL</code></li> <li>One or more shapefile files (<code>.shp</code>)</li> <li>Knowledge of the coordinate system (EPSG code) of your shapefiles</li> </ul>"},{"location":"sdk/tutorials/import_labels_from_shapefiles/#installation","title":"Installation","text":"<p>This feature requires additional dependencies. Install them using:</p> <pre><code>pip install 'kili[gis]'\n</code></pre> <p>This command installs the necessary libraries such as pyproj which are used for geospatial data manipulation.</p>"},{"location":"sdk/tutorials/import_labels_from_shapefiles/#function-structure","title":"Function Structure","text":"<p>The <code>append_labels_from_shapefiles</code> function takes the following parameters:</p> Parameter Type Description <code>project_id</code> str The Kili project identifier <code>asset_external_id</code> str The external identifier of the asset to annotate <code>shapefile_paths</code> List[str] List of paths to shapefile files <code>job_names</code> List[str] List of job names corresponding to each shapefile <code>category_names</code> List[str] List of category names corresponding to each shapefile <code>from_epsgs</code> Optional[List[int]] Optional list of source EPSG codes for each shapefile"},{"location":"sdk/tutorials/import_labels_from_shapefiles/#supported-geometry-types","title":"Supported Geometry Types","text":"<p>The function supports the following shapefile geometry types:</p> <ul> <li>Points (Type 1) - Converted to \"marker\" type annotations in Kili</li> <li>Polylines (Type 3) - Converted to \"polyline\" type annotations in Kili</li> <li>Polygons (Type 5) - Converted to \"semantic\" type (mask) annotations in Kili</li> </ul>"},{"location":"sdk/tutorials/import_labels_from_shapefiles/#basic-usage-example","title":"Basic Usage Example","text":"<p>Here's a simple usage example:</p> <pre><code>from kili.client import Kili\n\n# Initialize Kili client\nkili = Kili(api_key=\"your_api_key\")\n\n# Import labels from shapefiles\nkili.append_labels_from_shapefiles(\n    project_id=\"your_project_id\",\n    asset_external_id=\"satellite_image.tif\",\n    shapefile_paths=[\"roads.shp\", \"buildings.shp\", \"water_points.shp\"],\n    job_names=[\"ROADS\", \"BUILDINGS\", \"HYDROLOGY\"],\n    category_names=[\"ROAD\", \"BUILDING\", \"WATER_POINT\"],\n    from_epsgs=[4326, 4326, 4326]  # All shapefiles are in WGS84 (EPSG:4326)\n)\n</code></pre>"},{"location":"sdk/tutorials/import_labels_from_shapefiles/#advanced-example-with-different-coordinate-systems","title":"Advanced Example with Different Coordinate Systems","text":"<p>If your shapefiles use different coordinate systems:</p> <pre><code>from kili.client import Kili\n\nkili = Kili(api_key=\"your_api_key\")\n\nkili.append_labels_from_shapefiles(\n    project_id=\"your_project_id\",\n    asset_external_id=\"sentinel2_image.jp2\",\n    shapefile_paths=[\"observation_points.shp\", \"parcels.shp\", \"protected_areas.shp\"],\n    job_names=[\"OBSERVATIONS\", \"PARCELS\", \"ZONES\"],\n    category_names=[\"OBS_POINT\", \"AGRICULTURAL_PARCEL\", \"NATURE_RESERVE\"],\n    from_epsgs=[4326, 2154, 3857]  # WGS84, Lambert93, Web Mercator\n)\n</code></pre> <p>In this example, each shapefile uses a different coordinate system. The function will automatically convert all geometries to WGS84 (EPSG:4326) before importing them into Kili.</p>"},{"location":"sdk/tutorials/import_labels_from_shapefiles/#troubleshooting","title":"Troubleshooting","text":""},{"location":"sdk/tutorials/import_labels_from_shapefiles/#problem-importerror","title":"Problem: ImportError","text":"<pre><code>ImportError: This function requires the 'gis' extra dependencies.\nInstall them with: pip install kili[gis] or pip install 'kili[gis]'\n</code></pre> <p>Solution: Install the GIS dependencies:</p> <pre><code>pip install 'kili[gis]'\n</code></pre>"},{"location":"sdk/tutorials/import_labels_from_shapefiles/#problem-incorrect-coordinates-or-invisible-annotations","title":"Problem: Incorrect Coordinates or Invisible Annotations","text":"<p>Possible solutions:</p> <ul> <li>Check that you have specified the correct EPSG code for each shapefile</li> <li>Make sure the image in Kili is correctly georeferenced</li> <li>Check if the image has geospatial metadata with:</li> </ul> <pre><code>asset = kili.assets(project_id=\"your_project_id\", fields=[\"jsonContent\"])[0]\nprint(asset['jsonContent'])\n</code></pre>"},{"location":"sdk/tutorials/import_labels_from_shapefiles/#problem-categories-not-found","title":"Problem: Categories Not Found","text":"<p>Solution: Check that the category names exactly match those in your Kili ontology:</p> <pre><code>project = kili.projects(project_id=\"your_project_id\", fields=[\"jsonInterface\"])[0]\nprint(project[\"jsonInterface\"])\n</code></pre>"},{"location":"sdk/tutorials/import_labels_from_shapefiles/#conclusion","title":"Conclusion","text":"<p>The <code>append_labels_from_shapefiles</code> function greatly simplifies the import of geospatial data into Kili, allowing you to easily convert your existing GIS data into annotations usable for machine learning and manual annotation.</p>"},{"location":"sdk/tutorials/import_text_assets/","title":"Rich Text Assets","text":""},{"location":"sdk/tutorials/import_text_assets/#how-to-import-rich-text-assets","title":"How to import rich-text assets","text":"<p>When dealing with textual data, style can convey a lot of meaning. If you annotate a long list or a legal text, displaying structured text instead of plain boring text allows your annotator to rapidly grasp patterns within the document.</p>"},{"location":"sdk/tutorials/import_text_assets/#setup","title":"Setup","text":"<pre><code>%pip install kili\n</code></pre> <pre><code>from random import random\n\nfrom kili.client import Kili\n</code></pre> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/import_text_assets/#discover-rich-text-kili-format","title":"Discover rich-text Kili format","text":"<p>Let's create a named-entity recognition project that aims at labeling American legal documents.</p> <p>We start by defining the ontology of our project, with several categories:</p> <ul> <li><code>INSTRUCTIONS</code></li> <li><code>PREAMBLE</code></li> <li><code>RIGHTS</code></li> <li><code>REFERENCE_TO_GOD</code></li> </ul> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"mlTask\": \"NAMED_ENTITIES_RECOGNITION\",\n            \"instruction\": \"Categories\",\n            \"required\": 1,\n            \"isChild\": False,\n            \"isVisible\": True,\n            \"content\": {\n                \"categories\": {\n                    \"INSTRUCTIONS\": {\"name\": \"Instructions\", \"children\": [], \"color\": \"#cc4125\"},\n                    \"PREAMBLE\": {\"name\": \"Preamble\", \"children\": [], \"color\": \"#ffd966\"},\n                    \"RIGHTS\": {\"name\": \"Rights\", \"children\": [], \"color\": \"#76a5af\"},\n                    \"REFERENCE_TO_GOD\": {\n                        \"name\": \"Reference to God\",\n                        \"children\": [],\n                        \"color\": \"#c27ba0\",\n                    },\n                },\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\n</code></pre> <p>Next, we create a project:</p> <pre><code>project_id = kili.create_project(\n    json_interface=json_interface,\n    input_type=\"TEXT\",\n    title=\"[Kili SDK Notebook]: Import text assets\",\n)[\"id\"]\n</code></pre> <p>The method to use for adding assets to your Kili project is the <code>kili.append_many_to_dataset()</code> method.</p> <p>In case of rich text, you need to use the <code>json_content_array</code> argument:</p> <pre><code>kili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[json_content_1, json_content_2, etc...],\n)\n</code></pre> <p>Note that the <code>content_array</code> parameter of this method is used for uploading standard text assets.</p> <p>A <code>json_content</code> object is a Python dict that contains nodes as keys.</p> <p>Nodes can be either element nodes or text nodes.</p> <ul> <li>An element node can have children (that is a list of other elements or text nodes).</li> <li>By default, element nodes are <code>&lt;div /&gt;</code>.</li> <li>Possible types for an element node are:<ul> <li><code>blockquote</code></li> <li><code>h1</code></li> <li><code>h2</code></li> <li><code>h3</code></li> <li><code>h4</code></li> <li><code>li</code></li> <li><code>ol</code></li> <li><code>p</code></li> <li><code>table</code></li> <li><code>tbody</code></li> <li><code>td</code></li> <li><code>thead</code></li> <li><code>tr</code></li> <li><code>ul</code></li> </ul> </li> <li> <p>Available styles for a node (see Mozilla reference to learn more on CSS):</p> <ul> <li><code>alignItems</code></li> <li><code>alignSelf</code></li> <li><code>background</code></li> <li><code>backgroundColor</code></li> <li><code>border</code></li> <li><code>borderBottom</code></li> <li><code>borderLeft</code></li> <li><code>borderRadius</code></li> <li><code>borderRight</code></li> <li><code>borderTop</code></li> <li><code>color</code></li> <li><code>display</code></li> <li><code>flexDirection</code></li> <li><code>float</code></li> <li><code>fontWeight</code></li> <li><code>height</code></li> <li><code>margin</code></li> <li><code>marginBottom</code></li> <li><code>marginLeft</code></li> <li><code>marginRight</code></li> <li><code>marginTop</code></li> <li><code>maxHeight</code></li> <li><code>maxWidth</code></li> <li><code>minHeight</code></li> <li><code>minWidth</code></li> <li><code>padding</code></li> <li><code>paddingBottom</code></li> <li><code>paddingLeft</code></li> <li><code>paddingRight</code></li> <li><code>paddingTop</code></li> <li><code>textAlign</code></li> <li><code>textDecoration</code></li> <li><code>textIndent</code></li> <li><code>width</code></li> </ul> </li> <li> <p>A text node can contain text.</p> </li> <li>By default, text nodes are <code>&lt;span /&gt;</code>.</li> <li>Text nodes are identified by an <code>id</code>. The ID must be unique accross the whole document. This will allow for overlapping entities between two or more text nodes.</li> <li>Available styles for a text node:<ul> <li><code>bold: true</code></li> <li><code>code: true</code></li> <li><code>italic: true</code></li> <li><code>underline: true</code></li> <li><code>display</code></li> <li><code>float</code></li> <li><code>fontWeight</code></li> <li><code>margin</code></li> <li><code>marginBottom</code></li> <li><code>marginLeft</code></li> <li><code>marginRight</code></li> <li><code>marginTop</code></li> <li><code>padding</code></li> <li><code>paddingBottom</code></li> <li><code>paddingLeft</code></li> <li><code>paddingRight</code></li> <li><code>paddingTop</code></li> <li><code>textAlign</code></li> <li><code>textDecoration</code></li> <li><code>textIndent</code></li> </ul> </li> </ul> <p>Let's see some real examples with the corresponding result in Kili's interface!</p> <p>We can start with a really simple example:</p> <pre><code>json_content = [\n    {\n        \"children\": [\n            {\n                \"id\": f\"{random()}\",  # set your own id here\n                \"text\": \"The unanimous Declaration of the thirteen United States of America.\",\n            }\n        ]\n    }\n]\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[json_content],\n)\n</code></pre> <p>You should be able to see the new asset in the Kili project:</p> <p></p> <p>Let's try to upload the asset again, but this time with some style:</p> <pre><code>json_content = [\n    {\n        \"children\": [\n            {\n                \"id\": f\"{random()}\",\n                \"bold\": True,\n                \"underline\": True,\n                \"text\": \"The unanimous Declaration of the thirteen United States of America.\",\n            }\n        ]\n    }\n]\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[json_content],\n)\n</code></pre> <p></p> <p>Another test with an even more complex style. We can try to mix styled text nodes with plain-text nodes:</p> <pre><code>json_content = [\n    {\n        \"children\": [\n            {\n                \"type\": \"p\",\n                \"children\": [\n                    {\n                        \"id\": f\"{random()}\",\n                        \"bold\": True,\n                        \"underline\": True,\n                        \"text\": \"The unanimous Declaration\",\n                    },\n                    {\n                        \"id\": f\"{random()}\",\n                        \"bold\": True,\n                        \"text\": \" of the thirteen United States of America.\",\n                    },\n                    {\n                        \"id\": f\"{random()}\",\n                        \"text\": (\n                            \"When in the Course of human events, it becomes necessary for one\"\n                            \" people to dissolve the political bands which have connected them with\"\n                            \" another, and to assume among the powers of the earth, the separate\"\n                            \" and equal station to which the Laws of Nature and of Nature's God\"\n                            \" entitle them, a decent respect to the opinions of mankind requires\"\n                            \" that they should declare the causes which impel them to the\"\n                            \" separation.\"\n                        ),\n                    },\n                ],\n            }\n        ]\n    }\n]\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[json_content],\n)\n</code></pre> <p></p> <p>Let's create a new asset with a title, a sub title and proper margins:</p> <pre><code>json_content = [\n    {\n        \"children\": [\n            {\n                \"type\": \"h1\",\n                \"children\": [\n                    {\n                        \"border\": \"1px solid black\",\n                        \"textAlign\": \"center\",\n                        \"children\": [{\"id\": f\"{random()}\", \"text\": \"Declaration of Independence\"}],\n                    },\n                ],\n            },\n            {\n                \"type\": \"h2\",\n                \"children\": [{\"id\": f\"{random()}\", \"text\": \"In Congress, July 4, 1776\"}],\n            },\n            {\n                \"type\": \"p\",\n                \"children\": [\n                    {\n                        \"id\": f\"{random()}\",\n                        \"bold\": True,\n                        \"underline\": True,\n                        \"text\": \"The unanimous Declaration\",\n                    },\n                    {\n                        \"id\": f\"{random()}\",\n                        \"bold\": True,\n                        \"text\": \" of the thirteen United States of America.\",\n                    },\n                    {\n                        \"id\": f\"{random()}\",\n                        \"text\": (\n                            \"When in the Course of human events, it becomes necessary for one\"\n                            \" people to dissolve the political bands which have connected them with\"\n                            \" another, and to assume among the powers of the earth, the separate\"\n                            \" and equal station to which the Laws of Nature and of Nature's God\"\n                            \" entitle them, a decent respect to the opinions of mankind requires\"\n                            \" that they should declare the causes which impel them to the\"\n                            \" separation.\"\n                        ),\n                    },\n                ],\n            },\n            {\n                \"type\": \"p\",\n                \"marginLeft\": \"30px\",\n                \"marginRight\": \"30px\",\n                \"border\": \"red\",\n                \"children\": [\n                    {\n                        \"id\": f\"{random()}\",\n                        \"text\": (\n                            \"We hold these truths to be self-evident, that all men are created\"\n                            \" equal, that they are endowed by their Creator with certain\"\n                            \" unalienable Rights, that among these are Life, Liberty and the\"\n                            \" pursuit of Happiness.\"\n                        ),\n                    },\n                    {\n                        \"type\": \"ul\",\n                        \"children\": [\n                            {\n                                \"type\": \"li\",\n                                \"children\": [\n                                    {\n                                        \"id\": f\"{random()}\",\n                                        \"text\": (\n                                            \"That to secure these rights, Governments are\"\n                                            \" instituted among Men, deriving their just powers from\"\n                                            \" the consent of the governed,\"\n                                        ),\n                                    },\n                                ],\n                            },\n                            {\n                                \"type\": \"li\",\n                                \"children\": [\n                                    {\n                                        \"id\": f\"{random()}\",\n                                        \"text\": (\n                                            \"That whenever any Form of Government becomes\"\n                                            \" destructive of these ends, it is the Right of the\"\n                                            \" People to alter or to abolish it, and to institute\"\n                                            \" new Government, laying its foundation on such\"\n                                            \" principles and organizing its powers in such form, as\"\n                                            \" to them shall seem most likely to effect their Safety\"\n                                            \" and Happiness.\"\n                                        ),\n                                    },\n                                ],\n                            },\n                        ],\n                    },\n                    {\n                        \"id\": f\"{random()}\",\n                        \"text\": (\n                            \"Prudence, indeed, will dictate that Governments long established\"\n                            \" should not be changed for light and transient causes; and accordingly\"\n                            \" all experience hath shewn, that mankind are more disposed to suffer,\"\n                            \" while evils are sufferable, than to right themselves by abolishing\"\n                            \" the forms to which they are accustomed. But when a long train of\"\n                            \" abuses and usurpations, pursuing invariably the same Object evinces a\"\n                            \" design to reduce them under absolute Despotism, it is their right, it\"\n                            \" is their duty, to throw off such Government, and to provide new\"\n                            \" Guards for their future security.--Such has been the patient\"\n                            \" sufferance of these Colonies; and such is now the necessity which\"\n                            \" constrains them to alter their former Systems of Government. The\"\n                            \" history of the present King of Great Britain is a history of repeated\"\n                            \" injuries and usurpations, all having in direct object the\"\n                            \" establishment of an absolute Tyranny over these States. To prove\"\n                            \" this, let Facts be submitted to a candid world.\"\n                        ),\n                    },\n                ],\n            },\n        ],\n    },\n]\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[json_content],\n)\n</code></pre> <p></p>"},{"location":"sdk/tutorials/import_text_assets/#convert-html-to-rich-text-kili-format","title":"Convert HTML to rich-text Kili format","text":"<p>To make the whole process as seamless as possible, let's use simple Python code to transform raw HTML snippets directly into the Kili format.</p> <p>For this purpose, we will use BeautifulSoup 4, and will try to convert a simple table from Mozilla doc:</p> <pre><code>%pip install beautifulsoup4\n</code></pre> <pre><code>from bs4 import BeautifulSoup\n</code></pre> <pre><code>def from_html_to_kili(html: BeautifulSoup):\n    styles = {\n        \"table\": {\"border\": \"1px solid #333\"},\n        \"td\": {\"border\": \"1px solid #333\"},\n        \"th\": {\"backgroundColor\": \"#333\", \"color\": \"#fff\"},\n    }\n\n    if html is None:\n        return html\n\n    attributes = dict(styles[html.name]) if html.name in styles else {}\n    children = [from_html_to_kili(child) for child in html.findChildren(recursive=False)]\n    if len(children) == 0:\n        children.append({\"id\": f\"{random()}\", \"text\": html.text.strip(\"\\n\").strip()})\n    if len(children) != 0:\n        attributes[\"children\"] = children\n        if html.name != \"[document]\":\n            attributes[\"type\"] = html.name\n    return attributes\n</code></pre> <p>Below is our html content to convert to Kili json content:</p> <pre><code>html_doc = \"\"\"\n&lt;table&gt;\n    &lt;thead&gt;\n        &lt;tr&gt;\n            &lt;th colspan=\"2\"&gt;The table header&lt;/th&gt;\n        &lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody&gt;\n        &lt;tr&gt;\n            &lt;td&gt;The table body&lt;/td&gt;\n            &lt;td border=\"1px solid #333\"&gt;with two columns&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/tbody&gt;\n&lt;/table&gt;\n\"\"\"\n</code></pre> <p>Let's convert it using our custom method:</p> <pre><code>soup = BeautifulSoup(html_doc, \"html.parser\")\njson_content = [from_html_to_kili(soup)]\nprint(json_content)\n</code></pre> <pre><code>[{'children': [{'border': '1px solid #333', 'children': [{'children': [{'children': [{'backgroundColor': '#333', 'color': '#fff', 'children': [{'id': '0.06746091905311846', 'text': 'The table header'}], 'type': 'th'}], 'type': 'tr'}], 'type': 'thead'}, {'children': [{'children': [{'border': '1px solid #333', 'children': [{'id': '0.6734828512730971', 'text': 'The table body'}], 'type': 'td'}, {'border': '1px solid #333', 'children': [{'id': '0.38249704337851276', 'text': 'with two columns'}], 'type': 'td'}], 'type': 'tr'}], 'type': 'tbody'}], 'type': 'table'}]}]\n</code></pre> <p>Finally, we upload it to our Kili project:</p> <pre><code>kili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[json_content],\n)\n</code></pre> <p>OIn Kili, the table looks like this:</p> <p></p> <p>Congrats! \ud83d\udc4f</p> <p>In this tutorial, we have learned how to import rich-text assets with styled text nodes into a Kili project.</p> <p>Now, armed with these techniques, you can start building your own Kili projects with styled and structured text data!</p>"},{"location":"sdk/tutorials/import_text_assets/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/importing_assets_and_metadata/","title":"Importing Assets","text":""},{"location":"sdk/tutorials/importing_assets_and_metadata/#how-to-import-assets-to-a-kili-project","title":"How to import assets to a Kili project","text":"<p>In this tutorial, we will learn how to import assets to your project, and add metadata to those assets.</p> <p>Here are the steps that we will follow:</p> <ol> <li>Setting up a simple Kili project to work with</li> <li>Importing assets to Kili</li> <li>Adding metadata to assets</li> </ol>"},{"location":"sdk/tutorials/importing_assets_and_metadata/#setting-up-a-simple-kili-project-to-work-with","title":"Setting up a simple Kili project to work with","text":""},{"location":"sdk/tutorials/importing_assets_and_metadata/#installing-and-instantiating-kili","title":"Installing and instantiating Kili","text":"<p>First, let's install and import the required modules.</p> <pre><code>%pip install  kili\n</code></pre> <pre><code>from kili.client import Kili\n</code></pre> <p>Now, let's set up variables needed to create an instance of the Kili object.</p> <p>We will need your API key and Kili's API endpoint.</p> <p>If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key.</p> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_assets_and_metadata/#creating-a-basic-kili-project","title":"Creating a basic Kili project","text":"<p>To create a Kili project, you must first set up its interface.</p> <p>We will create a simple image project with just one simple classification job and two categories: <code>OBJECT_A</code> and <code>OBJECT_B</code>.</p> <p>To learn more about Kili project interfaces, refer to https://docs.kili-technology.com/docs/customizing-project-interface.</p> <pre><code>interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 1,\n            \"isChild\": False,\n            \"content\": {\n                \"categories\": {\"OBJECT_A\": {\"name\": \"Object A\"}, \"OBJECT_B\": {\"name\": \"Object B\"}},\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\n\nproject = kili.create_project(\n    title=\"[Kili SDK Notebook]: Importing assets with metadata\",\n    description=\"Project Description\",\n    input_type=\"IMAGE\",\n    json_interface=interface,\n)\n</code></pre> <p>For further processing, we will need to find out what our project ID is.</p> <p>We can easily retrieve it from the project creation response message:</p> <pre><code>project_id = project[\"id\"]\nprint(\"Project ID: \", project_id)\n</code></pre> <pre><code>Project ID:  cllamrwgl00670j393poh2t4j\n</code></pre>"},{"location":"sdk/tutorials/importing_assets_and_metadata/#importing-assets-to-kili","title":"Importing assets to Kili","text":"<p>Now, let's add some assets to be labeled.</p> <p>We will use some free off-the-shelf examples from the Internet.</p> <pre><code>url1 = \"https://storage.googleapis.com/label-public-staging/car/car_2.jpg\"\nurl2 = \"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\"\nurl3 = \"https://storage.googleapis.com/label-public-staging/recipes/inference/black_car.jpg\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[url1, url2, url3],\n    external_id_array=[\"image_1\", \"image_2\", \"image_3\"],  # name to give to assets\n)\n</code></pre> <p>At this point, you should be able to see your assets in your Kili project:</p> <p></p> <p>If you prefer to add your own images, you can use a local file. The code to do that would look similar to this:</p> <pre><code>project_id = 'project_id'\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=['./image_1.jpeg'], # Path to local image\n    external_id_array=['image_1']\n)\n</code></pre> <p>The procedure looks the same for most of other data types, like PDFs or text. For more information on supported file formats, refer to our documentation.</p> <p>Because videos and Rich Text assets may be more complex to import, we've created separate tutorials devoted to them:</p> <ul> <li>For information on importing video assets, refer to this tutorial.</li> <li>For information on importing Rich Text assets, see here.</li> </ul> <p>For more information on importing assets, refer to our documentation.</p>"},{"location":"sdk/tutorials/importing_assets_and_metadata/#adding-metadata-to-assets","title":"Adding metadata to assets","text":"<p>In Kili, you can add extra information to an asset by using asset metadata. The metadata can contain extra information like what language the document was written in, custom quality metrics, agreement metrics etc., and can be used with Kili's advanced filters. The metadata can also contain text extracted from images or PDF documents using OCR (Optical Character Recognition), and that will be shown in the Kili labeling interface.</p> <p>Additionally, three specific metadata types can be used as information presented to labelers in Kili interface:</p> <ul> <li><code>imageUrl</code></li> <li><code>text</code></li> <li><code>url</code></li> </ul>"},{"location":"sdk/tutorials/importing_assets_and_metadata/#setting-metadata-properties","title":"Setting metadata properties","text":"<p>As an optional step, you can define properties for each type of your metadata. These properties allow you to control:</p> <ul> <li>The data type (<code>string</code>, <code>number</code> or <code>date</code>)</li> <li>Whether the metadata is filterable in project queue</li> <li>Visibility of each metadata to labelers and reviewers</li> </ul> <pre><code>kili.update_properties_in_project(\n    project_id=project_id,\n    metadata_properties={\n        \"customConsensus\": {\n            \"type\": \"number\",\n            \"filterable\": True,\n            \"visibleByLabeler\": True,\n            \"visibleByReviewer\": True,\n        },\n        \"sensitiveData\": {\n            \"type\": \"string\",\n            \"filterable\": True,\n            \"visibleByLabeler\": False,  # Hide this from labelers\n            \"visibleByReviewer\": True,\n        },\n        \"uploadedFromCloud\": {\n            \"type\": \"string\",\n            \"filterable\": True,\n            \"visibleByLabeler\": True,\n            \"visibleByReviewer\": True,\n        },\n        \"modelLabelErrorScore\": {\n            \"type\": \"number\",\n            \"filterable\": True,\n            \"visibleByLabeler\": True,\n            \"visibleByReviewer\": True,\n        },\n        \"date\": {\n            \"type\": \"date\",\n            \"filterable\": True,\n            \"visibleByLabeler\": True,\n            \"visibleByReviewer\": True,\n        },\n    },\n)\n</code></pre> <p>Note: The previous <code>metadata_types</code> parameter is deprecated. Please use metadata_properties instead. If you use metadata_types, it will still work but will be converted to metadata_properties internally with default visibility and filterability settings.</p> <p>If you don't specify all properties, default values will be used:</p> <pre><code>filterable: true\ntype: 'string'\nvisibleByLabeler: true\nvisibleByReviewer: true\n</code></pre> <p>Now we can add metadata to our assets:</p> <pre><code>external_ids = [\"image_1\", \"image_2\"]\n\nkili.update_properties_in_assets(\n    project_id=project_id,\n    external_ids=external_ids,\n    json_metadatas=[\n        {\n            \"customConsensus\": 10,\n            \"sensitiveData\": \"yes\",\n            \"uploadedFromCloud\": \"no\",\n            \"modelLabelErrorScore\": 50,\n            \"imageUrl\": \"https://placehold.co/600x400/EEE/31343C\",\n            \"text\": \"Some text for asset 1\",\n            \"url\": \"www.example-website.com\",\n            \"date\": \"2023-10-01T12:00:00Z\",\n        },\n        {\n            \"customConsensus\": 40,\n            \"sensitiveData\": \"no\",\n            \"uploadedFromCloud\": \"yes\",\n            \"modelLabelErrorScore\": 30,\n            \"imageUrl\": \"https://placehold.co/600x400/EEE/31343C\",\n            \"text\": \"Some text for asset 2\",\n            \"url\": \"www.example-website.com\",\n            \"date\": \"2023-24-03T14:00:00Z\",\n        },\n    ],\n)\n</code></pre> <pre><code>[{'id': 'cllams1oz0000jhvz4hyxy0en'}, {'id': 'cllams1p00001jhvz75twgx7d'}]\n</code></pre> <p>Note : alternatively, you can use <code>kili.set_metadata</code> or <code>kili.add_metadata</code> methods.</p> <p>In the labeling interface, we can see that the assets have some metadata (note that <code>sensitiveData</code> will be hidden from labelers based on our settings).</p> <p></p> <p>If you want to add metadata based on Optical Character Recognition, the process is slightly different. To help you with it, we've created a separate tutorial.</p> <p>For more information on adding asset metadata, refer to our documentation.</p>"},{"location":"sdk/tutorials/importing_assets_and_metadata/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/importing_assets_and_metadata/#summary","title":"Summary","text":"<p>We've successfully set up a Kili project, imported assets to it, and finally added some metadata to our assets with advanced property settings. Well done!</p>"},{"location":"sdk/tutorials/importing_coco/","title":"COCO","text":""},{"location":"sdk/tutorials/importing_coco/#how-to-import-coco-annotations-into-kili","title":"How to import COCO annotations into Kili","text":"<p>In this tutorial, we will demonstrate how to import COCO annotations into Kili.</p>"},{"location":"sdk/tutorials/importing_coco/#setup","title":"Setup","text":"<p>Let's start by installing Kili:</p> <pre><code>%pip install kili numpy opencv-python\n</code></pre> <pre><code>import json\nfrom pprint import pprint\n\nimport numpy as np\n\nfrom kili.client import Kili\n</code></pre>"},{"location":"sdk/tutorials/importing_coco/#data-collection","title":"Data collection","text":"<p>We will use the COCO dataset to illustrate how to import COCO annotations into Kili.</p> <p>For this tutorial, we will use a subset of the <code>val2017</code> dataset. The full dataset can be downloaded here.</p> <pre><code>!curl https://raw.githubusercontent.com/kili-technology/kili-python-sdk/main/recipes/datasets/coco2017/annotations/captions_val2017_filtered.json --output captions_val2017_filtered.json\n!curl https://raw.githubusercontent.com/kili-technology/kili-python-sdk/main/recipes/datasets/coco2017/annotations/instances_val2017_filtered.json --output instances_val2017_filtered.json\n!curl https://raw.githubusercontent.com/kili-technology/kili-python-sdk/main/recipes/datasets/coco2017/annotations/person_keypoints_val2017_filtered.json --output person_keypoints_val2017_filtered.json\n</code></pre>"},{"location":"sdk/tutorials/importing_coco/#coco-format","title":"COCO format","text":"<p>The format is described here.</p> <p>The file <code>instances_val2017_filtered.json</code> contains the following keys:</p> <pre><code>instances_val2017 = json.load(open(\"instances_val2017_filtered.json\"))\nprint(instances_val2017.keys())\n</code></pre> <pre><code>dict_keys(['annotations', 'categories', 'images', 'info', 'licenses'])\n</code></pre> <p>Each annotation contains a the image id to which it belongs, the category id, the segmentation and the bounding box:</p> <pre><code>pprint(instances_val2017[\"annotations\"][0])\n</code></pre> <pre><code>{'area': 88.52115000000006,\n 'bbox': [102.49, 118.47, 7.9, 17.31],\n 'category_id': 64,\n 'id': 22328,\n 'image_id': 37777,\n 'iscrowd': 0,\n 'segmentation': [[110.39,\n                   135.78,\n                   110.39,\n                   127.62,\n                   110.01,\n                   119.6,\n                   106.87,\n                   118.47,\n                   104.37,\n                   120.1,\n                   102.49,\n                   122.73,\n                   103.74,\n                   125.49,\n                   105.24,\n                   128.88,\n                   106.87,\n                   132.39,\n                   107.38,\n                   135.78,\n                   110.39,\n                   135.65]]}\n</code></pre> <p>We can print the categories of COCO this way:</p> <pre><code>for category in instances_val2017[\"categories\"]:\n    print(category[\"id\"], category[\"name\"])\n</code></pre> <pre><code>1 person\n2 bicycle\n3 car\n4 motorcycle\n5 airplane\n6 bus\n7 train\n8 truck\n9 boat\n10 traffic light\n11 fire hydrant\n13 stop sign\n14 parking meter\n15 bench\n16 bird\n17 cat\n18 dog\n19 horse\n20 sheep\n21 cow\n22 elephant\n23 bear\n24 zebra\n25 giraffe\n27 backpack\n28 umbrella\n31 handbag\n32 tie\n33 suitcase\n34 frisbee\n35 skis\n36 snowboard\n37 sports ball\n38 kite\n39 baseball bat\n40 baseball glove\n41 skateboard\n42 surfboard\n43 tennis racket\n44 bottle\n46 wine glass\n47 cup\n48 fork\n49 knife\n50 spoon\n51 bowl\n52 banana\n53 apple\n54 sandwich\n55 orange\n56 broccoli\n57 carrot\n58 hot dog\n59 pizza\n60 donut\n61 cake\n62 chair\n63 couch\n64 potted plant\n65 bed\n67 dining table\n70 toilet\n72 tv\n73 laptop\n74 mouse\n75 remote\n76 keyboard\n77 cell phone\n78 microwave\n79 oven\n80 toaster\n81 sink\n82 refrigerator\n84 book\n85 clock\n86 vase\n87 scissors\n88 teddy bear\n89 hair drier\n90 toothbrush\n</code></pre> <p>The file <code>captions_val2017_filtered.json</code> contains transcription data:</p> <pre><code>captions_val2017 = json.load(open(\"captions_val2017_filtered.json\"))\nprint(captions_val2017.keys())\n</code></pre> <pre><code>dict_keys(['annotations', 'images', 'info', 'licenses'])\n</code></pre> <pre><code>print(captions_val2017[\"annotations\"][0])\n</code></pre> <pre><code>{'caption': 'A small closed toilet in a cramped space.', 'id': 441, 'image_id': 331352}\n</code></pre> <p>In this dataset, each image has 5 captions given by different annotators.</p> <p>The file <code>person_keypoints_val2017_filtered.json</code> contains keypoints data:</p> <pre><code>person_keypoints_val2017 = json.load(open(\"person_keypoints_val2017_filtered.json\"))\nprint(person_keypoints_val2017.keys())\n</code></pre> <pre><code>dict_keys(['annotations', 'categories', 'images', 'info', 'licenses'])\n</code></pre> <pre><code>pprint(person_keypoints_val2017[\"annotations\"][0])\n</code></pre> <pre><code>{'area': 17376.91885,\n 'bbox': [388.66, 69.92, 109.41, 277.62],\n 'category_id': 1,\n 'id': 200887,\n 'image_id': 397133,\n 'iscrowd': 0,\n 'keypoints': [433,\n               94,\n               2,\n               434,\n               90,\n               2,\n               0,\n               0,\n               0,\n               443,\n               98,\n               2,\n               0,\n               0,\n               0,\n               420,\n               128,\n               2,\n               474,\n               133,\n               2,\n               396,\n               162,\n               2,\n               489,\n               173,\n               2,\n               0,\n               0,\n               0,\n               0,\n               0,\n               0,\n               419,\n               214,\n               2,\n               458,\n               215,\n               2,\n               411,\n               274,\n               2,\n               458,\n               273,\n               2,\n               402,\n               333,\n               2,\n               465,\n               334,\n               2],\n 'num_keypoints': 13,\n 'segmentation': [[446.71,\n                   70.66,\n                   466.07,\n                   72.89,\n                   471.28,\n                   78.85,\n                   473.51,\n                   88.52,\n                   473.51,\n                   98.2,\n                   462.34,\n                   111.6,\n                   475.74,\n                   126.48,\n                   484.67,\n                   136.16,\n                   494.35,\n                   157.74,\n                   496.58,\n                   174.12,\n                   498.07,\n                   182.31,\n                   485.42,\n                   189.75,\n                   474.25,\n                   189.01,\n                   470.53,\n                   202.4,\n                   475.74,\n                   337.12,\n                   469.04,\n                   347.54,\n                   455.65,\n                   343.08,\n                   450.44,\n                   323.72,\n                   441.5,\n                   255.99,\n                   433.32,\n                   250.04,\n                   406.52,\n                   340.1,\n                   397.59,\n                   344.56,\n                   388.66,\n                   330.42,\n                   408.01,\n                   182.31,\n                   396.85,\n                   186.77,\n                   392.38,\n                   177.84,\n                   389.4,\n                   166.68,\n                   390.89,\n                   147.32,\n                   418.43,\n                   119.04,\n                   434.06,\n                   111.6,\n                   429.6,\n                   98.94,\n                   428.85,\n                   81.08,\n                   441.5,\n                   72.89,\n                   443.74,\n                   69.92]]}\n</code></pre>"},{"location":"sdk/tutorials/importing_coco/#kili-project-creation","title":"Kili project creation","text":"<p>Let's create the Kili project that will contain the images and annotations of the COCO dataset.</p> <p>Below, we initialize the Kili client:</p> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre> <p>The <code>json_interface</code> variable contains the ontology of the project.</p> <pre><code>json_interface = {\"jobs\": {}}\n</code></pre> <p>We start by defining the transcription job, that aims describing the image content:</p> <pre><code>json_interface[\"jobs\"][\"TRANSCRIPTION_JOB\"] = {\n    \"content\": {\"input\": \"textField\"},\n    \"instruction\": \"Caption\",\n    \"mlTask\": \"TRANSCRIPTION\",\n    \"required\": 0,\n    \"isChild\": False,\n}\n</code></pre> <p>In the dictionary below, we map the category ids to the category names:</p> <pre><code>category_id_to_name = {\n    category[\"id\"]: category[\"name\"] for category in instances_val2017[\"categories\"]\n}\n</code></pre> <pre><code>categories = {\n    category[\"name\"]: {\"children\": [], \"name\": category[\"name\"], \"id\": category[\"id\"]}\n    for category in instances_val2017[\"categories\"]\n}\n</code></pre> <p>We also define object detection jobs:</p> <pre><code>json_interface[\"jobs\"][\"OBJECT_DETECTION_JOB\"] = {\n    \"content\": {\"categories\": categories, \"input\": \"radio\"},\n    \"instruction\": \"BBox\",\n    \"mlTask\": \"OBJECT_DETECTION\",\n    \"required\": 0,\n    \"tools\": [\"rectangle\"],\n    \"isChild\": False,\n}\n</code></pre> <pre><code>json_interface[\"jobs\"][\"SEGMENTATION_JOB\"] = {\n    \"content\": {\"categories\": categories, \"input\": \"radio\"},\n    \"instruction\": \"Segment\",\n    \"mlTask\": \"OBJECT_DETECTION\",\n    \"required\": 0,\n    \"tools\": [\"semantic\"],\n    \"isChild\": False,\n}\n</code></pre> <p>And a pose estimation job:</p> <pre><code>map_key_cat_to_body_part = {\n    \"nose\": \"face\",\n    \"left_eye\": \"face\",\n    \"right_eye\": \"face\",\n    \"left_ear\": \"face\",\n    \"right_ear\": \"face\",\n    \"left_shoulder\": \"upper_body_left\",\n    \"right_shoulder\": \"upper_body_right\",\n    \"left_elbow\": \"upper_body_left\",\n    \"right_elbow\": \"upper_body_right\",\n    \"left_wrist\": \"upper_body_left\",\n    \"right_wrist\": \"upper_body_right\",\n    \"left_hip\": \"lower_body_left\",\n    \"right_hip\": \"lower_body_right\",\n    \"left_knee\": \"lower_body_left\",\n    \"right_knee\": \"lower_body_right\",\n    \"left_ankle\": \"lower_body_left\",\n    \"right_ankle\": \"lower_body_right\",\n}\n</code></pre> <pre><code>json_interface[\"jobs\"][\"POSE_ESTIMATION_JOB\"] = {\n    \"content\": {\n        \"categories\": {\n            \"face\": {\n                \"children\": [],\n                \"name\": \"face\",\n                \"points\": [\n                    {\"code\": \"nose\", \"name\": \"nose\"},\n                    {\"code\": \"left_eye\", \"name\": \"left_eye\"},\n                    {\"code\": \"right_eye\", \"name\": \"right_eye\"},\n                    {\"code\": \"left_ear\", \"name\": \"left_ear\"},\n                    {\"code\": \"right_ear\", \"name\": \"right_ear\"},\n                ],\n            },\n            \"upper_body_left\": {\n                \"children\": [],\n                \"name\": \"upper_body_left\",\n                \"points\": [\n                    {\"code\": \"left_shoulder\", \"name\": \"left_shoulder\"},\n                    {\"code\": \"left_elbow\", \"name\": \"left_elbow\"},\n                    {\"code\": \"left_wrist\", \"name\": \"left_wrist\"},\n                ],\n            },\n            \"upper_body_right\": {\n                \"children\": [],\n                \"name\": \"upper_body_right\",\n                \"points\": [\n                    {\"code\": \"right_shoulder\", \"name\": \"right_shoulder\"},\n                    {\"code\": \"right_elbow\", \"name\": \"right_elbow\"},\n                    {\"code\": \"right_wrist\", \"name\": \"right_wrist\"},\n                ],\n            },\n            \"lower_body_left\": {\n                \"children\": [],\n                \"name\": \"lower_body_left\",\n                \"points\": [\n                    {\"code\": \"left_hip\", \"name\": \"left_hip\"},\n                    {\"code\": \"left_knee\", \"name\": \"left_knee\"},\n                    {\"code\": \"left_ankle\", \"name\": \"left_ankle\"},\n                ],\n            },\n            \"lower_body_right\": {\n                \"children\": [],\n                \"name\": \"lower_body_right\",\n                \"points\": [\n                    {\"code\": \"right_hip\", \"name\": \"right_hip\"},\n                    {\"code\": \"right_knee\", \"name\": \"right_knee\"},\n                    {\"code\": \"right_ankle\", \"name\": \"right_ankle\"},\n                ],\n            },\n        },\n        \"input\": \"radio\",\n    },\n    \"instruction\": \"Pose estimation\",\n    \"mlTask\": \"OBJECT_DETECTION\",\n    \"required\": 0,\n    \"tools\": [\"pose\"],\n    \"isChild\": False,\n}\n</code></pre> <pre><code>project = kili.create_project(\n    title=\"[Kili SDK Notebook]: COCO 2017\",\n    input_type=\"IMAGE\",\n    json_interface=json_interface,\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_coco/#importing-images","title":"Importing images","text":"<p>Now that our project is created, let's import the images:</p> <pre><code>content_array = []\nexternal_id_array = []\nfor image in instances_val2017[\"images\"]:\n    content_array.append(image[\"flickr_url\"].replace(\"http://\", \"https://\"))\n    external_id_array.append(str(image[\"id\"]))\n</code></pre> <pre><code>kili.append_many_to_dataset(\n    project[\"id\"], content_array=content_array, external_id_array=external_id_array\n)\n</code></pre> <p></p>"},{"location":"sdk/tutorials/importing_coco/#importing-annotations","title":"Importing annotations","text":"<p>Below, we import some useful functions to convert annotations to Kili label format:</p> <pre><code>from typing import Dict, List\n\nfrom kili.utils.labels.bbox import bbox_points_to_normalized_vertices, point_to_normalized_point\nfrom kili.utils.labels.image import mask_to_normalized_vertices\n</code></pre> <pre><code>def coco_bbox_annotation_to_normalized_vertices(\n    coco_ann: Dict, *, img_width: int, img_height: int\n) -&gt; List[Dict]:\n    x, y, width, height = coco_ann[\"bbox\"]\n    ret = bbox_points_to_normalized_vertices(\n        bottom_left={\"x\": x, \"y\": y + height},\n        bottom_right={\"x\": x + width, \"y\": y + height},\n        top_right={\"x\": x + width, \"y\": y},\n        top_left={\"x\": x, \"y\": y},\n        img_height=img_height,\n        img_width=img_width,\n        origin_location=\"top_left\",\n    )\n    return ret\n</code></pre> <pre><code>def coco_segm_annotation_to_normalized_vertices(\n    coco_ann: Dict, *, img_width: int, img_height: int\n) -&gt; List[List[Dict]]:\n    coco_segmentations = coco_ann[\"segmentation\"]\n\n    ret = []\n    for coco_segm in coco_segmentations:\n        if coco_ann[\"iscrowd\"] == 0:\n            # a single object (iscrowd=0 in which case polygons are used)[\n            vertices = [\n                point_to_normalized_point(\n                    point={\"x\": x, \"y\": y},\n                    img_height=img_height,\n                    img_width=img_width,\n                    origin_location=\"top_left\",\n                )\n                for x, y in zip(coco_segm[::2], coco_segm[1::2])\n            ]\n            ret.append(vertices)\n\n        else:\n            # a crowd (iscrowd=1 in which case RLE (run-length encoding) is used)\n            rle_counts = coco_segmentations[\"counts\"]\n            mask = np.zeros(img_height * img_width, dtype=np.uint8)  # flat image\n            pixel_index = 0\n            for i, count in enumerate(rle_counts):\n                if i % 2 == 1:\n                    # we set pixels' value\n                    mask[pixel_index : pixel_index + count] = 255\n                pixel_index += count\n\n            # we reshape the mask to its original shape\n            # and we transpose it to have the same shape as the image\n            # (i.e. (height, width))\n            mask = mask.reshape((img_width, img_height)).T\n\n            # we convert the mask to normalized vertices\n            # hierarchy is not used here. It is used for polygons with holes.\n            normalized_vertices, hierarchy = mask_to_normalized_vertices(mask)\n            ret.extend(normalized_vertices)\n\n    return ret\n</code></pre> <pre><code>json_response_array = []\n\nfor image_id in external_id_array:\n    img_info = [img for img in instances_val2017[\"images\"] if img[\"id\"] == int(image_id)][0]\n    img_width = img_info[\"width\"]\n    img_height = img_info[\"height\"]\n\n    # json response contains the label data for the image\n    json_resp = {}\n\n    ### Transcription job\n    img_captions = [\n        ann for ann in captions_val2017[\"annotations\"] if ann[\"image_id\"] == int(image_id)\n    ]\n    json_resp[\"TRANSCRIPTION_JOB\"] = {\n        \"text\": img_captions[0][\"caption\"]  # we only take the 1st caption for sake of simplicity\n    }\n\n    ### Object detection and segmentation annotations\n    coco_annotations = [\n        ann for ann in instances_val2017[\"annotations\"] if ann[\"image_id\"] == int(image_id)\n    ]\n    kili_bbox_annotations = []\n    kili_segm_annotations = []\n    for coco_ann in coco_annotations:\n        ### Object detection job\n        if coco_ann[\"iscrowd\"] == 0:\n            # we skip crowd annotations bbox since they tend to be very large\n            kili_bbox_ann = {\n                \"children\": {},\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": coco_bbox_annotation_to_normalized_vertices(\n                            coco_ann, img_width=img_width, img_height=img_height\n                        )\n                    }\n                ],\n                \"categories\": [{\"name\": category_id_to_name[coco_ann[\"category_id\"]]}],\n                \"type\": \"rectangle\",\n                \"mid\": str(coco_ann[\"id\"]) + \"_bbox\",\n            }\n            kili_bbox_annotations.append(kili_bbox_ann)\n\n        ### Segmentation job\n        for i, norm_vertices in enumerate(\n            coco_segm_annotation_to_normalized_vertices(\n                coco_ann, img_width=img_width, img_height=img_height\n            )\n        ):\n            kili_segm_ann = {\n                \"children\": {},\n                \"boundingPoly\": [{\"normalizedVertices\": norm_vertices}],\n                \"categories\": [{\"name\": category_id_to_name[coco_ann[\"category_id\"]]}],\n                \"type\": \"semantic\",\n                \"mid\": str(coco_ann[\"id\"]) + \"_segm_\" + str(i),\n            }\n            kili_segm_annotations.append(kili_segm_ann)\n\n    ### Pose estimation annotations\n    coco_annotations = [\n        ann for ann in person_keypoints_val2017[\"annotations\"] if ann[\"image_id\"] == int(image_id)\n    ]\n    kili_keypoints_annotations = []\n    for coco_ann in coco_annotations:\n        keypoints = coco_ann[\"keypoints\"]\n        for body_part in (\n            \"face\",\n            \"upper_body_left\",\n            \"upper_body_right\",\n            \"lower_body_left\",\n            \"lower_body_right\",\n        ):\n            kili_keypoint_ann = {\n                \"categories\": [{\"name\": body_part}],\n                \"children\": {},\n                \"jobName\": \"POSE_ESTIMATION_JOB\",\n                \"kind\": \"POSE_ESTIMATION\",\n                \"mid\": str(coco_ann[\"id\"]) + \"_keypoints_\" + body_part,\n                \"points\": [],\n                \"type\": \"pose\",\n            }\n            for x, y, visibility, point_type in zip(\n                keypoints[::3],\n                keypoints[1::3],\n                keypoints[2::3],\n                person_keypoints_val2017[\"categories\"][0][\"keypoints\"],\n            ):\n                if x == y == visibility == 0:\n                    continue\n                if map_key_cat_to_body_part[point_type] != body_part:\n                    continue\n                kili_keypoint_ann[\"points\"].append(\n                    {\n                        \"children\": {},\n                        \"code\": point_type,\n                        \"jobName\": \"POSE_ESTIMATION_JOB\",\n                        \"mid\": str(coco_ann[\"id\"]) + \"_keypoints_\" + point_type,\n                        \"name\": point_type,\n                        \"type\": \"marker\",\n                        \"point\": point_to_normalized_point(\n                            point={\"x\": x, \"y\": y},\n                            img_height=img_height,\n                            img_width=img_width,\n                            origin_location=\"top_left\",\n                        ),\n                    }\n                )\n\n            kili_keypoints_annotations.append(kili_keypoint_ann)\n\n    json_resp[\"OBJECT_DETECTION_JOB\"] = {\"annotations\": kili_bbox_annotations}\n    json_resp[\"SEGMENTATION_JOB\"] = {\"annotations\": kili_segm_annotations}\n    json_resp[\"POSE_ESTIMATION_JOB\"] = {\"annotations\": kili_keypoints_annotations}\n\n    json_response_array.append(json_resp)\n</code></pre> <pre><code>kili.append_labels(\n    asset_external_id_array=external_id_array,\n    project_id=project[\"id\"],\n    json_response_array=json_response_array,\n)\n</code></pre> <p>In Kili labeling interface, we can see the images and the annotations:</p> <p></p>"},{"location":"sdk/tutorials/importing_coco/#conclusion","title":"Conclusion","text":"<p>In this tutorial, we have seen how to import COCO annotations into Kili.</p> <p>You can now use Kili to refine and review your annotations, in order to train your machine learning models on high quality data.</p>"},{"location":"sdk/tutorials/importing_coco/#cleaning-up","title":"Cleaning up","text":"<pre><code>kili.delete_project(project_id=project[\"id\"])\n</code></pre>"},{"location":"sdk/tutorials/importing_labels/","title":"Importing Labels","text":""},{"location":"sdk/tutorials/importing_labels/#how-to-import-labels-to-a-kili-project","title":"How to import labels to a Kili project","text":"<p>In this tutorial, you will learn how to import labels to your project.</p> <p>Here are the steps that we will follow:</p> <ol> <li>Setting up a simple Kili project to work with</li> <li>Importing some assets to the project</li> <li>Importing model-based pre-annotations</li> <li>Importing pre-existing labels</li> </ol>"},{"location":"sdk/tutorials/importing_labels/#setting-up-a-simple-kili-project-to-work-with","title":"Setting up a simple Kili project to work with","text":""},{"location":"sdk/tutorials/importing_labels/#installing-and-instantiating-kili","title":"Installing and instantiating Kili","text":"<p>First, let's install and import the required modules.</p> <pre><code>%pip install  kili\n</code></pre> <pre><code>from kili.client import Kili\n</code></pre> <p>Now, let's set up variables needed to create an instance of the Kili object.</p> <p>We will need your API key and Kili's API endpoint.</p> <p>If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key.</p> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_labels/#creating-a-basic-kili-project","title":"Creating a basic Kili project","text":"<p>To create a Kili project, you must first set up its interface.</p> <p>We will create a simple image project with just one simple classification job and two categories: <code>OBJECT_A</code> and <code>OBJECT_B</code>.</p> <p>To learn more about Kili project interfaces, refer to https://docs.kili-technology.com/docs/customizing-project-interface.</p> <pre><code>interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 1,\n            \"isChild\": False,\n            \"content\": {\n                \"categories\": {\"OBJECT_A\": {\"name\": \"Object A\"}, \"OBJECT_B\": {\"name\": \"Object B\"}},\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\n\nresult = kili.create_project(\n    title=\"[Kili SDK Notebook]: Importing labels\",\n    description=\"Project Description\",\n    input_type=\"IMAGE\",\n    json_interface=interface,\n)\n</code></pre> <p>For further processing, we will need to find out what our project ID is.</p> <p>We can easily retrieve it from the project creation response message:</p> <pre><code>project_id = result[\"id\"]\nprint(\"Project ID: \", project_id)\n</code></pre> <pre><code>Project ID:  clfwbvgpm00330jrne4n40m70\n</code></pre>"},{"location":"sdk/tutorials/importing_labels/#importing-assets-to-kili","title":"Importing assets to Kili","text":"<p>Now, let's add some assets to be labeled.</p> <p>We will use some free off-the-shelf examples from the Internet.</p> <pre><code>url1 = \"https://storage.googleapis.com/label-public-staging/car/car_2.jpg\"\nurl2 = \"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\"\nurl3 = \"https://storage.googleapis.com/label-public-staging/recipes/inference/black_car.jpg\"\n\nasset_external_id_array = [\"image_1\", \"image_2\", \"image_3\"]\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[url1, url2, url3],\n    external_id_array=asset_external_id_array,\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_labels/#importing-model-based-pre-annotations-into-your-project","title":"Importing model-based pre-annotations into your project","text":"<p>When you import pre-annotations, you can use two types of labels: <code>PREDICTION</code> and <code>INFERENCE</code>.</p> <p><code>PREDICTION</code>-type annotations will be displayed on the asset during the labeling process. Labelers will be able to confirm what model produced, edit, and/or add new annotations.</p> <p>Unlike <code>PREDICTION</code>-type labels, <code>INFERENCE</code>-type annotations are not displayed on the asset during the labeling process. <code>INFERENCE</code>-type labels are used for IoU (intersection over union) calculation if you want to benchmark your model predictions, or labelers' work quality against ground truth.</p> <p>For more information on Kili label types, refer to our documentation.</p> <p>First, let's prepare some fake predictions:</p> <pre><code>json_response_array = [\n    {\"JOB_0\": {\"categories\": [{\"confidence\": 95, \"name\": \"OBJECT_B\"}]}},\n    {\"JOB_0\": {\"categories\": [{\"confidence\": 79, \"name\": \"OBJECT_A\"}]}},\n    {\"JOB_0\": {\"categories\": [{\"confidence\": 83, \"name\": \"OBJECT_B\"}]}},\n]\n</code></pre> <p>And let's upload them as <code>PREDICTION</code> labels:</p> <pre><code>kili.append_labels(\n    json_response_array=json_response_array,\n    model_name=\"MyModel\",\n    label_type=\"PREDICTION\",\n    project_id=project_id,\n    asset_external_id_array=asset_external_id_array,\n)\n</code></pre> <p>In the project interface, you should now see your assets annotated by your model <code>MyModel</code>:</p> <p></p> <p>As well as the classes predicted by the model (class <code>OBJECT_B</code> for asset <code>image_1</code>):</p> <p></p> <p>You can also add <code>PREDICTION</code>-type labels directly, using the <code>create_predictions</code> method. The <code>label_type</code> will be assigned automatically as <code>PREDICTION</code>:</p> <pre><code>kili.create_predictions(\n    project_id=project_id,\n    external_id_array=asset_external_id_array,\n    json_response_array=json_response_array,\n    model_name=\"MyModel\",\n)\n</code></pre> <p>To import <code>INFERENCE</code>-type labels, just change the <code>label_type</code> argument of the <code>append_labels</code> method:</p> <pre><code>kili.append_labels(\n    json_response_array=json_response_array,\n    model_name=\"MyModel\",\n    label_type=\"INFERENCE\",\n    project_id=project_id,\n    asset_external_id_array=asset_external_id_array,\n)\n</code></pre> <p>This time, the labels are not shown in the labeling interface anymore, since those labels are used as ground truth to compute some metrics later on:</p> <p></p>"},{"location":"sdk/tutorials/importing_labels/#importing-pre-existing-labels-into-your-project","title":"Importing pre-existing labels into your project","text":"<p>If you want to copy and paste labels from other projects or other assets, add them with the <code>DEFAULT</code> label type. <code>DEFAULT</code> indicates that the label was generated by a human.</p> <p>In the example below, we take an existing annotation from asset <code>image_1</code>, and apply it to asset <code>image_2</code>:</p> <pre><code>asset_image_1 = kili.assets(project_id=project_id, external_id_strictly_in=[\"image_1\"])[0]\n\njson_response = asset_image_1[\"labels\"][-1][\"jsonResponse\"]\n\nkili.append_labels(\n    json_response_array=[json_response],\n    label_type=\"DEFAULT\",\n    project_id=project_id,\n    asset_external_id_array=[\"image_2\"],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_labels/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/importing_labels/#summary","title":"Summary","text":"<p>Done. We've successfully set up a Kili project, imported assets to it, and then imported various types of labels to our project. Well done!</p>"},{"location":"sdk/tutorials/importing_multilayer_geospatial_assets/","title":"Multi-Layer Geospatial Assets","text":""},{"location":"sdk/tutorials/importing_multilayer_geospatial_assets/#importing-multi-layer-geospatial-images-into-a-kili-project","title":"Importing Multi-Layer Geospatial Images into a Kili Project","text":"<p>In this tutorial, we will learn how to import multi-layer geospatial assets to your project.</p> <p>Here are the steps that we will follow:</p> <ol> <li>Setting up an image project.</li> <li>Importing some multi-layer assets to Kili with GEOTIFFs and layers from a public tile server.</li> </ol>"},{"location":"sdk/tutorials/importing_multilayer_geospatial_assets/#setting-up-a-kili-image-project-to-work-with","title":"Setting up a Kili image project to work with","text":""},{"location":"sdk/tutorials/importing_multilayer_geospatial_assets/#installing-and-instantiating-kili","title":"Installing and instantiating Kili","text":"<p>First, let's install and import the required modules.</p> <pre><code>%pip install kili\n</code></pre> <pre><code>from kili.client import Kili\n</code></pre> <p>Now, let's set up variables needed to create an instance of the Kili object.</p> <p>We will need your API key and Kili's API endpoint.</p> <p>If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key.</p> <pre><code>api_key = \"YOUR_API_KEY\"\napi_endpoint = \"https://cloud.kili-technology.com/api/label/v2/graphql\"\nkili = Kili(\n    # api_endpoint=api_endpoint, api_key=api_key, verify=True\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_multilayer_geospatial_assets/#creating-an-image-kili-project","title":"Creating an image Kili project","text":"<p>To create an IMAGE Kili project, you must first set up its ontology.</p> <p>Here, we will only add a classification task:</p> <pre><code>interface = {\n    \"jobs\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"PLANE\": {\n                        \"children\": [],\n                        \"color\": \"#472CED\",\n                        \"name\": \"Plane\",\n                        \"id\": \"category3\",\n                    }\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"BBOX\",\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"required\": 0,\n            \"tools\": [\"rectangle\"],\n            \"isChild\": False,\n            \"isNew\": False,\n        }\n    }\n}\n\nproject = kili.create_project(\n    title=\"[Kili SDK Notebook]: Importing multi-layer Geospatial asset\",\n    description=\"Project Description\",\n    input_type=\"IMAGE\",\n    json_interface=interface,\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_multilayer_geospatial_assets/#importing-your-assets","title":"Importing your assets","text":""},{"location":"sdk/tutorials/importing_multilayer_geospatial_assets/#download-geotiff-file-examples","title":"Download geotiff file examples","text":"<p>Before adding assets you need to download our geotiff examples and add them in a geospatial folder, created in the same folder as where you run your python script. It is mandatory to use local files and not urls for geospatial files.</p> <pre><code>import os\nimport urllib.request\n\nif not os.path.exists(\"geospatial\"):\n    os.makedirs(\"geospatial\")\nurllib.request.urlretrieve(\n    \"https://storage.googleapis.com/label-public-staging/asset-test-sample/geospatial/a.tiff\",\n    \"geospatial/a.tiff\",\n)\nurllib.request.urlretrieve(\n    \"https://storage.googleapis.com/label-public-staging/asset-test-sample/geospatial/b.tiff\",\n    \"geospatial/b.tiff\",\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_multilayer_geospatial_assets/#add-multi-layer-assets-to-your-project","title":"Add Multi-Layer assets to your project","text":"<p>You can now add assets. Here is an example to add 2 geotiffs and a public layer coming from the openstreetmap tile server.</p> <pre><code>project_id = project[\"id\"]\njson_metadata_array = [{\"processingParameters\": {\"epsg\": 3857}}]\nmulti_layer_content_array = [\n    [\n        {\n            \"path\": \"geospatial/a.tiff\",\n            \"name\": \"Layer 1\",\n            \"isBaseLayer\": False,\n        },\n        {\n            \"path\": \"geospatial/b.tiff\",\n            \"name\": \"Layer 2\",\n            \"isBaseLayer\": False,\n        },\n    ],\n]\njson_content_array = [\n    [\n        {\n            \"name\": \"osm\",\n            \"tileLayerUrl\": \"https://b.tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"epsg\": \"EPSG3857\",\n            \"bounds\": [\n                [11.17010498046875, 44.308941579503745],\n                [13.67478942871094, 46.542667432984864],\n            ],\n            \"useClassicCoordinates\": False,\n            \"minZoom\": 10,\n            \"maxZoom\": 18,\n            \"isBaseLayer\": True,\n        }\n    ]\n]\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    multi_layer_content_array=multi_layer_content_array,\n    json_metadata_array=json_metadata_array,\n    json_content_array=json_content_array,\n)\n</code></pre> <p>In this example 4 arguments are used for the <code>append_many_to_dataset</code> function :</p> <ol> <li><code>project_id</code>: the id of the project to which you want to add the asset</li> <li><code>multi_layer_content_array</code>: it is a list of dictionnaries representing the layers created from geospatial files like GEOTIFFS. For each GEOTIFF you have to set the <code>path</code> to the GEOTIFF, the <code>name</code> that will be used in kili for the layer and the boolean <code>isBaseLayer</code> to define if it's a base layer (only one visible at a time) or an overlay layer (a layer that will be displayed on top of the base layer). This last one is optional and by default if no parameter is set, we consider it is a base layer.</li> <li><code>json_metadata_array</code>: This one contains the processing parameters that will be used when processing the files. 3 parameters can be set there :<ol> <li><code>epsg</code>: This one defines the projection (https://en.wikipedia.org/wiki/EPSG_Geodetic_Parameter_Dataset) to which we will reproject the dataset. Our frontend supports only two projections : <code>EPSG:4326</code> and <code>EPSG:3857</code>. If this parameter is not set we will keep the projection of the initial file if it is one of these two, else we will reproject it by default to <code>EPSG:3857</code>. By default, we advise to not set this parameter but if you need to use your GEOTIFFS with some tile server (as with openstreetmap here) you will need to reproject it to the same EPSG as the one used by the tile server as our application supports only one EPSG for the whole asset. For your information most of the well known tile server (openstreetmap, googlemaps, etc) are using <code>EPSG:3857</code>.</li> <li><code>maxZoom</code> and <code>minZoom</code>: these defines limits of zoom for your GEOTIFF files. This is especially useful for files that will be tiled by our server (file size &gt; 30MB). By default we generate all the zooms until the one of the original file but if you want to limit to specific zoom levels you can constrain them with these parameters.</li> </ol> </li> <li><code>json_content_array</code>: It has to be used when you need to add public tile layers to your asset. You can find the same arguments as for GEOTIFF layers <code>name</code>, <code>minZoom</code>, <code>maxZoom</code>, <code>isBaseLayer</code>. You also need to specify the <code>epsg</code> but with the format <code>EPSG{number}</code> (this one correspond to the EPSG used by the tile server, we will not reproject anything). And then, you have to provide the url to the tile server with the parameter <code>tileLayerUrl</code> and the <code>bounds</code>, corresponding to the minimum and maximum latitude and longitude for which you want to request tiles (use the following format <code>[[min_lng, min_lat],[max_lng, max_lat]]</code>). Finally, the <code>useClassicCoordinates: False</code> has always to be provided to explain that geospatial coordinates are used.</li> </ol>"},{"location":"sdk/tutorials/importing_multilayer_geospatial_assets/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created if needed:</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/importing_pascalvoc/","title":"PascalVOC","text":""},{"location":"sdk/tutorials/importing_pascalvoc/#how-to-import-pascalvoc-annotations-into-kili","title":"How to import PascalVOC annotations into Kili","text":"<p>In this tutorial, we will demonstrate how to import PascalVOC annotations into Kili.</p>"},{"location":"sdk/tutorials/importing_pascalvoc/#setup","title":"Setup","text":"<p>Let's start by installing Kili and other packages.</p> <pre><code>%%capture\n%pip install kili xmltodict\n</code></pre> <pre><code>import os\nimport urllib.request\nfrom pathlib import Path\n\nimport xmltodict\n\nfrom kili.client import Kili\n</code></pre>"},{"location":"sdk/tutorials/importing_pascalvoc/#download-pascal-voc-format","title":"Download Pascal VOC format","text":"<p>The images and annotations come from the Oxford's PASCAL Visual Object Classes Challenge.</p> <p>For this tutorial we will use a subset from the validation set from 2012.</p> <pre><code>images_names = [\n    \"2007_000027\",\n    \"2010_001121\",\n    \"2010_001140\",\n    \"2011_004772\",\n    \"2012_003624\",\n    \"2012_004328\",\n]\nannos_folder = \"Annotations\"\nimages_folder = \"JPEGImages\"\nimages_extension = \".jpg\"\n</code></pre> <pre><code>Path(annos_folder).mkdir(parents=True, exist_ok=True)\nPath(images_folder).mkdir(parents=True, exist_ok=True)\n</code></pre> <pre><code>for image_name in images_names:\n    for fld, img_ext in zip([images_folder, annos_folder], [images_extension, \".xml\"]):\n        url = f\"https://raw.githubusercontent.com/kili-technology/kili-python-sdk/main/recipes/datasets/pascalVOC2012/valsubset/{fld}/{image_name}{img_ext}\"\n        urllib.request.urlretrieve(url, f\"{fld}/{image_name}{img_ext}\")\n</code></pre>"},{"location":"sdk/tutorials/importing_pascalvoc/#reading-xml-files","title":"Reading xml files","text":"<pre><code>def xml_to_dict(xml_file: str):\n    with open(xml_file) as file:\n        xml_data = file.read()\n        xml_dict = xmltodict.parse(xml_data)\n    return xml_dict\n</code></pre> <pre><code>images_annotations = []\nfor image_name in images_names:\n    images_annotations.append(xml_to_dict(os.path.join(annos_folder, image_name + \".xml\")))\n</code></pre>"},{"location":"sdk/tutorials/importing_pascalvoc/#create-a-kili-project","title":"Create a Kili project","text":"<p>Initialize the Kili client using your API key.</p> <pre><code>kili = Kili()\n</code></pre> <p>In the dictionary below, we map the category ids to the category names from all annotation files:</p> <pre><code>category_names = set()\nfor image_annos in images_annotations:\n    pascalvoc_annos = image_annos[\"annotation\"][\"object\"]\n    if isinstance(pascalvoc_annos, dict):\n        category_names.add(pascalvoc_annos[\"name\"])\n    else:\n        for anno in image_annos[\"annotation\"][\"object\"]:\n            category_names.add(anno[\"name\"])\ncategory_names = list(category_names)\n</code></pre> <p>The <code>json_interface</code> variable contains the ontology of the project.</p> <pre><code>json_interface = {\"jobs\": {}}\n\ncategories = {\n    cat_name: {\"children\": [], \"name\": cat_name, \"id\": i}\n    for i, cat_name in enumerate(category_names)\n}\n\njson_interface[\"jobs\"][\"OBJECT_DETECTION_JOB\"] = {\n    \"content\": {\"categories\": categories, \"input\": \"radio\"},\n    \"instruction\": \"BBox\",\n    \"mlTask\": \"OBJECT_DETECTION\",\n    \"required\": 0,\n    \"tools\": [\"rectangle\"],\n    \"isChild\": False,\n}\n</code></pre> <p>We can take a look at all the categories found with their respective ids:</p> <pre><code>for category in categories.values():\n    print(category[\"id\"], \":\", category[\"name\"])\n</code></pre> <pre><code>0 : cat\n\n\n\n1 : person\n\n\n\n2 : car\n\n\n\n3 : sofa\n</code></pre> <p>Create a Kili project using the json interface.</p> <pre><code>project = kili.create_project(\n    title=\"[Kili SDK Notebook]: PascalVOC 2012\",\n    input_type=\"IMAGE\",\n    json_interface=json_interface,\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_pascalvoc/#importing-images","title":"Importing images","text":"<p>Now that the project is imported, let's import the images.</p> <pre><code>content_array = []\nexternal_id_array = []\nfor image_id, image_name in enumerate(images_names):\n    content_array.append(os.path.join(images_folder, image_name + images_extension))\n    external_id_array.append(str(image_name))\n</code></pre> <pre><code>kili.append_many_to_dataset(\n    project[\"id\"], content_array=content_array, external_id_array=external_id_array\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_pascalvoc/#importing-annotations-to-kili","title":"Importing annotations to Kili","text":"<p>Below, we import an useful function to convert annotations to Kili label format.</p> <pre><code>from typing import Dict, List\n\nfrom kili.utils.labels.bbox import bbox_points_to_normalized_vertices\n</code></pre> <pre><code>def pascal_bbox_to_kili_normalized_vertices(\n    pascal_bbox: Dict, img_width: int, img_height: int\n) -&gt; List[Dict]:\n    x1, y1, x2, y2 = (\n        pascal_bbox[\"xmin\"],\n        pascal_bbox[\"ymin\"],\n        pascal_bbox[\"xmax\"],\n        pascal_bbox[\"ymax\"],\n    )\n    x1, y1, x2, y2 = int(x1), int(y1), int(x2), int(y2)\n    kili_normalized_vertices = bbox_points_to_normalized_vertices(\n        bottom_left={\"x\": x1, \"y\": y2},\n        bottom_right={\"x\": x2, \"y\": y2},\n        top_right={\"x\": x2, \"y\": y1},\n        top_left={\"x\": x1, \"y\": y1},\n        img_height=img_height,\n        img_width=img_width,\n        origin_location=\"top_left\",\n    )\n    return kili_normalized_vertices\n</code></pre> <p>We then add all annotations into the <code>json_response</code> which is uploaded to Kili.</p> <pre><code>json_response_array = []\nfor image_id, image_name in enumerate(images_names):\n    # Get image size and annotations in pascalvoc format\n    image_annos = images_annotations[image_id][\"annotation\"]\n    img_width, img_height = int(image_annos[\"size\"][\"width\"]), int(image_annos[\"size\"][\"height\"])\n\n    json_resp = {}\n    kili_bbox_annotations = []\n    if isinstance(image_annos[\"object\"], dict):\n        image_annos[\"object\"] = [image_annos[\"object\"]]\n    # Convert all annotations into Kili format and append them to the kili_bbox_annotations list\n    for ann in image_annos[\"object\"]:\n        kili_bbox_ann = {\n            \"children\": {},\n            \"boundingPoly\": [\n                {\n                    \"normalizedVertices\": pascal_bbox_to_kili_normalized_vertices(\n                        ann[\"bndbox\"], img_width=img_width, img_height=img_height\n                    )\n                }\n            ],\n            \"categories\": [{\"name\": ann[\"name\"]}],\n            \"type\": \"rectangle\",\n        }\n        kili_bbox_annotations.append(kili_bbox_ann)\n    # Append the json response\n    json_resp[\"OBJECT_DETECTION_JOB\"] = {\"annotations\": kili_bbox_annotations}\n    json_response_array.append(json_resp)\n</code></pre> <pre><code>kili.append_labels(\n    asset_external_id_array=external_id_array,\n    project_id=project[\"id\"],\n    json_response_array=json_response_array,\n)\n</code></pre> <p>In the Kili labeling interface, we can see the images and the annotations.</p> <p></p>"},{"location":"sdk/tutorials/importing_pascalvoc/#conclusion","title":"Conclusion","text":"<p>In this tutorial, we have seen how to import Pascal VOC annotations into Kili.</p> <p>You can now use Kili to refine and review your annotations, in order to train your machine learning models on high quality data.</p>"},{"location":"sdk/tutorials/importing_pascalvoc/#clean-up","title":"Clean up","text":"<p>Remove the project from your Kili projects.</p> <pre><code>kili.delete_project(project_id=project[\"id\"])\n</code></pre>"},{"location":"sdk/tutorials/importing_pdf_assets/","title":"PDF Assets","text":""},{"location":"sdk/tutorials/importing_pdf_assets/#how-to-import-pdf-assets-to-a-kili-project","title":"How to import PDF assets to a Kili project","text":"<p>In this tutorial, we will learn how to import PDF assets to your project.</p> <p>Here are the steps that we will follow:</p> <ol> <li>Setting up a PDF classification project.</li> <li>Importing some PDF assets to Kili.</li> <li>Adding their resolutions if needed.</li> </ol>"},{"location":"sdk/tutorials/importing_pdf_assets/#setting-up-a-pdf-kili-project-to-work-with","title":"Setting up a PDF Kili project to work with","text":""},{"location":"sdk/tutorials/importing_pdf_assets/#installing-and-instantiating-kili","title":"Installing and instantiating Kili","text":"<p>First, let's install and import the required modules.</p> <pre><code>%pip install kili\n</code></pre> <pre><code>from pprint import pprint\n\nfrom kili.client import Kili\n</code></pre> <p>Now, let's set up variables needed to create an instance of the Kili object.</p> <p>We will need your API key and Kili's API endpoint.</p> <p>If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key.</p> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_pdf_assets/#creating-a-pdf-kili-project","title":"Creating a PDF Kili project","text":"<p>To create a PDF Kili project, you must first set up its ontology.</p> <p>Here, we will only add a classification task:</p> <pre><code>interface = {\n    \"jobs\": {\n        \"CLASSIFICATION_JOB\": {\n            \"mlTask\": \"CLASSIFICATION\",\n            \"content\": {\n                \"categories\": {\n                    \"RESEARCH\": {\"name\": \"Research\", \"children\": [], \"id\": \"category1\"},\n                    \"GUIDELINES\": {\"name\": \"Guidelines\", \"children\": [], \"id\": \"category2\"},\n                    \"TREND_ANALYSIS\": {\"children\": [], \"name\": \"Trend analysis\", \"id\": \"category3\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Classify the document\",\n            \"required\": 1,\n            \"isChild\": False,\n            \"isNew\": False,\n        },\n    }\n}\n\nproject = kili.create_project(\n    title=\"[Kili SDK Notebook]: Importing assets with metadata - PDF\",\n    description=\"Project Description\",\n    input_type=\"PDF\",\n    json_interface=interface,\n)\n</code></pre> <p>You can now add assets. Here, we will add PDF from public URLs:</p> <pre><code>project_id = project[\"id\"]\nexternal_ids = [\"2306.17766\", \"2306.17582\", \"2306.17514\"]\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[\n        \"https://arxiv.org/pdf/2306.17766\",\n        \"https://arxiv.org/pdf/2306.17582\",\n        \"https://arxiv.org/pdf/2306.17514\",\n    ],\n    external_id_array=external_ids,\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_pdf_assets/#fetching-the-asset-resolutions","title":"Fetching the asset resolutions","text":"<p>You can fetch the PDF asset resolutions this way:</p> <pre><code>assets = kili.assets(\n    project_id,\n    fields=[\"id\", \"pageResolutions.height\", \"pageResolutions.width\", \"pageResolutions.pageNumber\"],\n)\n</code></pre> <pre><code>pprint(assets)\n</code></pre> <pre><code>[{'id': 'cljohld0v0000lfvz0ktpb290',\n  'pageResolutions': [{'height': 700, 'pageNumber': 1, 'width': 500},\n                      {'height': 700, 'pageNumber': 2, 'width': 500},\n                      {'height': 700, 'pageNumber': 3, 'width': 500},\n                      {'height': 700, 'pageNumber': 4, 'width': 500}]},\n {'id': 'cljohld0v0001lfvzok0h4mlu',\n  'pageResolutions': [{'height': 700, 'pageNumber': 1, 'width': 500},\n                      {'height': 700, 'pageNumber': 2, 'width': 500},\n                      {'height': 700, 'pageNumber': 3, 'width': 500},\n                      {'height': 700, 'pageNumber': 4, 'width': 500}]},\n {'id': 'cljohld0v0002lfvz3vid56ha',\n  'pageResolutions': [{'height': 700, 'pageNumber': 1, 'width': 500},\n                      {'height': 700, 'pageNumber': 2, 'width': 500},\n                      {'height': 700, 'pageNumber': 3, 'width': 500},\n                      {'height': 700, 'pageNumber': 4, 'width': 500}]}]\n</code></pre>"},{"location":"sdk/tutorials/importing_pdf_assets/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created if needed:</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/","title":"Video Assets","text":""},{"location":"sdk/tutorials/importing_video_assets/#how-to-import-video-assets-to-a-kili-project","title":"How to import video assets to a Kili project","text":"<p>In this tutorial, we will learn how to import video assets to Kili.</p> <p>Here are the steps that we will follow:</p> <ol> <li>Setting up a simple Kili project to work with</li> <li>Importing video assets to Kili</li> <li>Uploading a video asset using a path to a local file</li> <li>Uploading a video asset using an URL</li> <li>Uploading a video asset to label each frame separately</li> <li>Uploading a list of local images as one video asset</li> <li>Uploading a list of image URLs as one video asset</li> <li>Uploading a video asset with a custom sampling rate</li> <li>Updating video metadata</li> <li>Cleanup</li> </ol>"},{"location":"sdk/tutorials/importing_video_assets/#setting-up-a-simple-kili-project-to-work-with","title":"Setting up a simple Kili project to work with","text":""},{"location":"sdk/tutorials/importing_video_assets/#installing-and-instantiating-kili","title":"Installing and instantiating Kili","text":"<p>First, let's install and import the required modules.</p> <pre><code>%pip install  kili\n</code></pre> <pre><code>from kili.client import Kili\n</code></pre> <p>Now, let's set up variables needed to create an instance of the Kili object.</p> <p>We will need your API key and Kili's API endpoint.</p> <p>If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key.</p> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#creating-a-basic-kili-project","title":"Creating a basic Kili project","text":"<p>To create a Kili project, you must first set up its interface.</p> <p>We will create a video project with just one simple classification job and two categories: <code>OBJECT_A</code> and <code>OBJECT_B</code>.</p> <p>To learn more about Kili project interfaces, refer to https://docs.kili-technology.com/docs/customizing-project-interface.</p> <pre><code>interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"content\": {\n                \"categories\": {\n                    \"OBJECT_A\": {\"children\": [], \"name\": \"Object A\", \"id\": \"category3\"},\n                    \"OBJECT_B\": {\"children\": [], \"name\": \"Object B\", \"id\": \"category4\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Categories\",\n            \"isChild\": False,\n            \"mlTask\": \"CLASSIFICATION\",\n            \"models\": {},\n            \"isVisible\": True,\n            \"required\": 1,\n            \"isNew\": False,\n        }\n    }\n}\n\nresult = kili.create_project(\n    title=\"[Kili SDK Notebook]: Importing Video Assets\",\n    description=\"Project Description\",\n    input_type=\"VIDEO\",\n    json_interface=interface,\n)\n</code></pre> <p>For further processing, we will need to find out what our project ID is.</p> <p>We can easily retrieve it from the project creation response message:</p> <pre><code>project_id = result[\"id\"]\nprint(\"Project ID: \", project_id)\n</code></pre> <pre><code>Project ID:  cld90h71d0ha50jptd28xfjg1\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#importing-video-assets-to-kili","title":"Importing video assets to Kili","text":"<p>Now, let's add some video assets to be labeled. You can videos using URLs or use your local assets.</p> <p>We will use a free off-the-shelf asset from the Internet.</p>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-video-asset-using-a-path-to-a-local-file","title":"Uploading a video asset using a path to a local file","text":"<p>To show an example of how to upload a local video, we must first download it:</p> <pre><code>import urllib.request\n\nurllib.request.urlretrieve(\n    \"https://storage.googleapis.com/label-public-staging/asset-test-sample/video/short_video.mp4\",\n    \"test.mp4\",\n)\n</code></pre> <p>Now, we can easily upload the video to our project:</p> <pre><code>assets = kili.append_many_to_dataset(\n    project_id=project_id, content_array=[\"./test.mp4\"], external_id_array=[\"video_1_from_local\"]\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-video-asset-using-an-url","title":"Uploading a video asset using an URL","text":"<p>You can of course upload videos using URLs as well. To do so, simply replace <code>'./test.mp4'</code> with the URL of the video that you want to upload.</p> <pre><code>url = \"https://storage.googleapis.com/label-public-staging/asset-test-sample/video/short_video.mp4\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id, content_array=[url], external_id_array=[\"video_2_from_url\"]\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-video-asset-to-label-each-frame-separately","title":"Uploading a video asset to label each frame separately","text":"<p>To upload your video and be able to label frames separately, as individual images, refer to this code:</p> <pre><code>url = \"https://storage.googleapis.com/label-public-staging/asset-test-sample/video/short_video.mp4\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[url],\n    external_id_array=[\"video_2_from_url_split_frames\"],\n    json_metadata_array=[{\"processingParameters\": {\"shouldUseNativeVideo\": False}}],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-list-of-local-images-as-one-video-asset","title":"Uploading a list of local images as one video asset","text":"<p>We can create a video, by using local images as frames. Let's first download some images from the Internet:</p> <pre><code>urllib.request.urlretrieve(\n    \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000001.jpg\",\n    \"image_1.jpg\",\n)\nurllib.request.urlretrieve(\n    \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000002.jpg\",\n    \"image_2.jpg\",\n)\nurllib.request.urlretrieve(\n    \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000003.jpg\",\n    \"image_3.jpg\",\n)\n</code></pre> <p>Now, let's put them together as one video:</p> <pre><code>assets = kili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[[\"./image_1.jpg\", \"./image_2.jpg\", \"./image_3.jpg\"]],\n    external_id_array=[\"video_3_from_local_images\"],\n    json_metadata_array=[{\"processingParameters\": {\"shouldUseNativeVideo\": False}}],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-list-of-image-urls-as-one-video-asset","title":"Uploading a list of image URLs as one video asset","text":"<p>You can of course upload videos using URLs as well. To do so, simply replace <code>'./test.mp4'</code> with a set of URLs of images that you want to upload as a video.</p> <pre><code>url1 = \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000001.jpg\"\nurl2 = \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000002.jpg\"\nurl3 = \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000003.jpg\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[[url1, url2, url3]],\n    external_id_array=[\"video_4_from_image_urls\"],\n    json_metadata_array=[{\"processingParameters\": {\"shouldUseNativeVideo\": False}}],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-video-asset-with-a-custom-sampling-rate","title":"Uploading a video asset with a custom sampling rate","text":"<p>To upload a video with a custom sampling rate (let's say, 10 frames per second), use this code:</p> <pre><code>assets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[\"./test.mp4\"],\n    external_id_array=[\"video_5_custom\"],\n    json_metadata_array=[{\"processingParameters\": {\"framesPlayedPerSecond\": 10}}],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#updating-video-metadata","title":"Updating video metadata","text":"<p>When importing a video, if you want to add or delete metadata, you must provide the entire list of metadata. This new list will replace the previous one, meaning any metadata not included in the new list will be erased. However, this does not apply to the <code>processingParameters</code> metadata, which will be retained even if they are not present in the new list.</p> <p>If you need to update <code>processingParameters</code> keep in mind that you should only do it with caution as it can have an impact on how the video will be managed by the application.</p> <p>To update a <code>processingParameters</code>, use this code:</p> <pre><code>assets = kili.update_properties_in_assets(\n    project_id=project_id,\n    external_ids=[\"video_5_custom\"],\n    json_metadatas=[{\"processingParameters\": {\"framesPlayedPerSecond\": 10}}],\n)\n</code></pre> <p>If you have set custom metadatas to your asset, see here how, and you want to update one property you will have to first get all the json_metadatas and then update the wanted metadata :</p> <pre><code>updated_json_metadatas = kili.assets(\n    project_id=project_id, external_id_in=[\"video_5_custom\"], fields=[\"jsonMetadata\"]\n)\nupdated_json_metadatas[0][\"jsonMetadata\"][\"customMetadata\"] = 20\n\nassets = kili.update_properties_in_assets(\n    project_id=project_id,\n    external_ids=[\"video_5_custom\"],\n    json_metadatas=[updated_json_metadatas[0][\"jsonMetadata\"]],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#summary","title":"Summary","text":"<p>Done. We've successfully set up a video project, defined its interface, and uploaded a bunch of assets to it, using various Kili's upload methods. Well done!</p>"},{"location":"sdk/tutorials/inference_labels/","title":"Inference Labels","text":""},{"location":"sdk/tutorials/inference_labels/#how-to-import-inference-labels","title":"How to import inference labels","text":"<p>In this tutorial, we will walk through the process of using Kili to evaluate the performance of a machine learning model in production.</p> <p>We will learn how to push model-generated labels to Kili and how to visualize their quality.</p> <pre><code>%pip install kili\n</code></pre> <pre><code>from kili.client import Kili\n</code></pre> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/inference_labels/#context","title":"Context","text":""},{"location":"sdk/tutorials/inference_labels/#agreement","title":"Agreement","text":"<p>Let's say you have a trained machine learning model \\(m\\), which can, given data \\(x\\), output a prediction (i.e., an inference label): \\(\\hat{y} = m(x)\\).</p> <p>What you will probably want to do is monitor the quality of such predictions, as the model evolves. Kili allows you to better monitor and iterate on your model, thanks to the concept of agreement. An agreement is a quantitative measure of similarity between two different labels. In Kili, there are three main features derived from agreement:</p> <ul> <li>Consensus, which is the agreement between two labelers.</li> <li>Honeypot, which is the agreement between a \"super human annotator\" and a labeler.</li> <li>Inference, which is the agreement between a model-generated label and a human.</li> </ul> <p>Those numbers can be monitored from the queue page or the analytics page. You can find how the agreement is computed here.</p> <p>In this tutorial, we will put an emphasis on Inference.</p>"},{"location":"sdk/tutorials/inference_labels/#use-cases","title":"Use cases","text":"<p>We identify two main use cases for the use of inference labels.</p> <p>The first use case is when you have a model in production. When it receives assets, it automatically feeds a Kili project with both the asset and the predicted label. You also have human workforce whose job is to monitor the quality of the model. They manually label a portion of the data after it had been pre-labeled by the model. When a human submits a label, the inference score (model vs. human) for that label is automatically computed. Low inference scores can indicate either a model performing badly on some kind of data, or a disagreement between humans and the model. This can help you to:</p> <ul> <li>Detect data drift.</li> <li>Identify data on which the model needs improvement.</li> </ul> <p>The second use case is when you used Kili to label data and you have the first iteration of your model. You can now use a part of the labeled dataset as testing data, and quickly get test scores. Of course, you could use your own metrics (rather than our own definition of agreement), but using Kili lets you quickly filter and indentify the assets where your model differs the most from the ground truth.</p> <ul> <li>When you push an inference-type label to an asset, the inference score is automatically computed for the most recent label added to this asset.</li> <li>You can filter on low inference score, to understand why your model is failing, and how to fix it (getting more data, splitting or merging categories, etc.).</li> </ul> <p>With Kili, you can quickly iterate on the data used to train your model, to get a better model faster.</p>"},{"location":"sdk/tutorials/inference_labels/#in-practice","title":"In practice","text":""},{"location":"sdk/tutorials/inference_labels/#use-case-1","title":"Use case 1","text":"<p>We start by creating a project and defining a model which, given an asset input \\(x\\), returns a category (random in our example):</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"CLASSIFICATION_JOB\": {\n            \"mlTask\": \"CLASSIFICATION\",\n            \"content\": {\n                \"categories\": {\n                    \"RED\": {\"name\": \"Red\"},\n                    \"BLACK\": {\"name\": \"Black\"},\n                    \"WHITE\": {\"name\": \"White\"},\n                    \"GREY\": {\"name\": \"Grey\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"required\": 0,\n            \"isChild\": False,\n            \"instruction\": \"Color\",\n        }\n    }\n}\n\nproject_id = kili.create_project(\n    title=\"[Kili SDK Notebook]: Project demo inference\",\n    input_type=\"IMAGE\",\n    json_interface=json_interface,\n)[\"id\"]\n</code></pre> <p>Then we can simulate that our model is in production. Each time it receives an asset, we upload it to Kili along with the predicted label.</p> <pre><code>stream_of_assets = [\n    {\n        \"url\": (\n            \"https://storage.googleapis.com/label-public-staging/recipes/inference/black_car.jpg\"\n        ),\n        \"external_id\": \"black_car.jpg\",\n    },\n    {\n        \"url\": \"https://storage.googleapis.com/label-public-staging/recipes/inference/grey_car.jpg\",\n        \"external_id\": \"grey_car.jpg\",\n    },\n    {\n        \"url\": (\n            \"https://storage.googleapis.com/label-public-staging/recipes/inference/white_car.jpg\"\n        ),\n        \"external_id\": \"white_car.jpg\",\n    },\n    {\n        \"url\": \"https://storage.googleapis.com/label-public-staging/recipes/inference/red_car.jpg\",\n        \"external_id\": \"red_car.jpg\",\n    },\n]\n</code></pre> <p>We import the assets into the Kili project:</p> <pre><code>kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[asset[\"url\"] for asset in stream_of_assets],\n    external_id_array=[asset[\"external_id\"] for asset in stream_of_assets],\n)\n</code></pre> <p>We simulate some model predictions:</p> <pre><code>predictions = {\n    \"black_car.jpg\": \"WHITE\",\n    \"grey_car.jpg\": \"GREY\",\n    \"white_car.jpg\": \"RED\",\n    \"red_car.jpg\": \"BLACK\",\n}\n</code></pre> <p>And we upload those predictions to Kili:</p> <pre><code>predicted_categories = [predictions[asset[\"external_id\"]] for asset in stream_of_assets]\ninference_labels = [\n    {\"CLASSIFICATION_JOB\": {\"categories\": [{\"name\": predicted_category}]}}\n    for predicted_category in predicted_categories\n]\n\nkili.append_labels(\n    project_id=project_id,\n    asset_external_id_array=[asset[\"external_id\"] for asset in stream_of_assets],\n    json_response_array=inference_labels,\n    label_type=\"INFERENCE\",  # We import model-generated labels as \"INFERENCE\" labels\n    model_name=\"my_model\",\n)\n</code></pre> <p>Then, human labelers can annotate a subsample of the assets pushed to Kili.</p> <p>Note: you can automatically prioritize assets to be reviewed by a human by using the model's certainty score. When the model is unsure of its predictions, this may indicate wrong labels.</p> <pre><code>ground_truths = {\n    \"black_car.jpg\": \"BLACK\",\n    \"grey_car.jpg\": \"GREY\",\n    \"white_car.jpg\": \"WHITE\",\n    \"red_car.jpg\": \"RED\",\n}\n\nhuman_labels = [\n    {\"CLASSIFICATION_JOB\": {\"categories\": [{\"name\": ground_truths[asset[\"external_id\"]]}]}}\n    for asset in stream_of_assets\n]\nkili.append_labels(\n    project_id=project_id,\n    json_response_array=human_labels,\n    asset_external_id_array=[asset[\"external_id\"] for asset in stream_of_assets],\n    label_type=\"DEFAULT\",\n)\n</code></pre> <p>Note: that the inference metric could appear as None at the beginning (as those calculs can be complex we choose to do it in a separate way and so the return could be delayed). Just wait a bit before trigger the fetch of the labels.</p> <p>You can now fetch the agreement between the human and the model, for human labels:</p> <pre><code>labels = kili.labels(\n    project_id=project_id, fields=[\"inferenceMark\", \"id\", \"labelOf.id\"], type_in=[\"DEFAULT\"]\n)\nprint(labels)\n</code></pre> <pre><code>[{'labelOf': {'id': 'cleoicx8s0000h8vzn0qu3mpz'}, 'inferenceMark': 0.5, 'id': 'cleoicz3b02eg0jx8cub2c6q6'}, {'labelOf': {'id': 'cleoicx8s0001h8vzh742in5x'}, 'inferenceMark': 1, 'id': 'cleoicz3b02eh0jx8fe1iap2a'}, {'labelOf': {'id': 'cleoicx8s0002h8vz0jhz2co8'}, 'inferenceMark': 0.5, 'id': 'cleoicz3b02ei0jx8bi4ifnkw'}, {'labelOf': {'id': 'cleoicx8s0003h8vzbiaawl1j'}, 'inferenceMark': 0.5, 'id': 'cleoicz3b02ej0jx86n5c2m0a'}]\n</code></pre> <p>This allows you to identify problems:</p> <pre><code>for label in labels:\n    # this label has disagreement between human and model\n    if label[\"inferenceMark\"] &lt; 1:\n        asset_id = label[\"labelOf\"][\"id\"]\n        # get the model-generated label\n        inference_label = kili.labels(\n            project_id=project_id,\n            asset_id=asset_id,\n            type_in=[\"INFERENCE\"],\n            output_format=\"parsed_label\",\n            disable_tqdm=True,\n        )[0]\n        # get the human-made label\n        human_label = kili.labels(\n            project_id=project_id,\n            label_id=label[\"id\"],\n            output_format=\"parsed_label\",\n            disable_tqdm=True,\n        )[0]\n\n        inference_category = inference_label.jobs[\"CLASSIFICATION_JOB\"].category.name\n        human_category = human_label.jobs[\"CLASSIFICATION_JOB\"].category.name\n        print(\n            f\"The model predicted {inference_category} but the human predicted {human_category} for\"\n            f\" asset with id {asset_id}.\"\n        )\n</code></pre> <pre><code>The model predicted WHITE but the human predicted BLACK for asset with id cleoicx8s0000h8vzn0qu3mpz.\nThe model predicted RED but the human predicted WHITE for asset with id cleoicx8s0002h8vz0jhz2co8.\nThe model predicted BLACK but the human predicted RED for asset with id cleoicx8s0003h8vzbiaawl1j.\n</code></pre> <p>You can also find the assets with most disagreement directly from the interface with the \"Human/Model IoU\" filter.</p> <p>Low IoU indicates low agreement:</p> <p></p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/inference_labels/#use-case-2","title":"Use case 2","text":"<p>We can invert the previous use case.</p> <p>We start with a human-labeled dataset and we insert model predictions to it, to simulate testing our model on test data.</p> <pre><code>project_id = kili.create_project(\n    title=\"[Kili SDK Notebook]: Project demo inference 2\",\n    input_type=\"IMAGE\",\n    json_interface=json_interface,\n)[\"id\"]\n</code></pre> <pre><code>labeled_assets = [\n    {\n        \"url\": (\n            \"https://storage.googleapis.com/label-public-staging/recipes/inference/black_car.jpg\"\n        ),\n        \"external_id\": \"black_car.jpg\",\n    },\n    {\n        \"url\": \"https://storage.googleapis.com/label-public-staging/recipes/inference/grey_car.jpg\",\n        \"external_id\": \"grey_car.jpg\",\n    },\n    {\n        \"url\": (\n            \"https://storage.googleapis.com/label-public-staging/recipes/inference/white_car.jpg\"\n        ),\n        \"external_id\": \"white_car.jpg\",\n    },\n    {\n        \"url\": \"https://storage.googleapis.com/label-public-staging/recipes/inference/red_car.jpg\",\n        \"external_id\": \"red_car.jpg\",\n    },\n]\n</code></pre> <pre><code>kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[asset[\"url\"] for asset in labeled_assets],\n    external_id_array=[asset[\"external_id\"] for asset in labeled_assets],\n)\n</code></pre> <p><code>ground_truths</code> represents labels made by human annotators:</p> <pre><code>ground_truths = {\n    \"black_car.jpg\": \"BLACK\",\n    \"grey_car.jpg\": \"GREY\",\n    \"white_car.jpg\": \"WHITE\",\n    \"red_car.jpg\": \"RED\",\n}\n</code></pre> <p>Now, we import the human labels:</p> <pre><code>human_labels = [\n    {\"CLASSIFICATION_JOB\": {\"categories\": [{\"name\": ground_truths[asset[\"external_id\"]]}]}}\n    for asset in labeled_assets\n]\n\nkili.append_labels(\n    project_id=project_id,\n    json_response_array=human_labels,\n    asset_external_id_array=[asset[\"external_id\"] for asset in labeled_assets],\n    label_type=\"DEFAULT\",\n)\n</code></pre> <p>We take 80% of the training data and use it to train a model.</p> <p>We can then run the trained model against the remaining 20% of the labeled assets, and upload predictions to Kili:</p> <pre><code>test_labels = [\n    {\"CLASSIFICATION_JOB\": {\"categories\": [{\"name\": predictions[asset[\"external_id\"]]}]}}\n    for asset in labeled_assets\n]\nkili.append_labels(\n    project_id=project_id,\n    json_response_array=test_labels,\n    asset_external_id_array=[asset[\"external_id\"] for asset in labeled_assets],\n    label_type=\"INFERENCE\",\n    model_name=\"my_model\",\n)\n</code></pre> <pre><code>labels = kili.labels(\n    project_id=project_id, fields=[\"inferenceMark\", \"id\", \"labelOf.id\"], type_in=[\"DEFAULT\"]\n)\nprint(labels)\n</code></pre> <pre><code>[{'labelOf': {'id': 'cleoid2lk0004h8vzyqb6bfp5'}, 'inferenceMark': 0.5, 'id': 'cleoid3m802fg0jx831mhak3l'}, {'labelOf': {'id': 'cleoid2lk0005h8vzmodn4ce8'}, 'inferenceMark': 1, 'id': 'cleoid3m802fh0jx893nia1og'}, {'labelOf': {'id': 'cleoid2lk0006h8vza2xtc6h5'}, 'inferenceMark': 0.5, 'id': 'cleoid3m802fi0jx861b52nd5'}, {'labelOf': {'id': 'cleoid2lk0007h8vzkp2yodiu'}, 'inferenceMark': 0.5, 'id': 'cleoid3m802fj0jx8g5xj0lt2'}]\n</code></pre> <p>We can now print out a list of disagreements between human and machine labels:</p> <pre><code>for label in labels:\n    if label[\"inferenceMark\"] &lt; 1:\n        inference_label = list(\n            kili.labels(\n                project_id=project_id,\n                asset_id=label[\"labelOf\"][\"id\"],\n                type_in=[\"INFERENCE\"],\n                output_format=\"parsed_label\",\n                disable_tqdm=True,\n            )\n        )[0]\n        human_label = list(\n            kili.labels(\n                project_id=project_id,\n                label_id=label[\"id\"],\n                output_format=\"parsed_label\",\n                disable_tqdm=True,\n            )\n        )[0]\n\n        inference_category = inference_label.jobs[\"CLASSIFICATION_JOB\"].category.name\n        human_category = human_label.jobs[\"CLASSIFICATION_JOB\"].category.name\n\n        print(\n            f\"The human predicted {human_category} but the model predicted {inference_category} for\"\n            f\" asset with id {asset_id}.\"\n        )\n</code></pre> <pre><code>The human predicted BLACK but the model predicted WHITE for asset with id cleoicx8s0003h8vzbiaawl1j.\nThe human predicted WHITE but the model predicted RED for asset with id cleoicx8s0003h8vzbiaawl1j.\nThe human predicted RED but the model predicted BLACK for asset with id cleoicx8s0003h8vzbiaawl1j.\n</code></pre> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/inference_labels/#conclusion","title":"Conclusion","text":"<p>Congratulations! You can now upload your own inference labels to your Kili project \ud83d\ude80.</p>"},{"location":"sdk/tutorials/label_parsing/","title":"Parsing Labels","text":""},{"location":"sdk/tutorials/label_parsing/#how-to-use-the-label-parser","title":"How to use the label parser","text":"<p>This tutorial shows how to use the label parser to easily access labels' content.</p>"},{"location":"sdk/tutorials/label_parsing/#setup","title":"Setup","text":"<pre><code>%pip install kili\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#kili-labels","title":"Kili labels","text":"<p>In Kili SDK, a label is a dictionary that follows a json structure as described in the documentation:</p> <pre><code>my_label = kili.labels(project_id=\"my_project_id\", output_format='dict')[0]\n\nprint(my_label)\n</code></pre> <pre><code>{\n  \"id\": \"abc123\",\n  \"author\": {\"email\": \"john.doe@kili-techonology.com\", \"id\": \"123456\"},\n  \"createdAt\": \"2020-02-20T14:00:00.000Z\",\n  \"labelType\": \"DEFAULT\",\n  \"secondsToLabel\": 10,\n  \"jsonResponse\": {},\n  ...  // many other possible fields!\n}\n</code></pre> <p>The <code>jsonResponse</code> field is the one that contains the actual label data, that is the data that the annotator has entered in the interface (the bounding boxes, polygons, text, etc.).</p> <p>Is it however quite difficult to extract the label data from the <code>jsonResponse</code> field, as it is a nested dictionary. This is why we have developed a label parser that allows you to extract the label data in a more convenient way.</p>"},{"location":"sdk/tutorials/label_parsing/#parsed-label-integration-to-kililabels","title":"Parsed Label integration to kili.labels()","text":"<p>The <code>kili.labels()</code> method has an <code>output_format</code> argument that enables automatic label parsing:</p> <pre><code>my_label = kili.labels(project_id=\"my_project_id\", output_format='parsed_label')[0]\n\n# example of how to access the category name of the first label\n# (only for a classification job)\nmy_label.jobs[\"MY_JOB_NAME\"].category.name\n# or\nmy_label.jobs[\"MY_JOB_NAME\"].category.display_name\n</code></pre> <p>Instead of:</p> <pre><code>my_label = kili.labels(project_id=\"my_project_id\", output_format='dict')[0]\n\nmy_label[\"jsonResponse\"][\"jobs\"][\"MY_JOB_NAME\"][\"categories\"][0][\"name\"]\n</code></pre> <p>As you can see, the parsed label is much easier to use than the raw dict label, and helps you develop your own scripts faster using your IDE auto-completion, type checking, etc.</p>"},{"location":"sdk/tutorials/label_parsing/#parsed-label-integration-to-kiliassets","title":"Parsed Label integration to kili.assets()","text":"<p>The <code>kili.assets()</code> method has a <code>label_output_format</code> argument that enables automatic label parsing:</p> <pre><code>my_asset = kili.assets(project_id=\"my_project_id\", label_output_format='parsed_label')[0]\n\n# example of how to access the category name of the first label\n# (only for a classification job)\nmy_asset[\"labels\"][0].jobs[\"MY_JOB_NAME\"].category.name\n# or\nmy_asset[\"labels\"][0].jobs[\"MY_JOB_NAME\"].category.display_name\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#parsedlabel-class","title":"ParsedLabel class","text":"<p>The <code>ParsedLabel</code> class represents a Kili label with a parsed json response.</p> <p>As we have seen earlier, the <code>kili.labels(..., output_format='parsed_label')</code> will automatically return a list of <code>ParsedLabel</code> objects, but you can also create a <code>ParsedLabel</code> object from a raw dict label.</p> <pre><code>from kili.utils.labels.parsing import ParsedLabel\n</code></pre> <p>This class directly inherits from <code>dict</code>, and thus behaves like a dictionary.</p> <pre><code>print(ParsedLabel.__bases__[0])\n</code></pre> <pre><code>&lt;class 'dict'&gt;\n</code></pre> <p>Converting a label to a <code>ParsedLabel</code> is as simple as:</p> <pre><code>my_label = {\n    \"author\": {\"email\": \"first.last@kili-technology.com\", \"id\": \"123456\"},\n    \"id\": \"clh0fsi9u0tli0j666l4sfhpz\",\n    \"jsonResponse\": {\n        \"CLASSIFICATION_JOB\": {\"categories\": [{\"confidence\": 100, \"name\": \"CATEGORY_A\"}]}\n    },\n    \"labelType\": \"DEFAULT\",\n    \"secondsToLabel\": 5,\n}\n\nmy_parsed_label = ParsedLabel(my_label, json_interface=json_interface, input_type=\"IMAGE\")\n</code></pre> <pre><code>print(my_parsed_label[\"author\"][\"email\"])\n</code></pre> <pre><code>first.last@kili-technology.com\n</code></pre> <p>In a parsed label, the <code>jsonResponse</code> dict key is not accessible anymore, since it is parsed and transformed into a <code>.jobs</code> object:</p> <pre><code>try:\n    my_parsed_label[\"jsonResponse\"]\nexcept KeyError as err:\n    print(f\"The key {err} is not accessible anymore.\")\n</code></pre> <pre><code>The key 'jsonResponse' is not accessible anymore.\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#jobs-attribute","title":".jobs attribute","text":"<p>The <code>.jobs</code> attribute of a <code>ParsedLabel</code> class is a dictionary-like object that contains the json response data of a parsed label.</p> <p>The keys are the names of the jobs, and the values are the parsed job responses.</p> <p>Let's illustrate this with the previous label.</p> <pre><code>print(list(my_parsed_label.jobs.keys()))\n</code></pre> <pre><code>['CLASSIFICATION_JOB']\n</code></pre> <p>The values are <code>ParsedJob</code> objects, which are also dictionary-like objects that contain the job response data.</p> <p>The available data attributes are specific to the job interface described in the ontology (also called the json interface).</p> <pre><code>print(my_parsed_label.jobs[\"CLASSIFICATION_JOB\"])\n</code></pre> <pre><code>{'categories': [{'name': 'CATEGORY_A', 'confidence': 100}]}\n</code></pre> <p>For example, for a classification job, the available data attributes are <code>.categories</code> or <code>.category</code>, and a category object can have <code>.name</code>, <code>.display_name</code> and <code>.confidence</code> attributes.</p> <pre><code>print(my_parsed_label.jobs[\"CLASSIFICATION_JOB\"].categories[0].name)\nprint(my_parsed_label.jobs[\"CLASSIFICATION_JOB\"].categories[0].display_name)\nprint(my_parsed_label.jobs[\"CLASSIFICATION_JOB\"].categories[0].confidence)\n</code></pre> <pre><code>CATEGORY_A\nA\n100\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#autocomplete","title":"Autocomplete","text":"<p>The <code>ParsedLabel</code> class enables your IDE to explore the possible attributes during development:</p> <p></p> <p>Note that some attributes will not be avaible at runtime, since they are specific to the project ontology (jsonInterface) that will only be known at runtime.</p>"},{"location":"sdk/tutorials/label_parsing/#get-the-json-response-from-a-parsed-label","title":"Get the json response from a parsed label","text":"<p>If you need to get the json response from a parsed label, you can use the <code>.json_response</code> attribute:</p> <pre><code>print(type(my_parsed_label.json_response))\n</code></pre> <pre><code>&lt;class 'dict'&gt;\n</code></pre> <pre><code>print(my_parsed_label.json_response)\n</code></pre> <pre><code>{'CLASSIFICATION_JOB': {'categories': [{'name': 'CATEGORY_A', 'confidence': 100}]}}\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#convert-parsedlabel-to-python-dict","title":"Convert ParsedLabel to Python dict","text":"<p>A <code>ParsedLabel</code> is a custom class and is not serializable by default. However, it is possible to convert it to a Python dict using the <code>to_dict</code> method:</p> <pre><code>print(type(my_parsed_label))\n</code></pre> <pre><code>&lt;class 'kili.utils.labels.parsing.ParsedLabel'&gt;\n</code></pre> <pre><code>label_as_dict = my_parsed_label.to_dict()\n</code></pre> <pre><code>print(type(label_as_dict))\n</code></pre> <pre><code>&lt;class 'dict'&gt;\n</code></pre> <pre><code>print(label_as_dict)\n</code></pre> <pre><code>{'author': {'email': 'first.last@kili-technology.com', 'id': '123456'}, 'id': 'clh0fsi9u0tli0j666l4sfhpz', 'labelType': 'DEFAULT', 'secondsToLabel': 5, 'jsonResponse': {'CLASSIFICATION_JOB': {'categories': [{'name': 'CATEGORY_A', 'confidence': 100}]}}}\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#task-specific-attributes","title":"Task specific attributes","text":""},{"location":"sdk/tutorials/label_parsing/#classification-jobs","title":"Classification jobs","text":"<p>We define a json interface for two classification jobs:</p> <ul> <li>a single-class classification job, with name <code>SINGLE_CLASS_JOB</code> and three categories <code>A</code>, <code>B</code> and <code>C</code></li> <li>a multi-class classification job, with name <code>MULTI_CLASS_JOB</code> and three categories <code>D</code>, <code>E</code> and <code>F</code>.</li> </ul> <pre><code>json_interface = {\n    \"jobs\": {\n        \"SINGLE_CLASS_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"CATEGORY_A\": {\"children\": [], \"name\": \"A\"},\n                    \"CATEGORY_B\": {\"children\": [], \"name\": \"B\"},\n                    \"CATEGORY_C\": {\"children\": [], \"name\": \"C\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Class\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 1,\n            \"isChild\": False,\n        },\n        \"MULTI_CLASS_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"CATEGORY_D\": {\"children\": [], \"name\": \"D\"},\n                    \"CATEGORY_E\": {\"children\": [], \"name\": \"E\"},\n                    \"CATEGORY_F\": {\"children\": [], \"name\": \"F\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"Class\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 1,\n            \"isChild\": False,\n        },\n    }\n}\n</code></pre> <p>For this tutorial, we will work with already existing labels.</p> <p>Note that those labels could have been downloaded from a real Kili project using the <code>kili.labels()</code> method.</p> <p>To learn more about the json response format for classification jobs, please refer to the documentation.</p> <pre><code>json_responses = [\n    {\n        \"SINGLE_CLASS_JOB\": {\"categories\": [{\"confidence\": 75, \"name\": \"CATEGORY_A\"}]},\n        \"MULTI_CLASS_JOB\": {\n            \"categories\": [\n                {\"confidence\": 1, \"name\": \"CATEGORY_D\"},\n                {\"confidence\": 1, \"name\": \"CATEGORY_E\"},\n            ]\n        },\n    },\n    {\n        \"SINGLE_CLASS_JOB\": {\"categories\": [{\"confidence\": 50, \"name\": \"CATEGORY_B\"}]},\n        \"MULTI_CLASS_JOB\": {\n            \"categories\": [\n                {\"confidence\": 2, \"name\": \"CATEGORY_E\"},\n                {\"confidence\": 2, \"name\": \"CATEGORY_F\"},\n            ]\n        },\n    },\n    {\n        \"SINGLE_CLASS_JOB\": {\"categories\": [{\"confidence\": 25, \"name\": \"CATEGORY_C\"}]},\n        \"MULTI_CLASS_JOB\": {\n            \"categories\": [\n                {\"confidence\": 3, \"name\": \"CATEGORY_F\"},\n                {\"confidence\": 3, \"name\": \"CATEGORY_D\"},\n            ]\n        },\n    },\n]\n</code></pre> <pre><code>labels = [\n    ParsedLabel({\"jsonResponse\": label}, json_interface=json_interface, input_type=\"IMAGE\")\n    for label in json_responses\n]\n</code></pre> <pre><code>print(labels[0].jobs[\"SINGLE_CLASS_JOB\"])\n</code></pre> <pre><code>{'categories': [{'name': 'CATEGORY_A', 'confidence': 75}]}\n</code></pre> <pre><code>print(labels[0].jobs[\"SINGLE_CLASS_JOB\"].categories)\n</code></pre> <pre><code>[{'name': 'CATEGORY_A', 'confidence': 75}]\n</code></pre> <pre><code>print(labels[0].jobs[\"SINGLE_CLASS_JOB\"].categories[0].name)\nprint(labels[0].jobs[\"SINGLE_CLASS_JOB\"].categories[0].display_name)\n</code></pre> <pre><code>CATEGORY_A\nA\n</code></pre> <p>Since <code>SINGLE_CLASS_JOB</code> is a single-category classification job, the <code>.category</code> attribute is available, and is an alias for <code>.categories[0]</code>:</p> <pre><code>print(labels[0].jobs[\"SINGLE_CLASS_JOB\"].category.name)\nprint(labels[0].jobs[\"SINGLE_CLASS_JOB\"].category.confidence)\n</code></pre> <pre><code>CATEGORY_A\n75\n</code></pre> <p>The <code>.category</code> attribute is forbidden for multi-category classification jobs:</p> <pre><code>try:\n    print(labels[0].jobs[\"MULTI_CLASS_JOB\"].category.name)\nexcept Exception as err:\n    print(\"Error: \", err)\n</code></pre> <pre><code>Error:  The attribute 'category' is not compatible with the job.\n</code></pre> <p>It is also possible to iterate over the job names:</p> <pre><code>for i, label in enumerate(labels):\n    print(f\"\\nLabel {i}\")\n    for job_name, job_data in label.jobs.items():\n        print(\"job_name: \", job_name)\n        for category in job_data.categories:\n            print(\"category: \", category.display_name, category.name, category.confidence)\n</code></pre> <pre><code>Label 0\njob_name:  SINGLE_CLASS_JOB\ncategory:  A CATEGORY_A 75\njob_name:  MULTI_CLASS_JOB\ncategory:  D CATEGORY_D 1\ncategory:  E CATEGORY_E 1\n\nLabel 1\njob_name:  SINGLE_CLASS_JOB\ncategory:  B CATEGORY_B 50\njob_name:  MULTI_CLASS_JOB\ncategory:  E CATEGORY_E 2\ncategory:  F CATEGORY_F 2\n\nLabel 2\njob_name:  SINGLE_CLASS_JOB\ncategory:  C CATEGORY_C 25\njob_name:  MULTI_CLASS_JOB\ncategory:  F CATEGORY_F 3\ncategory:  D CATEGORY_D 3\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#transcription-jobs","title":"Transcription jobs","text":"<p>For a transcription job, you can access the label data through the <code>.text</code> attribute:</p> <pre><code>json_interface = {\n    \"jobs\": {\"TRANSCRIPTION_JOB\": {\"mlTask\": \"TRANSCRIPTION\", \"required\": 1, \"isChild\": False}}\n}\n\ndict_label = {\n    \"jsonResponse\": {\"TRANSCRIPTION_JOB\": {\"text\": \"This is a transcription annotation...\"}}\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"TEXT\")\n</code></pre> <pre><code>print(label.jobs[\"TRANSCRIPTION_JOB\"].text)\n</code></pre> <pre><code>This is a transcription annotation...\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#object-detection-jobs","title":"Object detection jobs","text":""},{"location":"sdk/tutorials/label_parsing/#standard-object-detection-job","title":"Standard object detection job","text":"<p>For standard object detection jobs, a parsed label has an <code>.annotations</code> attribute:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"tools\": [\"rectangle\"],\n            \"required\": 1,\n            \"isChild\": False,\n            \"content\": {\n                \"categories\": {\"CATEGORY_A\": {\"name\": \"A\"}, \"CATEGORY_B\": {\"name\": \"B\"}},\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"boundingPoly\": [\n                        {\n                            \"normalizedVertices\": [\n                                {\"x\": 0.54, \"y\": 0.52},\n                                {\"x\": 0.54, \"y\": 0.33},\n                                {\"x\": 0.70, \"y\": 0.33},\n                                {\"x\": 0.70, \"y\": 0.52},\n                            ]\n                        }\n                    ],\n                    \"categories\": [{\"name\": \"CATEGORY_B\"}],\n                    \"mid\": \"20230315142306286-25528\",\n                    \"type\": \"rectangle\",\n                }\n            ]\n        }\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"IMAGE\")\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].category.name)\n</code></pre> <pre><code>CATEGORY_B\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].type)\n</code></pre> <pre><code>rectangle\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].bounding_poly)\n</code></pre> <pre><code>[{'normalizedVertices': [{'x': 0.54, 'y': 0.52}, {'x': 0.54, 'y': 0.33}, {'x': 0.7, 'y': 0.33}, {'x': 0.7, 'y': 0.52}]}]\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].bounding_poly[0].normalized_vertices)\n</code></pre> <pre><code>[{'x': 0.54, 'y': 0.52}, {'x': 0.54, 'y': 0.33}, {'x': 0.7, 'y': 0.33}, {'x': 0.7, 'y': 0.52}]\n</code></pre> <p>The <code>.bounding_poly_annotations</code> attribute is equivalent to <code>.annotations</code>:</p> <pre><code>print(\n    label.jobs[\"OBJECT_DETECTION_JOB\"].annotations\n    == label.jobs[\"OBJECT_DETECTION_JOB\"].bounding_poly_annotations\n)\n</code></pre> <pre><code>True\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#point-detection-jobs","title":"Point detection jobs","text":"<p>The point coordinates of a point detection label are accessible through the <code>.point</code> attribute:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"CATEGORY_A\": {\"children\": [], \"color\": \"#472CED\", \"name\": \"A\"},\n                    \"CATEGORY_B\": {\"children\": [], \"name\": \"B\", \"color\": \"#5CE7B7\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Class\",\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"required\": 1,\n            \"tools\": [\"marker\"],\n            \"isChild\": False,\n        }\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"point\": {\"x\": 0.10, \"y\": 0.20},\n                    \"categories\": [{\"name\": \"CATEGORY_A\"}],\n                    \"mid\": \"20230323113855529-11197\",\n                    \"type\": \"marker\",\n                },\n                {\n                    \"children\": {},\n                    \"point\": {\"x\": 0.30, \"y\": 0.40},\n                    \"categories\": [{\"name\": \"CATEGORY_B\"}],\n                    \"mid\": \"20230323113857016-51829\",\n                    \"type\": \"marker\",\n                },\n            ]\n        }\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"IMAGE\")\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[1].type)\n</code></pre> <pre><code>marker\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[1].point)\n</code></pre> <pre><code>{'x': 0.3, 'y': 0.4}\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[1].category.name)\n</code></pre> <pre><code>CATEGORY_B\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#line-detection-jobs","title":"Line detection jobs","text":"<p>A polyline parsed label has a <code>.polyline</code> attribute.</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"CATEGORY_A\": {\"children\": [], \"color\": \"#472CED\", \"name\": \"A\"},\n                    \"CATEGORY_B\": {\"children\": [], \"name\": \"B\", \"color\": \"#5CE7B7\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Job name\",\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"required\": 1,\n            \"tools\": [\"polyline\"],\n            \"isChild\": False,\n        }\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"polyline\": [{\"x\": 0.59, \"y\": 0.40}, {\"x\": 0.25, \"y\": 0.30}],\n                    \"categories\": [{\"name\": \"CATEGORY_A\"}],\n                    \"mid\": \"20230428163557647-23000\",\n                    \"type\": \"polyline\",\n                },\n                {\n                    \"children\": {},\n                    \"polyline\": [{\"x\": 0.70, \"y\": 0.50}, {\"x\": 0.40, \"y\": 0.70}],\n                    \"categories\": [{\"name\": \"CATEGORY_B\"}],\n                    \"mid\": \"20230428163606237-86143\",\n                    \"type\": \"polyline\",\n                },\n            ]\n        }\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"IMAGE\")\n</code></pre> <pre><code>print(len(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations))\n</code></pre> <pre><code>2\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].category.name)\n</code></pre> <pre><code>CATEGORY_A\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].polyline)\n</code></pre> <pre><code>[{'x': 0.59, 'y': 0.4}, {'x': 0.25, 'y': 0.3}]\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#pose-estimation-jobs","title":"Pose estimation jobs","text":"<p>A pose estimation parsed label annotation has a <code>.points</code> attribute that returns the list of points that make up the annotation.</p> <p>Read more about pose estimation json response in the documentation.</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"content\": {\n                \"categories\": {\n                    \"HEAD\": {\n                        \"children\": [],\n                        \"name\": \"Head\",\n                        \"color\": \"#733AFB\",\n                        \"points\": [\n                            {\"code\": \"RIGHT_EARBASE\", \"name\": \"Right earbase\"},\n                            {\"code\": \"RIGHT_EYE\", \"name\": \"Right eye\"},\n                            {\"code\": \"NOSE\", \"name\": \"Nose\"},\n                            {\"code\": \"LEFT_EYE\", \"name\": \"Left eye\"},\n                            {\"code\": \"LEFT_EARBASE\", \"name\": \"Left earbase\"},\n                        ],\n                    },\n                    \"BODY\": {\n                        \"children\": [],\n                        \"name\": \"Body\",\n                        \"color\": \"#3CD876\",\n                        \"points\": [\n                            {\"code\": \"THROAT\", \"name\": \"Throat\"},\n                            {\"code\": \"WITHERS\", \"name\": \"Withers\"},\n                            {\"code\": \"TAILBASE\", \"name\": \"Tailbase\"},\n                        ],\n                    },\n                    \"FRONT_RIGHT_LEG\": {\n                        \"children\": [],\n                        \"name\": \"Front right leg\",\n                        \"color\": \"#3BCADB\",\n                        \"points\": [\n                            {\"code\": \"PAW\", \"name\": \"Paw\"},\n                            {\"code\": \"KNEE\", \"name\": \"Knee\"},\n                            {\"code\": \"ELBOW\", \"name\": \"Elbow\"},\n                        ],\n                    },\n                    \"FRONT_LEFT_LEG\": {\n                        \"children\": [],\n                        \"name\": \"Front left leg\",\n                        \"color\": \"#199CFC\",\n                        \"points\": [\n                            {\"code\": \"PAW\", \"name\": \"Paw\"},\n                            {\"code\": \"KNEE\", \"name\": \"Knee\"},\n                            {\"code\": \"ELBOW\", \"name\": \"Elbow\"},\n                        ],\n                    },\n                    \"BACK_RIGHT_LEG\": {\n                        \"children\": [],\n                        \"name\": \"Back right leg\",\n                        \"color\": \"#FA484A\",\n                        \"points\": [\n                            {\"code\": \"PAW\", \"name\": \"Paw\"},\n                            {\"code\": \"KNEE\", \"name\": \"Knee\"},\n                            {\"code\": \"ELBOW\", \"name\": \"Elbow\"},\n                        ],\n                    },\n                    \"BACK_LEFT_LEG\": {\n                        \"children\": [],\n                        \"name\": \"Back left leg\",\n                        \"color\": \"#ECB82A\",\n                        \"points\": [\n                            {\"code\": \"PAW\", \"name\": \"Paw\"},\n                            {\"code\": \"KNEE\", \"name\": \"Knee\"},\n                            {\"code\": \"ELBOW\", \"name\": \"Elbow\"},\n                        ],\n                    },\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Body parts from the animal point of view\",\n            \"isChild\": False,\n            \"tools\": [\"pose\"],\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"models\": {},\n            \"isVisible\": True,\n            \"required\": 0,\n        }\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"JOB_0\": {\n            \"annotations\": [\n                {\n                    \"categories\": [{\"name\": \"HEAD\"}],\n                    \"children\": {},\n                    \"mid\": \"20230220175803297-40094\",\n                    \"points\": [\n                        {\n                            \"children\": {},\n                            \"code\": \"RIGHT_EARBASE\",\n                            \"mid\": \"20230220170039711-76095\",\n                            \"point\": {\"x\": 0.350897302238901, \"y\": 0.18537832978498114},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"RIGHT_EYE\",\n                            \"mid\": \"20230220170039711-75233\",\n                            \"point\": {\"x\": 0.3581081932428414, \"y\": 0.2305347416594279},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"NOSE\",\n                            \"mid\": \"20230220170039711-59132\",\n                            \"point\": {\"x\": 0.38815357242592613, \"y\": 0.32807259130823285},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"LEFT_EYE\",\n                            \"mid\": \"20230220170039711-27852\",\n                            \"point\": {\"x\": 0.4386476019456967, \"y\": 0.23889914422760516},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"LEFT_EARBASE\",\n                            \"mid\": \"20230220170039711-40802\",\n                            \"point\": {\"x\": 0.46187314422288966, \"y\": 0.1875659030559057},\n                            \"type\": \"marker\",\n                        },\n                    ],\n                    \"type\": \"pose\",\n                },\n                {\n                    \"categories\": [{\"name\": \"BODY\"}],\n                    \"children\": {},\n                    \"mid\": \"20230220175812521-86245\",\n                    \"points\": [\n                        {\n                            \"children\": {},\n                            \"code\": \"THROAT\",\n                            \"mid\": \"20230220170039712-55565\",\n                            \"point\": {\"x\": 0.41045627160921705, \"y\": 0.3819115257598137},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"WITHERS\",\n                            \"mid\": \"20230220170039712-92408\",\n                            \"point\": {\"x\": 0.4818714352479842, \"y\": 0.2536057346999746},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"TAILBASE\",\n                            \"mid\": \"20230220170039712-18390\",\n                            \"point\": {\"x\": 0.6107470753777133, \"y\": 0.17341461528757518},\n                            \"type\": \"marker\",\n                        },\n                    ],\n                    \"type\": \"pose\",\n                },\n                {\n                    \"categories\": [{\"name\": \"FRONT_RIGHT_LEG\"}],\n                    \"children\": {},\n                    \"mid\": \"20230220175821453-77849\",\n                    \"points\": [\n                        {\n                            \"children\": {},\n                            \"code\": \"PAW\",\n                            \"mid\": \"20230220170039712-77846\",\n                            \"point\": {\"x\": 0.3776217136143816, \"y\": 0.9050043662345423},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"KNEE\",\n                            \"mid\": \"20230220170039712-53563\",\n                            \"point\": {\"x\": 0.4014267681606373, \"y\": 0.7026760034094114},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"ELBOW\",\n                            \"mid\": \"20230220170039712-78929\",\n                            \"point\": {\"x\": 0.3907555368123158, \"y\": 0.5151521549373389},\n                            \"type\": \"marker\",\n                        },\n                    ],\n                    \"type\": \"pose\",\n                },\n                {\n                    \"categories\": [{\"name\": \"FRONT_LEFT_LEG\"}],\n                    \"children\": {},\n                    \"mid\": \"20230220175828920-37602\",\n                    \"points\": [\n                        {\n                            \"children\": {},\n                            \"code\": \"PAW\",\n                            \"mid\": \"20230220170039712-72948\",\n                            \"point\": {\"x\": 0.46873761205005, \"y\": 0.9148740424699144},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"KNEE\",\n                            \"mid\": \"20230220170039712-67331\",\n                            \"point\": {\"x\": 0.4695584759999209, \"y\": 0.703909712938833},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"ELBOW\",\n                            \"mid\": \"20230220170039712-86687\",\n                            \"point\": {\"x\": 0.4958261223957892, \"y\": 0.541060055055191},\n                            \"type\": \"marker\",\n                        },\n                    ],\n                    \"type\": \"pose\",\n                },\n                {\n                    \"categories\": [{\"name\": \"BACK_RIGHT_LEG\"}],\n                    \"children\": {},\n                    \"mid\": \"20230220175834605-4761\",\n                    \"points\": [\n                        {\n                            \"children\": {},\n                            \"code\": \"PAW\",\n                            \"mid\": \"20230220170039712-95942\",\n                            \"point\": {\"x\": 0.5303024082903665, \"y\": 0.7470895464685865},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"KNEE\",\n                            \"mid\": \"20230220170039712-89543\",\n                            \"point\": {\"x\": 0.5623755076892811, \"y\": 0.5105044952809976},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"ELBOW\",\n                            \"mid\": \"20230220170039712-61950\",\n                            \"point\": {\"x\": 0.5359355740081666, \"y\": 0.4003228503073476},\n                            \"type\": \"marker\",\n                        },\n                    ],\n                    \"type\": \"pose\",\n                },\n                {\n                    \"categories\": [{\"name\": \"BACK_LEFT_LEG\"}],\n                    \"children\": {},\n                    \"mid\": \"20230220175849088-95977\",\n                    \"points\": [\n                        {\n                            \"children\": {},\n                            \"code\": \"PAW\",\n                            \"mid\": \"20230220170039712-40305\",\n                            \"point\": {\"x\": 0.6741443182503564, \"y\": 0.7362865546532311},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"KNEE\",\n                            \"mid\": \"20230220170039712-36409\",\n                            \"point\": {\"x\": 0.6753461334176798, \"y\": 0.49605444348117467},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"ELBOW\",\n                            \"mid\": \"20230220170039712-60395\",\n                            \"point\": {\"x\": 0.6380898632306548, \"y\": 0.38045402908259107},\n                            \"type\": \"marker\",\n                        },\n                    ],\n                    \"type\": \"pose\",\n                },\n            ]\n        }\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"IMAGE\")\n</code></pre> <pre><code>print(list(label.jobs.keys()))\n</code></pre> <pre><code>['JOB_0']\n</code></pre> <pre><code>print(label.jobs[\"JOB_0\"].annotations[0].category)\n</code></pre> <pre><code>{'name': 'HEAD', 'display_name': 'Head'}\n</code></pre> <pre><code>print(\"Number of points in this annotation: \", len(label.jobs[\"JOB_0\"].annotations[0].points))\n</code></pre> <pre><code>Number of points in this annotation:  5\n</code></pre> <pre><code>for point in label.jobs[\"JOB_0\"].annotations[0].points:\n    print(point.code, point.point)\n</code></pre> <pre><code>RIGHT_EARBASE {'x': 0.350897302238901, 'y': 0.18537832978498114}\nRIGHT_EYE {'x': 0.3581081932428414, 'y': 0.2305347416594279}\nNOSE {'x': 0.38815357242592613, 'y': 0.32807259130823285}\nLEFT_EYE {'x': 0.4386476019456967, 'y': 0.23889914422760516}\nLEFT_EARBASE {'x': 0.46187314422288966, 'y': 0.1875659030559057}\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#video-jobs","title":"Video jobs","text":"<p>A video label has an additional attribute <code>.frames</code> that returns the annotations for each frame.</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"FRAME_CLASSIF_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"OBJECT_A\": {\"children\": [], \"name\": \"Object A\"},\n                    \"OBJECT_B\": {\"children\": [], \"name\": \"Object B\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Categories\",\n            \"isChild\": False,\n            \"mlTask\": \"CLASSIFICATION\",\n            \"models\": {},\n            \"isVisible\": False,\n            \"required\": 1,\n        }\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"0\": {},\n        \"1\": {},\n        \"2\": {},\n        \"3\": {},\n        \"4\": {},\n        \"5\": {\n            \"FRAME_CLASSIF_JOB\": {\n                \"categories\": [{\"confidence\": 100, \"name\": \"OBJECT_A\"}],\n                \"isKeyFrame\": True,\n                \"annotations\": [],\n            }\n        },\n        \"6\": {\n            \"FRAME_CLASSIF_JOB\": {\n                \"categories\": [{\"confidence\": 42, \"name\": \"OBJECT_B\"}],\n                \"isKeyFrame\": False,\n                \"annotations\": [],\n            }\n        },\n        \"7\": {},\n        \"8\": {},\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"VIDEO\")\n</code></pre> <pre><code>for i, frame_annotations in enumerate(label.jobs[\"FRAME_CLASSIF_JOB\"].frames):\n    print(f\"Frame {i}: {frame_annotations}\")\n</code></pre> <pre><code>Frame 0: {}\nFrame 1: {}\nFrame 2: {}\nFrame 3: {}\nFrame 4: {}\nFrame 5: {'isKeyFrame': True, 'categories': [{'name': 'OBJECT_A', 'confidence': 100}], 'annotations': []}\nFrame 6: {'isKeyFrame': False, 'categories': [{'name': 'OBJECT_B', 'confidence': 42}], 'annotations': []}\nFrame 7: {}\nFrame 8: {}\n</code></pre> <pre><code>frame = label.jobs[\"FRAME_CLASSIF_JOB\"].frames[5]\n</code></pre> <pre><code>print(frame.category.name)\n</code></pre> <pre><code>OBJECT_A\n</code></pre> <p>The syntax is similar for object detection jobs on video:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"content\": {\n                \"categories\": {\n                    \"TRAIN\": {\"children\": [], \"name\": \"Train\", \"color\": \"#733AFB\"},\n                    \"CAR\": {\"children\": [], \"name\": \"Car\", \"color\": \"#3CD876\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Track objects A and B\",\n            \"isChild\": False,\n            \"tools\": [\"rectangle\"],\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"models\": {\"tracking\": {}},\n            \"isVisible\": True,\n            \"required\": 0,\n        }\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"0\": {},\n        \"1\": {\n            \"JOB_0\": {\n                \"annotations\": [\n                    {\n                        \"children\": {},\n                        \"boundingPoly\": [\n                            {\n                                \"normalizedVertices\": [\n                                    {\"x\": 0.30, \"y\": 0.63},\n                                    {\"x\": 0.30, \"y\": 0.55},\n                                    {\"x\": 0.36, \"y\": 0.55},\n                                    {\"x\": 0.36, \"y\": 0.63},\n                                ]\n                            }\n                        ],\n                        \"categories\": [{\"name\": \"CAR\"}],\n                        \"mid\": \"20230407140827577-43802\",\n                        \"type\": \"rectangle\",\n                        \"isKeyFrame\": True,\n                    }\n                ]\n            }\n        },\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"VIDEO\")\n</code></pre> <pre><code>print(label.jobs[\"JOB_0\"].frames[1].annotations[0].category.name)\n</code></pre> <pre><code>CAR\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#named-entities-recognition-jobs","title":"Named entities recognition jobs","text":"<p>For NER jobs, the content of the job reponse is a list of annotations.</p> <p>Those annotations can be accessed through the <code>.annotations</code> or <code>.entity_annotations</code> attributes.</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"NER_JOB\": {\n            \"mlTask\": \"NAMED_ENTITIES_RECOGNITION\",\n            \"required\": 1,\n            \"isChild\": False,\n            \"content\": {\n                \"categories\": {\"ORG\": {\"name\": \"org\"}, \"PERSON\": {\"name\": \"person\"}},\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\ndict_label = {\n    \"jsonResponse\": {\n        \"NER_JOB\": {\n            \"annotations\": [\n                {\n                    \"categories\": [{\"name\": \"ORG\", \"confidence\": 42}],\n                    \"beginOffset\": 21,\n                    \"content\": \"this is the text for Kili\",\n                    \"mid\": \"mid_a\",\n                },\n                {\n                    \"categories\": [{\"name\": \"PERSON\", \"confidence\": 100}],\n                    \"beginOffset\": 8,\n                    \"content\": \"this is Toto's text\",\n                    \"mid\": \"mid_b\",\n                },\n            ]\n        }\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"TEXT\")\n</code></pre> <pre><code>print(\"Number of annotations in this label: \", len(label.jobs[\"NER_JOB\"].annotations))\n</code></pre> <pre><code>Number of annotations in this label:  2\n</code></pre> <pre><code>print(label.jobs[\"NER_JOB\"].annotations == label.jobs[\"NER_JOB\"].entity_annotations)\n</code></pre> <pre><code>True\n</code></pre> <pre><code>print(label.jobs[\"NER_JOB\"].annotations[0].category)\n</code></pre> <pre><code>{'name': 'ORG', 'display_name': 'org', 'confidence': 42}\n</code></pre> <pre><code>print(label.jobs[\"NER_JOB\"].annotations[0].begin_offset)\n</code></pre> <pre><code>21\n</code></pre> <pre><code>print(label.jobs[\"NER_JOB\"].annotations[0].content)\n</code></pre> <pre><code>this is the text for Kili\n</code></pre> <pre><code>print(label.jobs[\"NER_JOB\"].annotations[0].mid)\n</code></pre> <pre><code>mid_a\n</code></pre> <p>It is also possible to iterate over the annotations of this label:</p> <pre><code>for annotation in label.jobs[\"NER_JOB\"].annotations:\n    print(annotation)\n</code></pre> <pre><code>{'categories': [{'name': 'ORG', 'confidence': 42}], 'beginOffset': 21, 'content': 'this is the text for Kili', 'mid': 'mid_a'}\n{'categories': [{'name': 'PERSON', 'confidence': 100}], 'beginOffset': 8, 'content': \"this is Toto's text\", 'mid': 'mid_b'}\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#named-entities-recognition-in-pdf-jobs","title":"Named entities recognition in PDF jobs","text":"<p>For PDF assets, a parsed NER label has a few additional attributes such as <code>.page_number_array</code> and <code>.polys</code>.</p> <p>The description of those attributes can be found in the documentation.</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"NAMED_ENTITIES_RECOGNITION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"CATEGORY_A\": {\"children\": [], \"color\": \"#472CED\", \"name\": \"A\"},\n                    \"CATEGORY_B\": {\"children\": [], \"name\": \"B\", \"color\": \"#5CE7B7\"},\n                    \"CATEGORY_C\": {\"children\": [], \"name\": \"C\", \"color\": \"#D33BCE\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Job name\",\n            \"mlTask\": \"NAMED_ENTITIES_RECOGNITION\",\n            \"required\": 1,\n            \"isChild\": False,\n        }\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"NAMED_ENTITIES_RECOGNITION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"annotations\": [\n                        {\n                            \"boundingPoly\": [\n                                {\n                                    \"normalizedVertices\": [\n                                        [\n                                            {\"x\": 0.46269795405629893, \"y\": 0.26256487006078677},\n                                            {\"x\": 0.46269795405629893, \"y\": 0.278286415605941},\n                                            {\"x\": 0.602529939052542, \"y\": 0.26256487006078677},\n                                            {\"x\": 0.602529939052542, \"y\": 0.278286415605941},\n                                        ]\n                                    ]\n                                }\n                            ],\n                            \"pageNumberArray\": [1],\n                            \"polys\": [\n                                {\n                                    \"normalizedVertices\": [\n                                        [\n                                            {\"x\": 0.46269795405629893, \"y\": 0.26256487006078677},\n                                            {\"x\": 0.46269795405629893, \"y\": 0.278286415605941},\n                                            {\"x\": 0.602529939052542, \"y\": 0.26256487006078677},\n                                            {\"x\": 0.602529939052542, \"y\": 0.278286415605941},\n                                        ]\n                                    ]\n                                }\n                            ],\n                        }\n                    ],\n                    \"categories\": [{\"confidence\": 100, \"name\": \"CATEGORY_C\"}],\n                    \"content\": \"Some content\",\n                    \"mid\": \"20230502085706687-73004\",\n                },\n                {\n                    \"children\": {},\n                    \"annotations\": [\n                        {\n                            \"boundingPoly\": [\n                                {\n                                    \"normalizedVertices\": [\n                                        [\n                                            {\"x\": 0.18745653985687646, \"y\": 0.4369143838760365},\n                                            {\"x\": 0.18745653985687646, \"y\": 0.45263593566837257},\n                                            {\"x\": 0.4306102589135375, \"y\": 0.4369143838760365},\n                                            {\"x\": 0.4306102589135375, \"y\": 0.45263593566837257},\n                                        ]\n                                    ]\n                                }\n                            ],\n                            \"pageNumberArray\": [1],\n                            \"polys\": [\n                                {\n                                    \"normalizedVertices\": [\n                                        [\n                                            {\"x\": 0.18745653985687646, \"y\": 0.4369143838760365},\n                                            {\"x\": 0.18745653985687646, \"y\": 0.45263593566837257},\n                                            {\"x\": 0.4306102589135375, \"y\": 0.4369143838760365},\n                                            {\"x\": 0.4306102589135375, \"y\": 0.45263593566837257},\n                                        ]\n                                    ]\n                                }\n                            ],\n                        }\n                    ],\n                    \"categories\": [{\"confidence\": 100, \"name\": \"CATEGORY_A\"}],\n                    \"content\": \"Coregist\",\n                    \"mid\": \"20230502085709115-90490\",\n                },\n            ]\n        }\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"PDF\")\n</code></pre> <pre><code>print(\"Number of annotations: \", len(label.jobs[\"NAMED_ENTITIES_RECOGNITION_JOB\"].annotations))\n</code></pre> <pre><code>Number of annotations:  2\n</code></pre> <pre><code>first_ann = label.jobs[\"NAMED_ENTITIES_RECOGNITION_JOB\"].annotations[0]\n</code></pre> <pre><code>print(first_ann.content)\n</code></pre> <pre><code>Some content\n</code></pre> <pre><code>print(first_ann.category)\n</code></pre> <pre><code>{'name': 'CATEGORY_C', 'display_name': 'C', 'confidence': 100}\n</code></pre> <p>The NER in PDFs json response format is a bit complex, and thus requires to use the <code>.annotations</code> attribute a second time. You can read more about it in the documentation.</p> <pre><code>print(first_ann.annotations[0].page_number_array)\n</code></pre> <pre><code>[1]\n</code></pre> <pre><code>print(first_ann.annotations[0].polys)\n</code></pre> <pre><code>[{'normalizedVertices': [[{'x': 0.46269795405629893, 'y': 0.26256487006078677}, {'x': 0.46269795405629893, 'y': 0.278286415605941}, {'x': 0.602529939052542, 'y': 0.26256487006078677}, {'x': 0.602529939052542, 'y': 0.278286415605941}]]}]\n</code></pre> <pre><code>print(first_ann.annotations[0].bounding_poly)\n</code></pre> <pre><code>[{'normalizedVertices': [[{'x': 0.46269795405629893, 'y': 0.26256487006078677}, {'x': 0.46269795405629893, 'y': 0.278286415605941}, {'x': 0.602529939052542, 'y': 0.26256487006078677}, {'x': 0.602529939052542, 'y': 0.278286415605941}]]}]\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#relation-jobs","title":"Relation jobs","text":"<p>A relation job is a job that links two annotations together. You can read more about it in the documentation.</p>"},{"location":"sdk/tutorials/label_parsing/#named-entities-relation-jobs","title":"Named entities relation jobs","text":"<p>A NER relation parsed label has the <code>.start_entities</code> and <code>.end_entities</code> attributes.</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"NAMED_ENTITIES_RELATION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"RELATION_1\": {\n                        \"children\": [],\n                        \"color\": \"#472CED\",\n                        \"name\": \"Relation 1\",\n                        \"endEntities\": [\"B\"],\n                        \"startEntities\": [\"A\"],\n                    }\n                },\n                \"input\": \"radio\",\n            },\n            \"mlTask\": \"NAMED_ENTITIES_RELATION\",\n            \"required\": 1,\n            \"isChild\": False,\n        },\n        \"NAMED_ENTITIES_RECOGNITION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"CATEGORY_A\": {\"children\": [], \"color\": \"#5CE7B7\", \"name\": \"A\"},\n                    \"CATEGORY_B\": {\"children\": [], \"name\": \"B\", \"color\": \"#D33BCE\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"mlTask\": \"NAMED_ENTITIES_RECOGNITION\",\n            \"required\": 1,\n            \"isChild\": False,\n        },\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"NAMED_ENTITIES_RECOGNITION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"beginId\": \"main/[0]\",\n                    \"beginOffset\": 159,\n                    \"categories\": [{\"name\": \"CATEGORY_A\"}],\n                    \"content\": \"KBDFR\",\n                    \"endId\": \"main/[0]\",\n                    \"endOffset\": 164,\n                    \"mid\": \"123\",\n                },\n                {\n                    \"children\": {},\n                    \"beginId\": \"main/[0]\",\n                    \"beginOffset\": 145,\n                    \"categories\": [{\"name\": \"CATEGORY_B\"}],\n                    \"content\": \"KBDJPN\",\n                    \"endId\": \"main/[0]\",\n                    \"endOffset\": 151,\n                    \"mid\": \"456\",\n                },\n            ]\n        },\n        \"NAMED_ENTITIES_RELATION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"categories\": [{\"name\": \"RELATION_1\"}],\n                    \"endEntities\": [{\"mid\": \"456\"}],\n                    \"mid\": \"20230502100607943-6453\",\n                    \"startEntities\": [{\"mid\": \"123\"}],\n                }\n            ]\n        },\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"TEXT\")\n</code></pre> <pre><code>print(list(label.jobs.keys()))\n</code></pre> <pre><code>['NAMED_ENTITIES_RELATION_JOB', 'NAMED_ENTITIES_RECOGNITION_JOB']\n</code></pre> <pre><code>print(\"Annotation content: \", label.jobs[\"NAMED_ENTITIES_RECOGNITION_JOB\"].annotations[0].content)\nprint(\"Category: \", label.jobs[\"NAMED_ENTITIES_RECOGNITION_JOB\"].annotations[0].category.name)\nprint(\"Begin offset: \", label.jobs[\"NAMED_ENTITIES_RECOGNITION_JOB\"].annotations[0].begin_offset)\nprint(\"End offset: \", label.jobs[\"NAMED_ENTITIES_RECOGNITION_JOB\"].annotations[0].end_offset)\n</code></pre> <pre><code>Annotation content:  KBDFR\nCategory:  CATEGORY_A\nBegin offset:  159\nEnd offset:  164\n</code></pre> <p>Here is how to print the unique IDs and names of the entity recognition annotations:</p> <pre><code>for ann in label.jobs[\"NAMED_ENTITIES_RECOGNITION_JOB\"].annotations:\n    print(ann.mid, ann.category.name)\n</code></pre> <pre><code>123 CATEGORY_A\n456 CATEGORY_B\n</code></pre> <pre><code>print(label.jobs[\"NAMED_ENTITIES_RELATION_JOB\"].annotations[0].category.name)\nprint(label.jobs[\"NAMED_ENTITIES_RELATION_JOB\"].annotations[0].start_entities)\nprint(label.jobs[\"NAMED_ENTITIES_RELATION_JOB\"].annotations[0].end_entities)\n</code></pre> <pre><code>RELATION_1\n[{'mid': '123'}]\n[{'mid': '456'}]\n</code></pre> <p>We can see that the relation annotation above refers to the entity annotations using their unique IDs.</p>"},{"location":"sdk/tutorials/label_parsing/#object-detection-relation-jobs","title":"Object detection relation jobs","text":"<p>For object detection relation jobs, the relation data is accessible through the <code>.start_objects</code> and <code>.end_objects</code> attributes.</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"CATEGORY_A\": {\"children\": [], \"color\": \"#472CED\", \"name\": \"A\"},\n                    \"CATEGORY_B\": {\"children\": [], \"name\": \"B\", \"color\": \"#5CE7B7\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"BBOX\",\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"required\": 1,\n            \"tools\": [\"rectangle\"],\n            \"isChild\": False,\n        },\n        \"OBJECT_RELATION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"RELATION_1\": {\n                        \"children\": [],\n                        \"color\": \"#D33BCE\",\n                        \"name\": \"Relation 1\",\n                        \"startObjects\": [\"CATEGORY_A\"],\n                        \"endObjects\": [\"CATEGORY_B\"],\n                    }\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Relation job\",\n            \"mlTask\": \"OBJECT_RELATION\",\n            \"required\": 1,\n            \"isChild\": False,\n        },\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"boundingPoly\": [\n                        {\n                            \"normalizedVertices\": [\n                                {\"x\": 0.11634755020512799, \"y\": 0.49755605764956},\n                                {\"x\": 0.11634755020512799, \"y\": 0.22714821030828314},\n                                {\"x\": 0.4035032060305503, \"y\": 0.22714821030828314},\n                                {\"x\": 0.4035032060305503, \"y\": 0.49755605764956},\n                            ]\n                        }\n                    ],\n                    \"categories\": [{\"name\": \"CATEGORY_A\"}],\n                    \"mid\": \"20230502102127826-44552\",\n                    \"type\": \"rectangle\",\n                },\n                {\n                    \"children\": {},\n                    \"boundingPoly\": [\n                        {\n                            \"normalizedVertices\": [\n                                {\"x\": 0.539654594568466, \"y\": 0.8005026086128164},\n                                {\"x\": 0.539654594568466, \"y\": 0.5413150038998081},\n                                {\"x\": 0.7760629146661198, \"y\": 0.5413150038998081},\n                                {\"x\": 0.7760629146661198, \"y\": 0.8005026086128164},\n                            ]\n                        }\n                    ],\n                    \"categories\": [{\"name\": \"CATEGORY_B\"}],\n                    \"mid\": \"20230502102129606-15732\",\n                    \"type\": \"rectangle\",\n                },\n            ]\n        },\n        \"OBJECT_RELATION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"categories\": [{\"name\": \"RELATION_1\"}],\n                    \"endObjects\": [{\"mid\": \"20230502102129606-15732\"}],\n                    \"mid\": \"20230502102131372-75485\",\n                    \"startObjects\": [{\"mid\": \"20230502102127826-44552\"}],\n                }\n            ]\n        },\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"IMAGE\")\n</code></pre> <pre><code>print(list(label.jobs.keys()))\n</code></pre> <pre><code>['OBJECT_DETECTION_JOB', 'OBJECT_RELATION_JOB']\n</code></pre> <pre><code>for ann in label.jobs[\"OBJECT_DETECTION_JOB\"].annotations:\n    print(ann.mid, ann.category.name)\n</code></pre> <pre><code>20230502102127826-44552 CATEGORY_A\n20230502102129606-15732 CATEGORY_B\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_RELATION_JOB\"].annotations[0].category)\nprint(label.jobs[\"OBJECT_RELATION_JOB\"].annotations[0].start_objects)\nprint(label.jobs[\"OBJECT_RELATION_JOB\"].annotations[0].end_objects)\n</code></pre> <pre><code>{'name': 'RELATION_1', 'display_name': 'Relation 1'}\n[{'mid': '20230502102127826-44552'}]\n[{'mid': '20230502102129606-15732'}]\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#child-jobs","title":"Child jobs","text":"<p>Use the <code>.children</code> attribute to access nested (child) labels:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"CATEGORY_A\": {\n                        \"children\": [\"TRANSCRIPTION_JOB\"],\n                        \"color\": \"#472CED\",\n                        \"name\": \"A\",\n                    }\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"BBox job\",\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"required\": 1,\n            \"tools\": [\"rectangle\"],\n            \"isChild\": False,\n        },\n        \"TRANSCRIPTION_JOB\": {\n            \"content\": {\"input\": \"textField\"},\n            \"instruction\": \"Transcription\",\n            \"mlTask\": \"TRANSCRIPTION\",\n            \"required\": 1,\n            \"isChild\": True,\n        },\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {\n                        \"TRANSCRIPTION_JOB\": {\"text\": \"This is a transcription of a bbox\"}\n                    },\n                    \"boundingPoly\": [\n                        {\n                            \"normalizedVertices\": [\n                                {\"x\": 0.23517058020185444, \"y\": 0.40330601957210255},\n                                {\"x\": 0.23517058020185444, \"y\": 0.22939225883393688},\n                                {\"x\": 0.4468241023835235, \"y\": 0.22939225883393688},\n                                {\"x\": 0.4468241023835235, \"y\": 0.40330601957210255},\n                            ]\n                        }\n                    ],\n                    \"categories\": [{\"name\": \"CATEGORY_A\"}],\n                    \"mid\": \"20230502102626089-88764\",\n                    \"type\": \"rectangle\",\n                }\n            ]\n        }\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"IMAGE\")\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].type)\nprint(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].category.name)\n</code></pre> <pre><code>rectangle\nCATEGORY_A\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].children[\"TRANSCRIPTION_JOB\"].text)\n</code></pre> <pre><code>This is a transcription of a bbox\n</code></pre>"},{"location":"sdk/tutorials/llm_dynamic/","title":"LLM Dynamic Projects","text":""},{"location":"sdk/tutorials/llm_dynamic/#how-to-set-up-a-kili-project-with-a-llm-model-and-create-a-conversation","title":"How to Set Up a Kili Project with a LLM Model and Create a Conversation","text":"<p>In this tutorial, you'll learn how to set up a project in Kili Technology that integrates a Large Language Model (LLM), associate the LLM with your project, and create a conversation using the Kili Python SDK. By the end of this guide, you'll have a functional project ready to collect and label LLM outputs for comparison and evaluation.</p> <p>Here are the steps we will follow:</p> <ol> <li>Creating a Kili project with a custom interface</li> <li>Creating an LLM model</li> <li>Associating the model with the project</li> <li>Creating a conversation</li> </ol>"},{"location":"sdk/tutorials/llm_dynamic/#creating-a-kili-project-with-a-custom-interface","title":"Creating a Kili Project with a Custom Interface","text":"<p>We will create a Kili project with a custom interface that includes a comparison job and a classification job. This interface will be used for labeling and comparing LLM outputs.</p> <p>Here's the JSON interface we will use:</p> <pre><code>interface = {\n    \"jobs\": {\n        \"COMPARISON_JOB\": {\n            \"content\": {\n                \"options\": {\n                    \"IS_MUCH_BETTER\": {\"children\": [], \"name\": \"Is much better\", \"id\": \"option1\"},\n                    \"IS_BETTER\": {\"children\": [], \"name\": \"Is better\", \"id\": \"option2\"},\n                    \"IS_SLIGHTLY_BETTER\": {\n                        \"children\": [],\n                        \"name\": \"Is slightly better\",\n                        \"id\": \"option3\",\n                    },\n                    \"TIE\": {\"children\": [], \"name\": \"Tie\", \"id\": \"option4\", \"mutual\": True},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Pick the best answer\",\n            \"mlTask\": \"COMPARISON\",\n            \"required\": 1,\n            \"isChild\": False,\n            \"isNew\": False,\n        },\n        \"CLASSIFICATION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"BOTH_ARE_GOOD\": {\"children\": [], \"name\": \"Both are good\", \"id\": \"category1\"},\n                    \"BOTH_ARE_BAD\": {\"children\": [], \"name\": \"Both are bad\", \"id\": \"category2\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Overall quality\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": False,\n            \"isNew\": False,\n        },\n    }\n}\n</code></pre> <p>Now, we create the project using the <code>create_project</code> method, with type <code>LLM_INSTR_FOLLOWING</code>:</p> <pre><code>from kili.client import Kili\n\nkili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n)\nproject = kili.create_project(\n    title=\"[Kili SDK Notebook]: LLM Dynamic\",\n    description=\"Project Description\",\n    input_type=\"LLM_INSTR_FOLLOWING\",\n    json_interface=interface,\n)\nproject_id = project[\"id\"]\n</code></pre>"},{"location":"sdk/tutorials/llm_dynamic/#creating-an-llm-model","title":"Creating an LLM Model","text":"<p>We will now create an LLM model in Kili, by specifying the model's credentials and connector type. In this example, we will use the OpenAI SDK as the connector type.</p> <p>Note: Replace <code>api_key</code> and <code>endpoint</code> with your model's actual credentials.</p> <pre><code>model_response = kili.llm.create_model(\n    organization_id=\"&lt;YOUR_ORGANIZATION_ID&gt;\",\n    model={\n        \"credentials\": {\n            \"api_key\": \"&lt;YOUR_OPEN_AI_API_KEY&gt;\",\n            \"endpoint\": \"&lt;your_desired_open_ai_endpoint&gt;\",\n        },\n        \"name\": \"My Model\",\n        \"type\": \"OPEN_AI_SDK\",\n    },\n)\n\nmodel_id = model_response[\"id\"]\n</code></pre> <p>You can now see the model integration by clicking Manage organization :</p> <p></p>"},{"location":"sdk/tutorials/llm_dynamic/#associating-the-model-with-the-project","title":"Associating the Model with the Project","text":"<p>Next, we will associate the created model with our project by creating project models with different configurations. Each time you create a prompt, two models will be chosen from the project models in the project</p> <p>In this example, we compare GPT 4o and GPT 4o Mini, with different temperature settings :</p> <pre><code># First project model with a fixed temperature\nfirst_project_model = kili.llm.create_project_model(\n    project_id=project_id,\n    model_id=model_id,\n    configuration={\n        \"model\": \"gpt-4o\",\n        \"temperature\": 0.5,\n    },\n)\n\n# Second project model with a temperature range\nsecond_project_model = kili.llm.create_project_model(\n    project_id=project_id,\n    model_id=model_id,\n    configuration={\n        \"model\": \"gpt-4o-mini\",\n        \"temperature\": {\"min\": 0.2, \"max\": 0.8},\n    },\n)\n</code></pre> <p>You can now see the project models in the project settings :</p> <p></p>"},{"location":"sdk/tutorials/llm_dynamic/#creating-a-conversation","title":"Creating a Conversation","text":"<p>Now, we'll generate a conversation by providing a prompt.</p> <pre><code>conversation = kili.llm.create_conversation(\n    project_id=project_id, initial_prompt=\"Give me Schr\u00f6dinger equation.\"\n)\n</code></pre> <p>It will add an asset to your project, and you'll be ready to start labeling the conversation :</p> <p></p>"},{"location":"sdk/tutorials/llm_dynamic/#summary","title":"Summary","text":"<p>In this tutorial, we've:</p> <ul> <li>Created a Kili project with a custom interface for LLM output comparison.</li> <li>Registered an LLM model in Kili with the necessary credentials.</li> <li>Associated the model with the project by creating project models with different configurations.</li> <li>Generated a conversation using a prompt, adding it to the project for labeling.</li> </ul>"},{"location":"sdk/tutorials/llm_static/","title":"LLM Static Assets","text":""},{"location":"sdk/tutorials/llm_static/#how-to-set-up-a-kili-llm-static-project","title":"How to Set Up a Kili LLM Static project","text":"<p>In this tutorial you'll learn how to create and import conversations in a Kili project with a custom interface for comparing LLM outputs.</p> <p>Here are the steps we will follow:</p> <ol> <li>Creating a Kili project with a custom interface</li> <li>Import three conversations to the project</li> </ol>"},{"location":"sdk/tutorials/llm_static/#creating-a-kili-project-with-a-custom-interface","title":"Creating a Kili Project with a Custom Interface","text":"<p>We will create a Kili project with a custom interface that includes several jobs for comparing LLM outputs.</p>"},{"location":"sdk/tutorials/llm_static/#defining-three-levels-of-annotation-jobs","title":"Defining Three Levels of Annotation Jobs","text":"<p>To streamline the annotation process, we define three distinct levels of annotation jobs:</p> <ul> <li> <p>Completion: This job enables annotators to evaluate individual responses generated by LLMs. Each response is annotated separately.</p> </li> <li> <p>Round: This job allows annotators to assess a single round of conversation, grouping all the LLM responses within that round under a single annotation.</p> </li> <li> <p>Conversation: This job facilitates annotation at the conversation level, where the entire exchange can be evaluated as a whole.</p> </li> </ul> <p>In this example, we use a JSON interface that incorporates classifications at all these levels, enabling comprehensive annotation:</p> <pre><code>interface = {\n    \"jobs\": {\n        \"CLASSIFICATION_JOB_AT_COMPLETION_LEVEL\": {\n            \"content\": {\n                \"categories\": {\n                    \"TOO_SHORT\": {\"children\": [], \"name\": \"Too short\", \"id\": \"category1\"},\n                    \"JUST_RIGHT\": {\"children\": [], \"name\": \"Just right\", \"id\": \"category2\"},\n                    \"TOO_VERBOSE\": {\"children\": [], \"name\": \"Too verbose\", \"id\": \"category3\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Verbosity\",\n            \"level\": \"completion\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": False,\n            \"isNew\": False,\n        },\n        \"CLASSIFICATION_JOB_AT_COMPLETION_LEVEL_1\": {\n            \"content\": {\n                \"categories\": {\n                    \"NO_ISSUES\": {\"children\": [], \"name\": \"No issues\", \"id\": \"category4\"},\n                    \"MINOR_ISSUES\": {\"children\": [], \"name\": \"Minor issue(s)\", \"id\": \"category5\"},\n                    \"MAJOR_ISSUES\": {\"children\": [], \"name\": \"Major issue(s)\", \"id\": \"category6\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Instructions Following\",\n            \"level\": \"completion\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": False,\n            \"isNew\": False,\n        },\n        \"CLASSIFICATION_JOB_AT_COMPLETION_LEVEL_2\": {\n            \"content\": {\n                \"categories\": {\n                    \"NO_ISSUES\": {\"children\": [], \"name\": \"No issues\", \"id\": \"category7\"},\n                    \"MINOR_INACCURACY\": {\n                        \"children\": [],\n                        \"name\": \"Minor inaccuracy\",\n                        \"id\": \"category8\",\n                    },\n                    \"MAJOR_INACCURACY\": {\n                        \"children\": [],\n                        \"name\": \"Major inaccuracy\",\n                        \"id\": \"category9\",\n                    },\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Truthfulness\",\n            \"level\": \"completion\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": False,\n            \"isNew\": False,\n        },\n        \"CLASSIFICATION_JOB_AT_COMPLETION_LEVEL_3\": {\n            \"content\": {\n                \"categories\": {\n                    \"NO_ISSUES\": {\"children\": [], \"name\": \"No issues\", \"id\": \"category10\"},\n                    \"MINOR_SAFETY_CONCERN\": {\n                        \"children\": [],\n                        \"name\": \"Minor safety concern\",\n                        \"id\": \"category11\",\n                    },\n                    \"MAJOR_SAFETY_CONCERN\": {\n                        \"children\": [],\n                        \"name\": \"Major safety concern\",\n                        \"id\": \"category12\",\n                    },\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Harmlessness/Safety\",\n            \"level\": \"completion\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": False,\n            \"isNew\": False,\n        },\n        \"COMPARISON_JOB\": {\n            \"content\": {\n                \"options\": {\n                    \"IS_MUCH_BETTER\": {\"children\": [], \"name\": \"Is much better\", \"id\": \"option13\"},\n                    \"IS_BETTER\": {\"children\": [], \"name\": \"Is better\", \"id\": \"option14\"},\n                    \"IS_SLIGHTLY_BETTER\": {\n                        \"children\": [],\n                        \"name\": \"Is slightly better\",\n                        \"id\": \"option15\",\n                    },\n                    \"TIE\": {\"children\": [], \"name\": \"Tie\", \"mutual\": True, \"id\": \"option16\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Pick the best answer\",\n            \"mlTask\": \"COMPARISON\",\n            \"required\": 1,\n            \"isChild\": False,\n            \"isNew\": False,\n        },\n        \"CLASSIFICATION_JOB_AT_ROUND_LEVEL\": {\n            \"content\": {\n                \"categories\": {\n                    \"BOTH_ARE_GOOD\": {\"children\": [], \"name\": \"Both are good\", \"id\": \"category17\"},\n                    \"BOTH_ARE_BAD\": {\"children\": [], \"name\": \"Both are bad\", \"id\": \"category18\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Overall quality\",\n            \"level\": \"round\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": False,\n            \"isNew\": False,\n        },\n        \"CLASSIFICATION_JOB_AT_CONVERSATION_LEVEL\": {\n            \"content\": {\n                \"categories\": {\n                    \"GLOBAL_GOOD\": {\"children\": [], \"name\": \"Globally good\", \"id\": \"category19\"},\n                    \"BOTH_ARE_BAD\": {\"children\": [], \"name\": \"Globally bad\", \"id\": \"category20\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Global\",\n            \"level\": \"conversation\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": False,\n            \"isNew\": False,\n        },\n        \"TRANSCRIPTION_JOB_AT_CONVERSATION_LEVEL\": {\n            \"content\": {\"input\": \"textField\"},\n            \"instruction\": \"Additional comments...\",\n            \"level\": \"conversation\",\n            \"mlTask\": \"TRANSCRIPTION\",\n            \"required\": 0,\n            \"isChild\": False,\n            \"isNew\": False,\n        },\n    }\n}\n</code></pre> <p>Now, we create the project using the <code>create_project</code> method, with type <code>LLM_STATIC</code>:</p> <pre><code>from kili.client import Kili\n\nkili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n)\nproject = kili.create_project(\n    title=\"[Kili SDK Notebook]: LLM Static\",\n    description=\"Project Description\",\n    input_type=\"LLM_STATIC\",\n    json_interface=interface,\n)\nproject_id = project[\"id\"]\n</code></pre>"},{"location":"sdk/tutorials/llm_static/#import-conversations","title":"Import conversations","text":"<p>When working with LLM Static projects in Kili, each conversation represents a single data item (or asset). You must define:</p> <ul> <li>A unique identifier for the conversation (<code>externalId</code>).</li> <li>An array of messages (or chat items) under the key <code>chatItems</code>.</li> </ul> <p>Each message in chatItems requires:</p> <ul> <li>Content of message (<code>content</code>).</li> <li>A unique identifier for the message (<code>externalId</code>).</li> <li>A <code>role</code> that can be <code>SYSTEM</code>, <code>USER</code>, or <code>ASSISTANT</code>.</li> <li>If the role is <code>ASSISTANT</code>, a <code>modelName</code> is also required, indicating which LLM produced the response.</li> </ul> <p>Important: Your conversation must contain exactly two ASSISTANT entries per \u201cround\u201d (i.e., two or more LLM responses to the same user prompt).</p>"},{"location":"sdk/tutorials/llm_static/#example-unlabeled-conversation","title":"Example: Unlabeled Conversation","text":"<p>Below is a sample 3-round conversation with two different LLMs (<code>gpt-o1</code> and <code>deepseek-r1</code>). Each round contains a USER query followed by ASSISTANT responses from each model.</p> <pre><code>\"chatItems\": [\n    {\n        \"externalId\": \"system-1\",\n        \"role\": \"SYSTEM\",\n        \"content\": \"You are an assistant helping the user by providing clear and concise answers.\"\n    },\n    {\n        \"externalId\": \"user-1\",\n        \"role\": \"USER\",\n        \"content\": \"What is the capital of France?\"\n    },\n    {\n        \"externalId\": \"assistant-1a\",\n        \"role\": \"ASSISTANT\",\n        \"content\": \"The capital of France is Paris.\",\n        \"modelName\": \"gpt-o1\"\n    },\n    {\n        \"externalId\": \"assistant-1b\",\n        \"role\": \"ASSISTANT\",\n        \"content\": \"The capital of France is Paris.\",\n        \"modelName\": \"deepseek-r1\"\n    },\n    {\n        \"externalId\": \"user-2\",\n        \"role\": \"USER\",\n        \"content\": \"What is Paris famous for?\"\n    },\n    {\n        \"externalId\": \"assistant-2a\",\n        \"role\": \"ASSISTANT\",\n        \"content\": \"Paris is renowned for its iconic landmarks, such as the Eiffel Tower, Louvre Museum, and Notre-Dame Cathedral. The city is also celebrated for its rich history, vibrant art scene, world-class cuisine, and status as a global center of fashion and romance.\",\n        \"modelName\": \"deepseek-r1\"\n    },\n    {\n        \"externalId\": \"assistant-2b\",\n        \"role\": \"ASSISTANT\",\n        \"content\": \"Paris is well-known for its art, fashion, and gastronomy, alongside iconic sites like the Eiffel Tower.\",\n        \"modelName\": \"deepseek-r1\"\n    },\n    {\n        \"externalId\": \"user-3\",\n        \"role\": \"USER\",\n        \"content\": \"What is the best time to visit Paris?\"\n    },\n    {\n        \"externalId\": \"assistant-3a\",\n        \"role\": \"ASSISTANT\",\n        \"content\": \"The best time to visit Paris is in spring (April to June) or fall (September to October), when the weather is mild and crowds are smaller.\",\n        \"modelName\": \"gpt-o1\"\n    },\n    {\n        \"externalId\": \"assistant-3b\",\n        \"role\": \"ASSISTANT\",\n        \"content\": \"Spring and autumn are ideal for visiting Paris, as the weather is pleasant, and you can avoid peak tourist season.\",\n        \"modelName\": \"deepseek-r1\"\n    }\n]\n</code></pre> <p>You can load and import such a conversation into your Kili LLM Static project by passing this data to the <code>import_conversations</code> method via the Kili Python SDK.</p> <pre><code>kili.llm.import_conversations(project_id, conversations=conversations)\n</code></pre>"},{"location":"sdk/tutorials/llm_static/#importing-labeled-conversations","title":"Importing labeled conversations","text":"<p>If you already have annotations for your conversations, you can include them in your import payload by adding the <code>label</code> and <code>labeler</code> fields.</p>"},{"location":"sdk/tutorials/llm_static/#labeler","title":"Labeler","text":"<ul> <li><code>labeler</code> : the email of the user who created the annotations.</li> </ul> <p>Note that this user must belong to your Kili organization and have access to the project.</p>"},{"location":"sdk/tutorials/llm_static/#label-structure","title":"Label Structure","text":"<p>The label object contains up to three optional keys\u2014completion, round, and conversation\u2014corresponding to the three granularity levels of labeling in an LLM Static project.</p> <pre><code>{\n  \"label\": {\n      \"completion\": { ... },\n      \"round\": { ... },\n      \"conversation\": { ... },\n  }\n}\n</code></pre>"},{"location":"sdk/tutorials/llm_static/#1-conversation-level","title":"1. Conversation level","text":"<p>Use the <code>conversation</code> field to set annotations that apply to the entire conversation. For each classification job, provide a <code>categories</code> array, and for transcription jobs, provide a <code>text</code> property.</p> <pre><code>\"conversation\": {\n    \"CLASSIFICATION_JOB_AT_CONVERSATION_LEVEL\": {\n        \"categories\": [\n            \"GLOBAL_GOOD\"\n        ]\n    },\n    \"TRANSCRIPTION_JOB_AT_CONVERSATION_LEVEL\": {\n        \"text\": \"Great conversation!\"\n    }\n}\n</code></pre> <p>\ud83d\udca1 Tip: For transcription jobs, if the job has been configured with: <pre><code>\"content\": {\"input\": \"markdown\"}\n</code></pre> then the transcription can be edited in Markdown format</p>"},{"location":"sdk/tutorials/llm_static/#2-round-level-labels","title":"2. Round-Level Labels","text":"<p>Use the round field for jobs defined with level=\"round\".</p> <ul> <li>Key: The round number (starting at 0)</li> <li>Value: The label details for that round</li> </ul> <p>For comparison jobs (where <code>mlTask</code> is <code>COMPARISON</code>), you must additionally specify <code>firstId</code> and <code>secondId</code> \u2014 the IDs of the assistant messages being compared.</p> <pre><code>\"round\": {\n    \"CLASSIFICATION_JOB_AT_ROUND_LEVEL\": {\n        \"0\": {\n          \"categories\": [\n            \"BOTH_ARE_GOOD\"\n          ]\n        },\n        \"1\": {\n          \"categories\": [\n            \"BOTH_ARE_BAD\"\n          ]\n        },\n        \"2\": {\n          \"categories\": [\n            \"BOTH_ARE_GOOD\"\n          ]\n        }\n      },\n      \"COMPARISON_JOB\": {\n        \"0\": {\n          \"code\": \"Is much better\",\n          \"firstId\": \"assistant-1a\",\n          \"secondId\": \"assistant-1b\"\n        },\n        \"1\": {\n          \"code\": \"Is better\",\n          \"firstId\": \"assistant-2a\",\n          \"secondId\": \"assistant-2b\"\n        },\n        \"2\": {\n          \"code\": \"Is much better\",\n          \"firstId\": \"assistant-3b\",\n          \"secondId\": \"assistant-3a\"\n        }\n    }\n}\n</code></pre>"},{"location":"sdk/tutorials/llm_static/#3-completion-level-labels","title":"3. Completion-Level Labels","text":"<p>Use the completion field for jobs defined at completion level (i.e label for each assistant response).</p> <ul> <li>Key : The <code>externalId</code> of the assistant message</li> <li>Value: The label details for that specific completion</li> </ul> <pre><code>\"completion\": {\n    \"CLASSIFICATION_JOB_AT_COMPLETION_LEVEL\": {\n        \"assistant-1a\": {\n            \"categories\": [\n                \"TOO_SHORT\"\n            ]\n        },\n        \"assistant-2a\": {\n            \"categories\": [\n                \"JUST_RIGHT\"\n            ]\n        },\n        \"assistant-3b\": {\n            \"categories\": [\n                \"TOO_SHORT\"\n            ]\n        }\n    }\n}\n</code></pre>"},{"location":"sdk/tutorials/llm_static/#full-example-labeled-conversation","title":"Full Example: Labeled Conversation","text":"<p>Here is a condensed example illustrating conversation, round, and completion labels. Notice each labeled conversation includes both label and labeler.</p> <pre><code>{\n    \"externalId\": \"conversation-42\",\n    \"labeler\": \"annotator@example.com\",\n    \"label\": {\n        \"conversation\": {\n            \"CLASSIFICATION_JOB_AT_CONVERSATION_LEVEL\": {\n                \"categories\": [\n                    \"GLOBAL_GOOD\"\n                ]\n            }\n        },\n        \"round\": {\n            \"COMPARISON_JOB\": {\n                \"0\": {\n                    \"code\": \"IS_BETTER\",\n                    \"firstId\": \"assistant-1a\",\n                    \"secondId\": \"assistant-1b\"\n                }\n            }\n        },\n        \"completion\": {\n            \"CLASSIFICATION_JOB_AT_COMPLETION_LEVEL\": {\n                \"assistant-1a\": {\n                    \"categories\": [\n                        \"TOO_SHORT\"\n                    ]\n                }\n            }\n        }\n    },\n    \"chatItems\": [\n        {\n            \"externalId\": \"system-1\",\n            \"role\": \"SYSTEM\",\n            \"content\": \"System instructions.\"\n        },\n        {\n            \"externalId\": \"user-1\",\n            \"role\": \"USER\",\n            \"content\": \"What's the capital of France?\"\n        },\n        {\n            \"externalId\": \"assistant-1a\",\n            \"role\": \"ASSISTANT\",\n            \"content\": \"Paris.\",\n            \"modelName\": \"gpt-o1\"\n        },\n        {\n            \"externalId\": \"assistant-1b\",\n            \"role\": \"ASSISTANT\",\n            \"content\": \"The capital is Paris, France.\",\n            \"modelName\": \"deepseek-r1\"\n        }\n    ]\n}\n</code></pre>"},{"location":"sdk/tutorials/llm_static/#final-notes","title":"Final Notes","text":"<ul> <li>Ensure each conversation and chat item has a unique <code>externalId</code>.</li> <li>When including labeled data, the specified <code>labeler</code> must be a valid user in your Kili organization with access to the project.</li> <li>Make sure your labeling schema aligns with the job definitions in your project\u2019s JSON interface.</li> </ul> <p>If you follow these guidelines, you\u2019ll be able to seamlessly import both unlabeled and labeled conversations into your Kili LLM Static project.</p> <pre><code>\n</code></pre>"},{"location":"sdk/tutorials/medical_imaging/","title":"DICOM","text":""},{"location":"sdk/tutorials/medical_imaging/#how-to-upload-medical-images-to-kili-and-visualize-segmentation-labels-with-matplotlib","title":"How to upload medical images to Kili, and visualize segmentation labels with matplotlib","text":"<p>In this tutorial, we will learn how to:</p> <ul> <li>upload medical images to Kili using pydicom</li> <li>upload dicom tags as metadata to our assets</li> <li>download segmentation labels from Kili, and convert them to Numpy masks for visualization with matplotlib.</li> </ul> <p>Data used in this tutorial comes from the RSNA Pneumonia Detection Challenge hosted on Kaggle.</p> <p>First of all, let's import the packages, and install pydicom in case you don't have it installed.</p> <pre><code>%pip install pydicom matplotlib Pillow wget numpy pandas kili\n</code></pre> <pre><code>import pickle\nfrom functools import reduce\nfrom pathlib import Path\n\nimport matplotlib.patches as mpatches\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pydicom\nimport wget\nfrom PIL import Image\n\nfrom kili.client import Kili\n</code></pre>"},{"location":"sdk/tutorials/medical_imaging/#get-data","title":"Get data","text":"<p>Let's download some dicom images:</p> <pre><code>wget.download(\n    \"https://github.com/kili-technology/kili-python-sdk/blob/main/recipes/datasets/0000a175-0e68-4ca4-b1af-167204a7e0bc.dcm?raw=true\"\n)\nwget.download(\n    \"https://github.com/kili-technology/kili-python-sdk/blob/main/recipes/datasets/0005d3cc-3c3f-40b9-93c3-46231c3eb813.dcm?raw=true\"\n)\n\ndata_folder = Path()\nfiles = list(data_folder.glob(\"*.dcm\"))\nassert len(files) == 2, files\n</code></pre>"},{"location":"sdk/tutorials/medical_imaging/#process-data","title":"Process data","text":"<p>A dicom image not only contains pixels (or voxels), but also dicom tags, that can contain information about the patient, the scanner, etc.</p> <p>Below, we extract the dicom tags and add them to <code>metadata_array</code>.</p> <p>We also convert all images to JPEG format.</p> <pre><code>def extract_dicom_tags(img_dicom):\n    metadata = {}\n    for key in img_dicom.keys():\n        if key.group == 32736:  # key containing the image pixels\n            continue\n        item = img_dicom.get(key)\n        if hasattr(item, \"description\") and hasattr(item, \"value\"):\n            metadata[item.description()] = str(item.value)\n    return metadata\n</code></pre> <pre><code>metadata_array = []\nprocessed_imgs = []\n\nfor file in files:\n    sample = pydicom.dcmread(str(file))\n\n    im = Image.fromarray(sample.pixel_array)\n    fpath = data_folder / f\"{file.stem}.jpeg\"\n    im.save(str(fpath))\n    processed_imgs.append(str(fpath))\n\n    metadata_array.append(extract_dicom_tags(sample))\n</code></pre> <pre><code>print(metadata_array[0])\n</code></pre> <pre><code>{'Specific Character Set': 'ISO_IR 100', 'SOP Class UID': '1.2.840.10008.5.1.4.1.1.7', 'SOP Instance UID': '1.2.276.0.7230010.3.1.4.8323329.1747.1517874292.605928', 'Study Date': '19010101', 'Study Time': '000000.00', 'Accession Number': '', 'Modality': 'CR', 'Conversion Type': 'WSD', \"Referring Physician's Name\": '', 'Series Description': 'view: PA', \"Patient's Name\": '0005d3cc-3c3f-40b9-93c3-46231c3eb813', 'Patient ID': '0005d3cc-3c3f-40b9-93c3-46231c3eb813', \"Patient's Birth Date\": '', \"Patient's Sex\": 'F', \"Patient's Age\": '22', 'Body Part Examined': 'CHEST', 'View Position': 'PA', 'Study Instance UID': '1.2.276.0.7230010.3.1.2.8323329.1747.1517874292.605927', 'Series Instance UID': '1.2.276.0.7230010.3.1.3.8323329.1747.1517874292.605926', 'Study ID': '', 'Series Number': '1', 'Instance Number': '1', 'Patient Orientation': '', 'Samples per Pixel': '1', 'Photometric Interpretation': 'MONOCHROME2', 'Rows': '1024', 'Columns': '1024', 'Pixel Spacing': '[0.14300000000000002, 0.14300000000000002]', 'Bits Allocated': '8', 'Bits Stored': '8', 'High Bit': '7', 'Pixel Representation': '0', 'Lossy Image Compression': '01', 'Lossy Image Compression Method': 'ISO_10918_1'}\n</code></pre>"},{"location":"sdk/tutorials/medical_imaging/#create-the-kili-project","title":"Create the Kili project","text":"<p>Next, we need to connect to Kili, create a project, and define the annotation interface (ontology).</p> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre> <pre><code>json_interface = {\n    \"jobs\": {\n        \"CLASSIFICATION_JOB\": {\n            \"mlTask\": \"CLASSIFICATION\",\n            \"content\": {\n                \"categories\": {\"YES\": {\"name\": \"Yes\"}, \"NO\": {\"name\": \"No\"}},\n                \"input\": \"radio\",\n            },\n            \"required\": 1,\n            \"isChild\": False,\n            \"instruction\": \"Healthy ?\",\n        },\n        \"JOB_0\": {\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"content\": {\n                \"categories\": {\n                    \"BONE\": {\"name\": \"bone\"},\n                    \"TISSUE\": {\"name\": \"tissue\"},\n                    \"LUNG\": {\"name\": \"lung\"},\n                    \"RIB\": {\"name\": \"rib\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"required\": True,\n            \"tools\": [\"polygon\"],\n            \"isChild\": False,\n            \"instruction\": \"Segmentation\",\n        },\n    }\n}\n</code></pre> <p>We can now use the Kili SDK to create our project and upload our images to the project.</p> <pre><code>title = \"[Kili SDK Notebook]: Medical Imaging with Kili Technology\"\ndescription = \"This is a test project\"\ninput_type = \"IMAGE\"\n\nproject = kili.create_project(\n    title=title, description=description, input_type=input_type, json_interface=json_interface\n)\nproject_id = project[\"id\"]\n</code></pre> <pre><code>kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=processed_imgs,\n    external_id_array=processed_imgs,\n    json_metadata_array=metadata_array,\n)\n</code></pre> <p>Done! Your images and their metadata are in the project:</p> <p></p> <p></p> <p>All that remains is to start labeling! To learn more about how to label images in Kili, check out our documentation.</p>"},{"location":"sdk/tutorials/medical_imaging/#convert-kili-labels-to-numpy-masks","title":"Convert Kili labels to numpy masks","text":"<p>Once your assets are labeled, you might want to download them and visualize them using matplotlib.</p> <p>To download your labels, simply use <code>kili.labels(project_id)</code>. You can also export your labels to a zip file using <code>kili.export_labels(project_id)</code>. For more information, see the documentation.</p> <p>In this tutorial, we assume that our labels have already been downloaded and stored in a file <code>medical-labels.pkl</code>.</p> <pre><code>from kili.utils.labels.parsing import ParsedLabel\n</code></pre> <pre><code>wget.download(\n    \"https://github.com/kili-technology/kili-python-sdk/blob/main/recipes/conf/medical-labels.pkl?raw=true\"\n)\n\nwith open(\"medical-labels.pkl\", \"rb\") as f:\n    label = pickle.load(f)\n\nlabel = ParsedLabel(\n    label={\"jsonResponse\": label}, json_interface=json_interface, input_type=\"IMAGE\"\n)\n\nhealthy = label.jobs[\"CLASSIFICATION_JOB\"].category.name\nannotations = label.jobs[\"JOB_0\"].annotations\n</code></pre> <pre><code>print(healthy)\n</code></pre> <pre><code>YES\n</code></pre> <p>In this example, <code>annotations</code> is a list containing 10 masks.</p> <p>A mask is represented by a Python list of vertices, each vertex being a list of two coordinates (x, y).</p> <pre><code>print(len(annotations))\nprint(type(annotations))\nprint(len(annotations[0].bounding_poly[0].normalized_vertices))\nprint(annotations[0].bounding_poly[0].normalized_vertices[0])\n</code></pre> <pre><code>10\n&lt;class 'kili.services.label_data_parsing.annotation.AnnotationList'&gt;\n255\n{'x': 0.401891, 'y': 0.024966000000015254}\n</code></pre> <p>We assign a color to each class:</p> <pre><code>import matplotlib.colors as mcolors\n\ncolors = plt.rcParams[\"axes.prop_cycle\"].by_key()[\"color\"]\ncolors = [\n    tuple(int(x * 255) for x in mcolors.hex2color(hex_color))\n    for hex_color in plt.rcParams[\"axes.prop_cycle\"].by_key()[\"color\"]\n]\nCLASS_TO_COLOR = {}\nfor class_name, color in zip(\n    json_interface[\"jobs\"][\"JOB_0\"][\"content\"][\"categories\"].keys(), colors\n):\n    CLASS_TO_COLOR[class_name] = color\nprint(CLASS_TO_COLOR)\n</code></pre> <pre><code>{'BONE': (31, 119, 180), 'TISSUE': (255, 127, 14), 'LUNG': (44, 160, 44), 'RIB': (214, 39, 40)}\n</code></pre> <p>We convert those labels using the <code>kili.utils.labels</code> module, and plot them using matplotlib:</p> <pre><code>from kili.utils.labels.image import normalized_vertices_to_mask\n</code></pre> <pre><code>im = Image.open(processed_imgs[0])\n\nimg_width, img_height = im.size\nclass_names = []\nmasks = []\nfor annotation in annotations:\n    class_name = annotation.category.name\n    normalized_vertices = annotation.bounding_poly[0].normalized_vertices\n\n    # convert the label normalized vertices to a numpy mask\n    mask = normalized_vertices_to_mask(normalized_vertices, img_width, img_height)\n\n    # add color to the mask\n    mask_rgb = np.zeros((*mask.shape, 3), dtype=np.int32)\n    mask_rgb[mask &gt; 0] = CLASS_TO_COLOR[class_name]\n\n    class_names.append(class_name)\n    masks.append(mask_rgb)\n</code></pre> <p>Let's merge all masks into a single one:</p> <pre><code>merged_masks = reduce(lambda mask_1, mask_2: np.where(mask_1 != (0, 0, 0), mask_1, mask_2), masks)\n</code></pre>"},{"location":"sdk/tutorials/medical_imaging/#plot-the-image-and-masks","title":"Plot the image and masks","text":"<p>Finally, we can plot the image as well as the masks converted from our Kili labels:</p> <pre><code>handles = []\nlabels = []\nfor class_name, color in CLASS_TO_COLOR.items():\n    patch = mpatches.Patch(color=tuple(x / 255 for x in color), label=class_name)\n    handles.append(patch)\n    labels.append(class_name)\n</code></pre> <pre><code>fig, ax = plt.subplots(figsize=(10, 10))\nax.imshow(im, cmap=\"gray\")\nax.imshow(merged_masks, alpha=0.5)\nax.set_title(f\"Healthy: {healthy}\")\nax.legend(handles=handles, labels=labels, fontsize=16, loc=\"upper left\")\nplt.show()\n</code></pre> <p></p> <p>Congrats! \ud83d\udc4f</p> <p>In this tutorial, we have seen how to upload medical images to Kili, and how to download the segmentation labels and convert them to Numpy masks.</p>"},{"location":"sdk/tutorials/medical_imaging/#project-cleanup","title":"Project cleanup","text":"<pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/","title":"OpenAI NER Pre-annotations","text":""},{"location":"sdk/tutorials/ner_pre_annotations_openai/#how-to-import-openai-ner-pre-annotations","title":"How to import OpenAI NER pre-annotations","text":"<p>This tutorial explains how to use a powerful OpenAI Large Language Model (LLM) to generate pre-annotations, which will then be imported into a Named Entity Recognition (NER) Kili project.</p> <p>Nowadays, LLMs are capable of performing many NLP tasks, including NER, without being explicitly trained on them, which is known as zero-shot learning.</p> <p>By using a well-designed prompt, we can generate high-quality pre-annotations for the NER task, as demonstrated in the pre-annotations quality evaluation section of this tutorial.</p> <p>Throughout this tutorial, we will thus:</p> <ul> <li>Load a dataset CoNLL2003 from the HuggingFace datasets library.</li> <li>Learn how to use the OpenAI API to generate pre-annotations.</li> <li>Import data and labels into a NER project on Kili.</li> <li>Evaluate the quality of the generated pre-annotations.</li> </ul>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#setup","title":"Setup","text":"<p>Let's start this tutorial by installing the packages we will need later on.</p> <pre><code>%pip install kili datasets evaluate ipywidgets openai scikit-learn numpy rich\n</code></pre> <pre><code>import getpass\nimport json\nimport os\nfrom collections import defaultdict\n\nimport numpy as np\nimport openai\nfrom rich.console import Console\nfrom rich.table import Table\n</code></pre>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#data-preparation","title":"Data preparation","text":"<p>In this tutorial, we will use the CoNLL2003 dataset from the Hugging Face repository. This dataset contains more than 10,000 sentences annotated with named entities.</p> <pre><code>from datasets import load_dataset\n</code></pre> <p>To speed up the process, we will use a limited number of samples. We will also remove sentences that do not contain enough words.</p> <pre><code>MAX_DATAPOINTS = 20\nMIN_NB_TOKENS_PER_SENTENCE = 9\n</code></pre> <pre><code>dataset = load_dataset(\"conll2003\", split=\"train\").filter(\n    lambda datapoint: len(datapoint[\"tokens\"]) &gt;= MIN_NB_TOKENS_PER_SENTENCE\n)\ndataset = dataset.select(range(MAX_DATAPOINTS))\n</code></pre> <pre><code>print(dataset)\n</code></pre> <pre><code>Dataset({\n    features: ['id', 'tokens', 'pos_tags', 'chunk_tags', 'ner_tags'],\n    num_rows: 20\n})\n</code></pre> <pre><code>for i in range(3):\n    print(dataset[i])\n</code></pre> <pre><code>{'id': '0', 'tokens': ['EU', 'rejects', 'German', 'call', 'to', 'boycott', 'British', 'lamb', '.'], 'pos_tags': [22, 42, 16, 21, 35, 37, 16, 21, 7], 'chunk_tags': [11, 21, 11, 12, 21, 22, 11, 12, 0], 'ner_tags': [3, 0, 7, 0, 0, 0, 7, 0, 0]}\n{'id': '3', 'tokens': ['The', 'European', 'Commission', 'said', 'on', 'Thursday', 'it', 'disagreed', 'with', 'German', 'advice', 'to', 'consumers', 'to', 'shun', 'British', 'lamb', 'until', 'scientists', 'determine', 'whether', 'mad', 'cow', 'disease', 'can', 'be', 'transmitted', 'to', 'sheep', '.'], 'pos_tags': [12, 22, 22, 38, 15, 22, 28, 38, 15, 16, 21, 35, 24, 35, 37, 16, 21, 15, 24, 41, 15, 16, 21, 21, 20, 37, 40, 35, 21, 7], 'chunk_tags': [11, 12, 12, 21, 13, 11, 11, 21, 13, 11, 12, 13, 11, 21, 22, 11, 12, 17, 11, 21, 17, 11, 12, 12, 21, 22, 22, 13, 11, 0], 'ner_tags': [0, 3, 4, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}\n{'id': '4', 'tokens': ['Germany', \"'s\", 'representative', 'to', 'the', 'European', 'Union', \"'s\", 'veterinary', 'committee', 'Werner', 'Zwingmann', 'said', 'on', 'Wednesday', 'consumers', 'should', 'buy', 'sheepmeat', 'from', 'countries', 'other', 'than', 'Britain', 'until', 'the', 'scientific', 'advice', 'was', 'clearer', '.'], 'pos_tags': [22, 27, 21, 35, 12, 22, 22, 27, 16, 21, 22, 22, 38, 15, 22, 24, 20, 37, 21, 15, 24, 16, 15, 22, 15, 12, 16, 21, 38, 17, 7], 'chunk_tags': [11, 11, 12, 13, 11, 12, 12, 11, 12, 12, 12, 12, 21, 13, 11, 12, 21, 22, 11, 13, 11, 1, 13, 11, 17, 11, 12, 12, 21, 1, 0], 'ner_tags': [5, 0, 0, 0, 0, 3, 4, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0]}\n</code></pre> <p>Here is the meaning of each feature in the dataset:</p> <ul> <li>id: A unique identifier for each token in a sentence.</li> <li>tokens: The tokens (words or punctuation marks) in a sentence.</li> <li>pos_tags: Part-of-speech tags for each token in the sentence. Part-of-speech tagging is the process of assigning a tag to each word in a sentence that indicates its part of speech (e.g., noun, verb, adjective, etc.).</li> <li>chunk_tags: Chunking tags for each token in the sentence. Chunking is the process of grouping words into meaningful phrases based on their syntactic structure.</li> <li>ner_tags: Named Entity Recognition (NER) tags for each token in the sentence. NER is the task of identifying named entities in text and classifying them into pre-defined categories such as person, organization, location, etc.</li> </ul> <p>The sentences are split into tokens. We can regroup the tokens for later use:</p> <pre><code>fix_joined_tokens_map = {\" .\": \".\", \"( \": \"(\", \" )\": \")\", \" 's \": \"'s \", \"s ' \": \"s' \"}\n\nsentence_column = []\nfor datapoint in dataset:\n    sentence = \" \".join(datapoint[\"tokens\"])\n    for before, after in fix_joined_tokens_map.items():\n        sentence = sentence.replace(before, after)\n    sentence_column.append(sentence)\n\ndataset = dataset.add_column(\"sentence\", sentence_column)\n</code></pre> <pre><code>print(dataset[0])\n</code></pre> <pre><code>{'id': '0', 'tokens': ['EU', 'rejects', 'German', 'call', 'to', 'boycott', 'British', 'lamb', '.'], 'pos_tags': [22, 42, 16, 21, 35, 37, 16, 21, 7], 'chunk_tags': [11, 21, 11, 12, 21, 22, 11, 12, 0], 'ner_tags': [3, 0, 7, 0, 0, 0, 7, 0, 0], 'sentence': 'EU rejects German call to boycott British lamb.'}\n</code></pre> <pre><code>NER_TAGS_ONTOLOGY = {\n    \"O\": 0,\n    \"B-PERSON\": 1,\n    \"I-PERSON\": 2,\n    \"B-ORGANIZATION\": 3,\n    \"I-ORGANIZATION\": 4,\n    \"B-LOCATION\": 5,\n    \"I-LOCATION\": 6,\n    \"B-MISCELLANEOUS\": 7,\n    \"I-MISCELLANEOUS\": 8,\n}\n</code></pre> <p><code>NER_TAGS_ONTOLOGY</code> is a dictionary that maps the named entity tags in the CoNLL2003 dataset to integer labels. Here is the meaning of each key-value pair in the dictionary:</p> <ul> <li>O: Represents the tag \"O\" which means that the token is not part of a named entity.</li> <li>B-PERSON: Represents the beginning of a person.</li> <li>I-PERSON: Represents a token inside a person.</li> <li>B-ORGANIZATION: Represents the beginning of an organization.</li> <li>I-ORGANIZATION: Represents a token inside an organization.</li> <li>B-LOCATION: Represents the beginning of a location.</li> <li>I-LOCATION: Represents a token inside a location.</li> <li>B-MISCELLANEOUS: Represents the beginning of a miscellaneous.</li> <li>I-MISCELLANEOUS: Represents a token inside a miscellaneous.</li> </ul> <p>During the training of a NER model, the entity names will be converted to integer labels using such a dictionary.</p>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#connect-with-chatgpt-api","title":"Connect with ChatGPT API","text":"<p>Let's use the OpenAI API to get the pre-annotations for our dataset.</p> <pre><code>if \"OPENAI_API_KEY\" in os.environ:\n    OPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\nelse:\n    OPENAI_API_KEY = getpass.getpass(\"Please enter your OpenAI API key: \")\n</code></pre> <pre><code>openai.api_key = OPENAI_API_KEY\n</code></pre> <p>We can now define the parameters that will be used during the query to OpenAI model:</p> <ul> <li>model: the model that will be used to generate the pre-annotations. The full list is available under this link.</li> <li>temperature: the temperature of the model. The higher the temperature, the more random the text. The lower the temperature, the more likely it is to predict the next word. The default value is 0.7. It should be between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.</li> <li>max_tokens: the maximum number of tokens to generate. The default value is 64. It should be between 1 and 4096, depending on the model.</li> </ul> <pre><code>openai_query_params = {\"model\": \"text-davinci-003\", \"temperature\": 0, \"max_tokens\": 1024}\n\n\ndef ask_openai(prompt: str, openai_query_params=openai_query_params) -&gt; str:\n    response = openai.Completion.create(\n        prompt=prompt,\n        **openai_query_params,\n    )\n    return response[\"choices\"][0][\"text\"]\n</code></pre> <p>Let's test the API with a simple prompt:</p> <pre><code>print(ask_openai(\"Hello, are you here?\"))\n</code></pre> <pre><code>Yes, I am here. How can I help you?\n</code></pre>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#prompt-design","title":"Prompt design","text":"<p>To get pre-annotations for our dataset, we need to create a prompt that tells the model what to do:</p> <pre><code>base_prompt = \"\"\"In the sentence below, give me the list of:\n- organization named entity\n- location named entity\n- person named entity\n- miscellaneous named entity.\nFormat the output in json with the following keys:\n- ORGANIZATION for organization named entity\n- LOCATION for location named entity\n- PERSON for person named entity\n- MISCELLANEOUS for miscellaneous named entity.\nSentence below:\n\"\"\"\n</code></pre> <p>Let's see if the model understands the prompt well on a simple example:</p> <pre><code>test_sentence = (\n    \"Elon Musk is the CEO of Tesla and SpaceX. He was born in South Africa and now lives in the\"\n    \" USA. He is one of the founders of OpenAI.\"\n)\n</code></pre> <pre><code>print(ask_openai(base_prompt + test_sentence))\n</code></pre> <pre><code>{\n  \"ORGANIZATION\": [\"Tesla\", \"SpaceX\", \"OpenAI\"],\n  \"LOCATION\": [\"South Africa\", \"USA\"],\n  \"PERSON\": [\"Elon Musk\"],\n  \"MISCELLANEOUS\": []\n}\n</code></pre> <p>Looks really good! Let's now process all sentences in our dataset with the previous prompt.</p>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#create-the-pre-annotations","title":"Create the pre-annotations","text":"<p>In the code below, we will use the OpenAI API to get the pre-annotations for each sentence in our dataset.</p> <pre><code>openai_answers = []\nfor datapoint in dataset:\n    sentence = datapoint[\"sentence\"]\n    answer = ask_openai(base_prompt + sentence)\n    try:\n        answer_json = json.loads(answer)\n    except json.JSONDecodeError:\n        print(f\"Wrong json formatting:\\n{answer}\")\n        answer_json = {\"ORGANIZATION\": [], \"LOCATION\": [], \"PERSON\": [], \"MISCELLANEOUS\": []}\n    openai_answers.append(answer_json)\n</code></pre> <pre><code>print(openai_answers[:3])\n</code></pre> <pre><code>[{'ORGANIZATION': ['EU', 'German'], 'LOCATION': ['British'], 'PERSON': [], 'MISCELLANEOUS': ['lamb']}, {'ORGANIZATION': ['European Commission'], 'LOCATION': ['German', 'British'], 'PERSON': [], 'MISCELLANEOUS': ['mad cow disease']}, {'ORGANIZATION': [\"European Union's veterinary committee\"], 'LOCATION': ['Germany', 'Britain'], 'PERSON': ['Werner Zwingmann'], 'MISCELLANEOUS': []}]\n</code></pre> <p>We need to sanitize the json to make sure that the values are of type list:</p> <pre><code>for i, _ in enumerate(openai_answers):\n    json_dict = openai_answers[i]\n    for category in json_dict:\n        if isinstance(json_dict[category], str):\n            json_dict[category] = [json_dict[category]]\n        elif isinstance(json_dict[category], list):\n            continue\n        else:\n            print(f\"Unknown value type '{json_dict[category]}' for value '{json_dict[category]}'\")\n            json_dict[category] = []\n</code></pre>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#import-dataset-and-pre-annotations-to-kili","title":"Import dataset and pre-annotations to Kili","text":"<p>Now that we have both the data and the pre-annotations, we can import them to a Kili project.</p> <pre><code>from kili.client import Kili\n</code></pre> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre> <p>Below, we define the ontology (json interface) of the project. We define the 4 classes as well as their corresponding colors:</p> <pre><code>COLORS = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\"]\n\nENTITY_TYPES = [\n    (\"PERSON\", \"Person\"),\n    (\"ORGANIZATION\", \"Organization\"),\n    (\"LOCATION\", \"Location\"),\n    (\"MISCELLANEOUS\", \"Miscellaneous\"),\n]\n\nENTITY_TYPES_WITH_COLORS = [\n    (entity_type[0], entity_type[1], color) for entity_type, color in zip(ENTITY_TYPES, COLORS)\n]\nprint(ENTITY_TYPES_WITH_COLORS)\n</code></pre> <pre><code>[('PERSON', 'Person', '#1f77b4'), ('ORGANIZATION', 'Organization', '#ff7f0e'), ('LOCATION', 'Location', '#2ca02c'), ('MISCELLANEOUS', 'Miscellaneous', '#d62728')]\n</code></pre> <pre><code>json_interface = {\n    \"jobs\": {\n        \"NAMED_ENTITIES_RECOGNITION_JOB\": {\n            \"mlTask\": \"NAMED_ENTITIES_RECOGNITION\",\n            \"content\": {\n                \"categories\": {\n                    name: {\"name\": name_pretty, \"children\": [], \"color\": color}\n                    for name, name_pretty, color in ENTITY_TYPES_WITH_COLORS\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"\",\n            \"required\": 1,\n            \"isChild\": False,\n        }\n    },\n}\n</code></pre> <p>Let's now create the project with its ontology:</p> <pre><code>project = kili.create_project(\n    title=\"[Kili SDK Notebook]: CoNLL Named Entity Recognition with OpenAI pre-annotations\",\n    input_type=\"TEXT\",\n    json_interface=json_interface,\n)\nproject_id = project[\"id\"]\n</code></pre> <p>We now import the sentences to the project:</p> <pre><code>external_id_array = []\ncontent_array = []\nfor datapoint in dataset:\n    sentence = datapoint[\"sentence\"]\n    content_array.append(sentence)\n    external_id_array.append(datapoint[\"id\"])\n\nprint(content_array[:3])\nprint(external_id_array[:3])\n</code></pre> <pre><code>['EU rejects German call to boycott British lamb.', 'The European Commission said on Thursday it disagreed with German advice to consumers to shun British lamb until scientists determine whether mad cow disease can be transmitted to sheep.', \"Germany's representative to the European Union's veterinary committee Werner Zwingmann said on Wednesday consumers should buy sheepmeat from countries other than Britain until the scientific advice was clearer.\"]\n['0', '3', '4']\n</code></pre> <pre><code>kili.append_many_to_dataset(\n    project_id=project_id, content_array=content_array, external_id_array=external_id_array\n)\n</code></pre> <pre><code>{'id': 'clf14l26401or0jv4e0d7d9ge'}\n</code></pre> <p>If you go to the project page, you should be able to see your assets:</p> <p></p> <p>And on the labeling interface, you will see the sentence and the ontology:</p> <p></p> <p>We can finally import our OpenAI-generated pre-annotations!</p> <pre><code>json_response_array = []\n\nfor datapoint, sentence_annotations in zip(dataset, openai_answers):\n    full_sentence = datapoint[\"sentence\"]\n    annotations = []  # list of annotations for the sentence\n    for category, _ in ENTITY_TYPES:\n        sentence_annotations_cat = sentence_annotations[category]\n        for content in sentence_annotations_cat:\n            begin_offset = full_sentence.find(content)\n            assert (\n                begin_offset != -1\n            ), f\"Cannot find offset of '{content}' in sentence '{full_sentence}'\"\n            annotation = {\n                \"categories\": [{\"name\": category}],\n                \"beginOffset\": begin_offset,\n                \"content\": content,\n            }\n            annotations.append(annotation)\n\n    json_resp = {\"NAMED_ENTITIES_RECOGNITION_JOB\": {\"annotations\": annotations}}\n    json_response_array.append(json_resp)\n</code></pre> <pre><code>print(json_response_array[0])\n</code></pre> <pre><code>{'NAMED_ENTITIES_RECOGNITION_JOB': {'annotations': [{'categories': [{'name': 'ORGANIZATION'}], 'beginOffset': 0, 'content': 'EU'}, {'categories': [{'name': 'ORGANIZATION'}], 'beginOffset': 11, 'content': 'German'}, {'categories': [{'name': 'LOCATION'}], 'beginOffset': 34, 'content': 'British'}, {'categories': [{'name': 'MISCELLANEOUS'}], 'beginOffset': 42, 'content': 'lamb'}]}}\n</code></pre> <p>We then import the annotations using the <code>kili.create_predictions()</code> method:</p> <pre><code>kili.create_predictions(\n    project_id,\n    external_id_array=external_id_array,\n    json_response_array=json_response_array,\n    model_name=openai_query_params[\"model\"],\n)\n</code></pre> <pre><code>{'id': 'clf14l26401or0jv4e0d7d9ge'}\n</code></pre> <p>In the main project page, you should now be able to see that the assets have been pre-annotated with the model you chose before:</p> <p></p> <p>On the labeling interface for a specific asset, you can see the pre-annotations:</p> <p></p> <p>Great! We have successfully pre-annotated our dataset. Looks like this solution has the potential to save us a lot of time in future projects.</p>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#pre-annotations-quality-evaluation","title":"Pre-annotations quality evaluation","text":"<p>Because OpenAI-generated pre-annotations are not perfect, it would be great to have a way to measure the model's accuracy.</p> <p>Since our dataset CoNLL2003 has been annotated, we can easily evaluate the quality of the pre-annotations generated by OpenAI.</p> <pre><code>def format_sentence_annotations(sentence_annotations):\n    \"\"\"Maps a token to its NER tag (B-ORGANIZATION, I-ORGANIZATION, etc.) class value.\"\"\"\n    ret = defaultdict(list)\n    for category, _ in ENTITY_TYPES:\n        sentence_annotations_cat = sentence_annotations[category]\n        for content in sentence_annotations_cat:\n            content_split = content.split(\" \")\n            for i, token in enumerate(content_split):\n                if i == 0:\n                    ret[token].append(NER_TAGS_ONTOLOGY[f\"B-{category}\"])\n                else:\n                    ret[token].append(NER_TAGS_ONTOLOGY[f\"I-{category}\"])\n    return ret\n\n\nreferences = []\npredictions = []\nfor datapoint, sentence_annotations in zip(dataset, openai_answers):\n    references.append(datapoint[\"ner_tags\"])\n\n    sentence_annotations = format_sentence_annotations(sentence_annotations)\n    ner_tags_predicted = []\n    for token in datapoint[\"tokens\"]:\n        if token in sentence_annotations and len(sentence_annotations[token]) &gt; 0:\n            ner_tags_predicted.append(sentence_annotations[token][0])\n            del sentence_annotations[token][0]\n        else:\n            ner_tags_predicted.append(NER_TAGS_ONTOLOGY[\"O\"])\n    predictions.append(ner_tags_predicted)\n</code></pre> <pre><code>print(dataset[0][\"tokens\"])\nprint(references[0])\nprint(predictions[0])\nprint(NER_TAGS_ONTOLOGY)\n</code></pre> <pre><code>['EU', 'rejects', 'German', 'call', 'to', 'boycott', 'British', 'lamb', '.']\n[3, 0, 7, 0, 0, 0, 7, 0, 0]\n[3, 0, 3, 0, 0, 0, 5, 7, 0]\n{'O': 0, 'B-PERSON': 1, 'I-PERSON': 2, 'B-ORGANIZATION': 3, 'I-ORGANIZATION': 4, 'B-LOCATION': 5, 'I-LOCATION': 6, 'B-MISCELLANEOUS': 7, 'I-MISCELLANEOUS': 8}\n</code></pre> <pre><code>def flatten_list(list_):\n    ret = []\n    for sublist in list_:\n        ret.extend(sublist)\n    return ret\n\n\nreferences = flatten_list(references)\npredictions = flatten_list(predictions)\nreferences = np.array(references)\npredictions = np.array(predictions)\n</code></pre> <pre><code>from sklearn.metrics import f1_score\n</code></pre> <p>We will use the F1 score to report the results.</p> <pre><code>table = Table(title=\"Results\")\n\ntable.add_column(\"Class\")\ntable.add_column(\"F1\")\ntable.add_column(\"Nb samples\", justify=\"center\")\n\nfor class_name, class_value in NER_TAGS_ONTOLOGY.items():\n    y_true = np.where(references == class_value, 1, 0)\n    y_pred = np.where(predictions == class_value, 1, 0)\n    table.add_row(\n        class_name,\n        f\"{f1_score(y_true, y_pred) * 100:6.1f}%\",\n        f\"{y_true.sum():3d}\",\n        end_section=True,\n    )\n\n# Group tokens regardless of their positions in the entities\nNER_TAGS_ONTOLOGY_GROUPED = {\n    \"PERSON\": (1, 2),\n    \"ORGANIZATION\": (3, 4),\n    \"LOCATION\": (5, 6),\n    \"MISCELLANEOUS\": (7, 8),\n}\nfor class_name, class_values in NER_TAGS_ONTOLOGY_GROUPED.items():\n    y_true = np.where((references == class_values[0]) | (references == class_values[1]), 1, 0)\n    y_pred = np.where((predictions == class_values[0]) | (predictions == class_values[1]), 1, 0)\n    table.add_row(\n        class_name,\n        f\"{f1_score(y_true, y_pred) * 100:6.1f}%\",\n        f\"{y_true.sum():3d}\",\n        style=\"bold green\",\n        end_section=True,\n    )\n\n\ntable.add_row(\n    \"All\",\n    f\"{f1_score(references, predictions, average='weighted') * 100:6.1f}%\",\n    f\"{len(references):3d}\",\n    style=\"bold bright_red\",\n)\n</code></pre> <pre><code>console = Console()\nconsole.print(table)\n</code></pre> <pre>                 Results                  \n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Class           \u2503 F1      \u2503 Nb samples \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 O               \u2502   93.4% \u2502    468     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 B-PERSON        \u2502   90.9% \u2502     12     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 I-PERSON        \u2502  100.0% \u2502     10     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 B-ORGANIZATION  \u2502   58.8% \u2502     12     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 I-ORGANIZATION  \u2502   44.4% \u2502      8     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 B-LOCATION      \u2502   71.4% \u2502     14     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 I-LOCATION      \u2502    0.0% \u2502      0     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 B-MISCELLANEOUS \u2502   10.3% \u2502     15     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 I-MISCELLANEOUS \u2502   31.2% \u2502      5     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 PERSON          \u2502   95.2% \u2502     22     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ORGANIZATION    \u2502   53.8% \u2502     20     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 LOCATION        \u2502   71.4% \u2502     14     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 MISCELLANEOUS   \u2502   19.7% \u2502     20     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 All             \u2502   88.6% \u2502    544     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</pre> <p>Quite good!</p> <p>As we can see, the pre-annotations are not perfect, but the LLM seems to be able to generate pre-annotations that are good enough to help us speed up the labelling process in future projects.</p>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#conclusion","title":"Conclusion","text":"<p>In this tutorial, we have seen how to use the OpenAI API to generate pre-annotations for a dataset. We have also seen how to import the data and the pre-annotations to a Kili project, and how to evaluate the quality of these pre-annotations.</p>"},{"location":"sdk/tutorials/ocr_pre_annotations/","title":"OCR Pre-annotations","text":""},{"location":"sdk/tutorials/ocr_pre_annotations/#how-to-import-ocr-pre-annotations","title":"How to import OCR pre-annotations","text":"<p>In this tutorial we will see how to import OCR pre-annotations in Kili using Google vision API.</p> <p>Pre-annotating your data with OCR will save you a lot of time when annotating transcriptions in Kili.</p> <p>The data that we use comes from The Street View Text Dataset.</p>"},{"location":"sdk/tutorials/ocr_pre_annotations/#loading-an-image-from-the-street-view-dataset-in-kili","title":"Loading an image from The Street View Dataset in Kili","text":"<p>Follow this link to get the image for this tutorial:</p> <p></p> <p>We will use the Google Vision API to perform Optical Character Recognition on the different inscriptions in this image.</p> <p>To use the google API, we need to install some packages:</p> <pre><code>%pip install google-cloud google-cloud-vision Pillow kili google-cloud-storage wget\n</code></pre> <pre><code>import json\nimport os\n\nimport wget\nfrom google.cloud import vision\nfrom google.oauth2 import service_account\nfrom PIL import Image\n\nfrom kili.client import Kili\n</code></pre> <p>We can now create the project ontology (json interface).</p> <p>For a transcription task on images, the ontology is a classification job with nested transcriptions for each category:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {  # this job is for annotating the bounding boxes\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"tools\": [\"rectangle\"],\n            \"instruction\": \"Categories\",\n            \"required\": 1,\n            \"isChild\": False,\n            \"content\": {\n                \"categories\": {\n                    \"STORE_INFORMATIONS\": {\"name\": \"Store informations\", \"children\": [\"JOB_1\"]},\n                    \"PRODUCTS\": {\"name\": \"Products\", \"children\": [\"JOB_2\"]},\n                },\n                \"input\": \"radio\",\n            },\n        },\n        \"JOB_1\": {\n            \"mlTask\": \"TRANSCRIPTION\",\n            \"instruction\": \"Transcription of store informations\",\n            \"required\": 1,\n            \"isChild\": True,\n        },\n        \"JOB_2\": {\n            \"mlTask\": \"TRANSCRIPTION\",\n            \"instruction\": \"Transcription of products\",\n            \"required\": 1,\n            \"isChild\": True,\n        },\n    }\n}\n</code></pre> <p>Let's initialize the Kili client and create our project:</p> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre> <pre><code># Create an OCR project\nproject = kili.create_project(\n    description=\"OCR street view\",\n    input_type=\"IMAGE\",\n    json_interface=json_interface,\n    title=\"[Kili SDK Notebook]: Street text OCR annotation project\",\n)\nproject_id = project[\"id\"]\n</code></pre>"},{"location":"sdk/tutorials/ocr_pre_annotations/#creating-ocr-annotations-using-google-vision-api","title":"Creating OCR annotations using Google Vision API","text":"<p>We will now see how to perform OCR preannotation on our image using Google Vision API.</p> <p>First you will need to create an account on Google Cloud:</p> <ol> <li>create a project (or use an existing one)</li> <li>then go to the Cloud Vision API page</li> <li>activate the API for your project</li> </ol> <p>Now that the API is activated we will need to get a secret key in order to call the API later in our project:</p> <ol> <li>go to API and services page</li> <li>and create a service account with authorization to use the vision API</li> </ol> <p>On the service account details page:</p> <ol> <li>click on add a key</li> <li>download the key using json format</li> <li>place the key in your environment variables or in a file</li> </ol> <pre><code>google_key_str = os.getenv(\"KILI_API_CLOUD_VISION\")\n\nif not google_key_str:\n    path_to_json_key = \"./google_cloud_key.json\"\n    with open(path_to_json_key) as file:\n        google_key_str = file.read()\n\nGOOGLE_KEY = json.loads(google_key_str)\n\nassert GOOGLE_KEY\n</code></pre> <p>We can now start adding OCR pre-annotations to the asset metadata:</p> <pre><code>def implicit():\n    from google.cloud import storage\n\n    # If you don't specify credentials when constructing the client, the\n    # client library will look for credentials in the environment.\n    storage_client = storage.Client()\n\n    # Make an authenticated API request\n    buckets = list(storage_client.list_buckets())\n    print(buckets)\n</code></pre> <pre><code>def detect_text(path):\n    \"\"\"Detects text in the file.\"\"\"\n    credentials = service_account.Credentials.from_service_account_info(GOOGLE_KEY)\n    client = vision.ImageAnnotatorClient(credentials=credentials)\n\n    with open(path, \"rb\") as image_file:\n        content = image_file.read()\n\n    response = client.text_detection({\"content\": content})\n    texts = response._pb.text_annotations\n    text_annotations = []\n\n    for text in texts:\n        vertices = [{\"x\": vertex.x, \"y\": vertex.y} for vertex in text.bounding_poly.vertices]\n\n        tmp = {\n            \"description\": text.description,\n            \"boundingPoly\": {\n                \"vertices\": vertices,\n            },\n        }\n\n        text_annotations.append(tmp)\n\n    if response.error.message:\n        raise Exception(\n            f\"{response.error.message}\\nFor more info on error messages, check: \"\n            \"https://cloud.google.com/apis/design/errors\"\n        )\n\n    return text_annotations\n</code></pre> <pre><code>PATH_TO_IMG = wget.download(\n    \"https://raw.githubusercontent.com/kili-technology/kili-python-sdk/main/recipes/img/store_front.jpeg\"\n)\n</code></pre> <pre><code>text_annotations = detect_text(PATH_TO_IMG)\nassert len(text_annotations) &gt; 0\nprint(f\"Found {len(text_annotations)} boxes of text.\")\nprint(text_annotations[0])\n</code></pre> <pre><code>Found 22 boxes of text.\n{'description': \"CD\\nITALIAN $1\\nESPRESSO Shot\\nplus tax\\nFINE ITALIAN\\nIMPORTS &amp; DELI\\nJIM\\nIMMY'S FRESH MEATS\\nSAUSAGES\\nFOOD STORE\\nIX\", 'boundingPoly': {'vertices': [{'x': 24, 'y': 6}, {'x': 1668, 'y': 6}, {'x': 1668, 'y': 553}, {'x': 24, 'y': 553}]}}\n</code></pre> <pre><code>im = Image.open(PATH_TO_IMG)\nIMG_WIDTH, IMG_HEIGHT = im.size\nprint(im.size)\n</code></pre> <pre><code>(1680, 1050)\n</code></pre> <p>We now need to convert the OCR predictions to the Kili asset metadata format:</p> <pre><code>full_text_annotations = {\n    \"fullTextAnnotation\": {\n        \"pages\": [{\"height\": IMG_HEIGHT, \"width\": IMG_WIDTH}],\n    },\n    \"textAnnotations\": text_annotations,\n}\n</code></pre> <p>We follow the Google Vision API <code>AnnotateImageResponse</code> format. So in the end, the OCR data to insert into Kili as a JSON metadata contains:</p> <ul> <li>Full text annotation. A list of pages in the document with their respective heights and widths.</li> <li>A list of text annotations with:<ul> <li>text content</li> <li>bounding box coordinates.</li> </ul> </li> </ul> <pre><code>{\n  \"fullTextAnnotation\": { \"pages\": [{ \"height\": 914, \"width\": 813 }] },\n  \"textAnnotations\": [\n    {\n      \"description\": \"7SB75\",\n      \"boundingPoly\": {\n        \"vertices\": [\n          { \"x\": 536, \"y\": 259 },\n          { \"x\": 529, \"y\": 514 },\n          { \"x\": 449, \"y\": 512 },\n          { \"x\": 456, \"y\": 257 }\n        ]\n      }\n    },\n    {\n      \"description\": \"09TGG\",\n      \"boundingPoly\": {\n        \"vertices\": [\n          { \"x\": 436, \"y\": 256 },\n          { \"x\": 435, \"y\": 515 },\n          { \"x\": 360, \"y\": 515 },\n          { \"x\": 361, \"y\": 256 }\n        ]\n      }\n    }\n  ]\n}\n</code></pre> <p>Let's upload the asset with its pre-annotations to Kili:</p> <pre><code>external_id = \"store\"\ncontent = PATH_TO_IMG\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[content],\n    external_id_array=[external_id],\n    json_metadata_array=[full_text_annotations],\n)\n</code></pre>"},{"location":"sdk/tutorials/ocr_pre_annotations/#annotate-in-kili","title":"Annotate in Kili","text":"<p>You can now annotate your images and you will see the text automatically extracted:</p> <p></p> <p>Congrats! \ud83d\udc4f</p> <p>Pre-annotating your assets can save you a significant amount of time and improve the accuracy of your labeling \u23f3\ud83c\udfaf.</p>"},{"location":"sdk/tutorials/ocr_pre_annotations/#cleanup","title":"Cleanup","text":"<p>To clean up, we simply need to remove the project that we created:</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/pixel_level_masks/","title":"Segmentation Pre-annotations","text":""},{"location":"sdk/tutorials/pixel_level_masks/#how-to-import-segmentation-pre-annotations","title":"How to import segmentation pre-annotations","text":"<p>In this tutorial, we will show you how to import prediction labels into your Kili project.</p> <p>You will see these predictions as pre-annotations in your labeling interface, and you will be able to modify or validate them.</p> <p>We will discover this feature on a segmentation project that is used to work with images or videos with pixel-level annotations.</p> <p>The data used in this tutorial is from the COCO dataset.</p>"},{"location":"sdk/tutorials/pixel_level_masks/#import-an-image-into-your-kili-project","title":"Import an image into your Kili project","text":"<p>Let's first inspect what our annotated image looks like in the COCO dataset.</p> Raw image With the annotations <p>Before starting, we install the requirements:</p> <pre><code>%pip install matplotlib Pillow kili opencv-python\n</code></pre> <pre><code>%matplotlib inline\n\nimport urllib.request\nfrom random import randint\n\nimport cv2\nimport matplotlib.pyplot as plt\n\nfrom kili.client import Kili\n</code></pre> <p>Let's authenticate to Kili:</p> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre> <p>Let's create an image project in Kili where we can annotate images with a <code>semantic</code> tool and two classes: <code>HUMAN</code> and <code>MOTORCYCLE</code> at pixel level.</p> <p>We create the image project with its ontology (json_interface):</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"tools\": [\"semantic\"],\n            \"instruction\": None,\n            \"required\": 1,\n            \"isChild\": False,\n            \"content\": {\n                \"categories\": {\n                    \"MOTORCYCLE\": {\"name\": \"Motorcycle\", \"children\": [], \"color\": \"#0755FF\"},\n                    \"HUMAN\": {\"name\": \"Human\", \"children\": [], \"color\": \"#EEBA00\"},\n                },\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\n</code></pre> <pre><code>project = kili.create_project(\n    description=\"COCO dataset\",\n    input_type=\"IMAGE\",\n    json_interface=json_interface,\n    title=\"[Kili SDK Notebook]: Motorcycle annotation segmentation project\",\n)\n\nproject_id = project[\"id\"]\n</code></pre> <p>Then, we upload the image to the project:</p> <pre><code>external_id = \"moto\"\ncontent = \"https://farm7.staticflickr.com/6153/6181981748_6a225c275d_z.jpg\"\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[content],\n    external_id_array=[external_id],\n    json_content_array=None,\n)\n</code></pre> <p>You should now be able to visualize your asset in Kili:</p> <p></p>"},{"location":"sdk/tutorials/pixel_level_masks/#import-annotations-from-a-mask","title":"Import annotations from a mask","text":"<p>Now, imagine you already have your annotation stored as a mask. You want to insert it in Kili Technology as a prediction. Here is what the mask looks like:</p> <p></p> <p>We can start by downloading the image on disk:</p> <pre><code>mask_url = \"https://raw.githubusercontent.com/kili-technology/kili-python-sdk/main/recipes/img/HUMAN.mask.png\"\nurllib.request.urlretrieve(mask_url, \"mask.png\")\n</code></pre> <p>Kili SDK provides a set of utils to easily create labels. See the documentation for more information.</p> <p>Now, we will use the <code>mask_to_normalized_vertices</code> helper method to create a segmentation label from the mask image.</p> <pre><code>from kili.utils.labels.image import mask_to_normalized_vertices\n</code></pre> <pre><code>mask = cv2.imread(\"mask.png\")[:, :, 0]\ncontours, _ = mask_to_normalized_vertices(mask)\nprint(f\"Found {len(contours)} contour(s) in the mask.\")\n</code></pre> <pre><code>Found 1 contour(s) in the mask.\n</code></pre> <pre><code>annotations = [\n    {\n        \"boundingPoly\": [{\"normalizedVertices\": contour} for contour in contours],\n        \"categories\": [{\"name\": \"HUMAN\", \"confidence\": 100}],\n        \"mid\": str(randint(100, 1000)),\n        \"score\": None,\n        \"type\": \"semantic\",\n    }\n]\njson_response = {\"JOB_0\": {\"annotations\": annotations}}\n</code></pre> <pre><code>kili.create_predictions(\n    project_id=project_id,\n    external_id_array=[external_id],\n    json_response_array=[json_response],\n    model_name=\"original_mask\",\n)\n</code></pre> <pre><code>{'id': 'clfql5ikf01zz0jsxaxohccnx'}\n</code></pre> <p>That's it! Your mask was just converted to Kili Technology's standard format and uploaded as a prediction to the platform:</p> <p></p>"},{"location":"sdk/tutorials/pixel_level_masks/#export-the-annotations-as-a-mask","title":"Export the annotations as a mask","text":"<p>You may want to do the reverse operation, that is download the existing annotation from Kili and convert it to a mask.</p> <p>Let's see how you can achieve this using the helper method <code>normalized_vertices_to_mask</code>!</p> <pre><code>from kili.utils.labels.image import normalized_vertices_to_mask\n</code></pre> <p>Then, we can retrieve the json response and plot the mask:</p> <pre><code>labels = kili.labels(\n    project_id=project_id, asset_external_id_in=[external_id], fields=[\"jsonResponse\"]\n)\nlabel = labels[0]\njson_response = label[\"jsonResponse\"]\nreconstructed_mask = normalized_vertices_to_mask(\n    json_response[\"JOB_0\"][\"annotations\"][0][\"boundingPoly\"][0][\"normalizedVertices\"],\n    mask.shape[1],\n    mask.shape[0],\n)\n\nplt.title(\"Mask for HUMAN class\")\nplt.imshow(reconstructed_mask, cmap=\"gray\")\nplt.show()\n</code></pre> <p></p>"},{"location":"sdk/tutorials/pixel_level_masks/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/pixel_level_masks/#conclusion","title":"Conclusion","text":"<p>You can now try uploading your own predictions using <code>kili.create_predictions()</code>!</p>"},{"location":"sdk/tutorials/plugins_development/","title":"Developing Plugins","text":""},{"location":"sdk/tutorials/plugins_development/#how-to-develop-and-test-a-kili-plugin","title":"How to develop and test a Kili plugin","text":""},{"location":"sdk/tutorials/plugins_development/#preliminary","title":"Preliminary","text":"<p>This notebook will teach you how to build your first plugin.</p> <p>A plugin is an uploaded Python script triggered by an event that you define.</p> <p>For instance, you can trigger a plugin when a labeler clicks on Submit with the <code>on_submit</code> handler.</p> <p>The plugin should have different methods for the different types of events:</p> <ul> <li><code>on_submit</code></li> <li><code>on_review</code></li> </ul> <p>These methods have a predefined set of parameters:</p> <ul> <li>the <code>label</code> submitted</li> <li>the <code>asset_id</code> of the asset labeled</li> </ul> <p>Some attributes are available in the class:</p> <ul> <li><code>self.kili</code></li> <li><code>self.project_id</code></li> </ul> <p>Therefore, the skeleton of the plugin should look like this:</p> <pre><code>from kili.plugins import PluginCore\nfrom typing import Dict\nimport numpy as np\n\nclass PluginHandler(PluginCore):\n    \"\"\"Custom plugin\"\"\"\n\n    def on_review(self, label: Dict, asset_id: str) -&gt; None:\n        \"\"\"Dedicated handler for Review action\"\"\"\n        # Do something...\n\n    def on_submit(self, label: Dict, asset_id: str) -&gt; None:\n        \"\"\"Dedicated handler for Submit action\"\"\"\n        # Do something...\n</code></pre> <p>Do not hesitate to reach out to us if you need more.</p> <p>NB: The plugin capabilities of Kili are under active development, and compatible with version 2.125.2 and later of Kili. Don't hesitate to reach out via Github or Kili support to provide feedback.</p>"},{"location":"sdk/tutorials/plugins_development/#instantiate-kili","title":"Instantiate Kili","text":"<pre><code>%pip install  kili\n</code></pre> <pre><code>%load_ext autoreload\n%autoreload 2\n\n\nfrom kili.client import Kili\n\nkili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#develop-your-plugin","title":"Develop your plugin","text":"<p>The first step is to define the functions that will be called when the event is triggered. You will be able to iterate on these functions locally (more on that in the next section).</p> <p>The plugin can be defined in two ways: a single <code>.py</code> file with everything inside or a module (folder containing multiple <code>.py</code> files). In the case of the module type, a file named <code>main.py</code> needs to be at the root of the folder and will serve as the entrypoint.</p>"},{"location":"sdk/tutorials/plugins_development/#1-first-option-plugin-defined-in-a-single-file","title":"1. First option - Plugin defined in a single file","text":"<p>This cell should be the contents of the <code>.py</code> file that you will upload as a plugin at the end.</p> <p>This file should define the <code>PluginHandler</code> class that will contain the proper methods.</p> <p>We recommend using a modern IDE like VScode to get type hints and autocompletion on the methods.</p> <pre><code>from typing import Dict\n\nimport numpy as np\n\nfrom kili.plugins import PluginCore\n\n\ndef custom_function(label: Dict):\n    label_id = label.get(\"id\")\n    print(f\"My custom function for review of label with id {label_id}\")\n\n\nclass PluginHandler(PluginCore):\n    \"\"\"Custom plugin instance\"\"\"\n\n    def custom_method(self, project_id, label_id):\n        print(f\"custom_method called for label {label_id}\")\n        random_seed = np.random.random(1)[0]\n        if random_seed &gt; 0.5:\n            self.logger.warning(\"Generating issue\")\n            # Use kili for actions with self.kili\n            self.kili.create_issues(\n                project_id=project_id,\n                label_id_array=[label_id],\n                text_array=[\"Random issue generated for this label\"],\n            )\n\n    def on_review(self, label: Dict, asset_id: str) -&gt; None:\n        \"\"\"Dedicated handler for Review action\"\"\"\n        custom_function(label)\n\n    def on_submit(self, label: Dict, asset_id: str) -&gt; None:\n        \"\"\"Dedicated handler for Submit action\"\"\"\n        print(\"On submit called\")\n\n        project_id = self.project_id\n        label_id = label.get(\"id\")\n\n        self.custom_method(project_id, label_id)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#2-second-option-plugin-defined-in-a-folder","title":"2. Second option - Plugin defined in a folder","text":"<p>As said previously, the structure of the folder can be the following (the only constraint being the presence of the <code>main.py</code> file): <pre><code>plugin_folder\n|__ main.py\n|__ other_file.py\n|__ requirements.txt\n|\n|___helpers\n    |__ helper.py\n</code></pre></p> <p>You can notice that you can also include a <code>requirements.txt</code> file in the folder and the necessary packages will be installed with your plugin. Don't forget to add them, since the plugin could work on your machine if you have them installed, but it won't be possible to create the plugin if there are missing dependencies.</p> <p>Note: The <code>requirements.txt</code> file can only be included for the SaaS version of the Kili platform, for on-premise deployments there is a pre-defined list of packages that can be used. For more details, see the documentation of plugins</p> <p>Important: The main.py file need to have the same skeleton as the plugin defined in a single file (presence of the class <code>PluginHandler</code>), the difference being that it can import and call functions defined in other files</p> <p>Depending on where the folder is stored, there are two ways to import the plugin in order to test it:</p> <ul> <li>The first way is to use a relative import (having the plugin folder and the notebook in the same folder). It is simpler and we recommend it as it will also allow the IDE to detect the correct methods and propose hints and autocompletion.</li> <li>The second is to use an absolute path to the plugin folder</li> </ul>"},{"location":"sdk/tutorials/plugins_development/#21-relative-import","title":"2.1 Relative import","text":"<pre><code># Here replace 'plugin_folder' with the actual name of the folder\nfrom plugin_folder.main import PluginHandler\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#22-absolute-path-import","title":"2.2 Absolute path import","text":"<pre><code>import sys\nfrom pathlib import Path\n\n# Input the path to the plugin folder (it should include the folder), for example '/path/to/plugin_folder'\nplugin_path = \"&lt;INSERT PATH TO PLUGIN FOLDER&gt;\"\n\nmodule_path = str(Path(plugin_path).parent.absolute())\n\n# We are inserting the path in the system PATH to be able to import the module in the next line\nsys.path.insert(0, module_path)\n\n# In the next line replace 'plugin_folder' with the actual name of the folder\nfrom plugin_folder.main import PluginHandler\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#testing-the-plugin-locally","title":"Testing the plugin locally","text":"<p>In this we will show you how to test your plugin locally before uploading it.</p> <pre><code>project_id = \"&lt;PROJECT ID&gt;\"\n</code></pre> <p>Instantiate the plugin:</p> <pre><code>my_plugin_instance = PluginHandler(kili, project_id)\n\n\ndef get_label(label_id, project_id):\n    \"\"\"Function to get the object Label with the same keys as it will be in the plugin\"\"\"\n    label = list(\n        kili.labels(\n            project_id=project_id,\n            label_id=label_id,\n            fields=[\"id\", \"jsonResponse\", \"author.id\", \"labelType\", \"createdAt\", \"secondsToLabel\"],\n        )\n    )[0]\n\n    label[\"authorId\"] = label[\"author\"][\"id\"]\n    del label[\"author\"]\n    return label\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#test-the-plugin-run","title":"Test the plugin run","text":"<p>If you already have a test project with labels added, you can directly use the IDs of these labels (see the following cell). Otherwise, you can follow the plugins_example.ipynb notebook to create a new project and then upload an asset with an associated label.</p> <pre><code>asset_id = \"&lt;YOUR_ASSET_ID&gt;\"\nlabel_id = \"&lt;YOUR_LABEL_ID&gt;\"\n</code></pre> <pre><code>label = get_label(label_id=label_id, project_id=project_id)\n\nmy_plugin_instance.on_submit(label=label, asset_id=asset_id)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#test-the-plugin-run-on-kili","title":"Test the plugin run on Kili","text":"<p>When you finish debugging the code, you may want to upload it directly into Kili.</p> <p>Note that you might get an error if the plugin name already exists in your Kili organization.</p> <pre><code>path_to_plugin = \"path/to/my/plugin.py\"\nplugin_name = \"My first kili plugin\"\n</code></pre> <pre><code>from kili.exceptions import GraphQLError\n\ntry:\n    kili.upload_plugin(path_to_plugin, plugin_name)\nexcept GraphQLError as error:\n    print(str(error))\n</code></pre> <p>Plugins must be activated in the project that you want them to run in. Be careful with production projects: your custom workflows or rules will also be applied</p> <pre><code>kili.activate_plugin_on_project(plugin_name, project_id=project_id)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#monitoring-the-plugin","title":"Monitoring the plugin","text":"<p>Plugin creation takes some time (around 5 minutes). The plugin will begin to run only after it's been fully created (if labeling events are to be triggered on this project).</p> <p>Additionally, you can get the logs of the runs:</p> <pre><code>kili.get_plugin_logs(project_id=project_id, plugin_name=plugin_name)\n</code></pre> <p>You can set custom date rules for filtering your logs:</p> <pre><code>from datetime import date, datetime\n\ndt = date.today()  # You can change this date if needed\nstart_date = datetime.combine(dt, datetime.min.time())\n\nkili.get_plugin_logs(project_id=project_id, plugin_name=plugin_name, start_date=start_date)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#managing-your-plugin","title":"Managing your plugin","text":"<p>There are several other methods to manage your plugins and their lifecycle. To find out more, check the plugins tutorials.</p>"},{"location":"sdk/tutorials/plugins_example/","title":"Plugin Example - Programmatic QA","text":""},{"location":"sdk/tutorials/plugins_example/#how-to-create-a-plugin-for-programmatic-qa","title":"How to create a plugin for programmatic QA","text":""},{"location":"sdk/tutorials/plugins_example/#context","title":"Context","text":"<p>This notebook is an end-to-end example that you can follow to: create a project, upload a first plugin and activate it on this project, and finally start monitoring it.</p> <p>NB: The plugin capabilities of Kili are under active development, and compatible with version 2.125.2 and later of Kili. Don't hesitate to reach out via Github or the Kili support to provide feedback.</p>"},{"location":"sdk/tutorials/plugins_example/#step-1-instantiate-kili","title":"Step 1: Instantiate Kili","text":"<pre><code>%pip install kili\n</code></pre> <pre><code>from kili.client import Kili\n\nkili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-2-create-the-project","title":"Step 2: Create the project","text":"<p>First, we need to create a new project. In our example, we will use an <code>IMAGE</code> type project with the following <code>jsonInterace</code>:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"content\": {\n                \"categories\": {\n                    \"OBJECT_A\": {\n                        \"children\": [],\n                        \"name\": \"Object A\",\n                        \"color\": \"#733AFB\",\n                        \"id\": \"category1\",\n                    },\n                    \"OBJECT_B\": {\n                        \"children\": [],\n                        \"name\": \"Object B\",\n                        \"color\": \"#3CD876\",\n                        \"id\": \"category2\",\n                    },\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Categories\",\n            \"isChild\": False,\n            \"tools\": [\"rectangle\"],\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"models\": {},\n            \"isVisible\": True,\n            \"required\": 1,\n            \"isNew\": False,\n        }\n    }\n}\n</code></pre> <pre><code>title = \"[Kili SDK Notebook]: Plugins test project\"\ndescription = \"My first project with a plugin\"\ninput_type = \"IMAGE\"\n\nproject = kili.create_project(\n    title=title, description=description, input_type=input_type, json_interface=json_interface\n)\nproject_id = project[\"id\"]\n\nprint(f\"Created project {project_id}\")\n</code></pre> <p>Upload an asset:</p> <pre><code>content_array = [\"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\"]\nnames_array = [\"landscape\"]\n\nkili.append_many_to_dataset(\n    project_id=project_id, content_array=content_array, external_id_array=names_array\n)\n\nasset_id = kili.assets(project_id=project_id, fields=[\"id\"], disable_tqdm=True)[0][\"id\"]\n</code></pre> <p>This project has one job of bounding box creation with two categories.</p> <p>With our plugin, we want to make sure that the labelers don't create more than one bounding box of category A.</p> <p>To iterate on the plugin code, you can refer to the plugins_development.ipynb notebook.</p>"},{"location":"sdk/tutorials/plugins_example/#step-3-write-the-plugin","title":"Step 3: Write the plugin","text":"<pre><code>from kili.plugins import PluginCore\nfrom typing import Dict, List, Optional\n\ndef check_rules_on_label(label: Dict) -&gt; List[Optional[str]]:\n    #custom methods\n    print('Custom method - checking number of bboxes')\n\n    counter = 0\n    for annotation in label['jsonResponse'][\"JOB_0\"][\"annotations\"]:\n        if annotation[\"categories\"][0][\"name\"] == \"OBJECT_A\":\n            counter += 1\n\n    if counter &lt;= 1:\n        return []\n    return [f\"There are too many BBox ({counter}) - Only 1 BBox of Object A accepted\"]\n\n\nclass PluginHandler(PluginCore):\n    \"\"\"\n    Custom plugin instance\n    \"\"\"\n\n    def on_submit(self, label: Dict, asset_id: str) -&gt; None:\n        \"\"\"\n        Dedicated handler for Submit action\n        \"\"\"\n        self.logger.info(\"On submit called\")\n\n        issues_array = check_rules_on_label(label)\n\n        project_id = self.project_id\n\n        if len(issues_array) &gt; 0:\n            print(\"Creating an issue...\")\n\n            self.kili.create_issues(\n                project_id=project_id,\n                label_id_array=[label['id']] * len(issues_array),\n                text_array=issues_array,\n            )\n\n            print(\"Issue created!\")\n\n            self.kili.send_back_to_queue(asset_ids=[asset_id])\n</code></pre> <pre><code>import urllib.request\nfrom pathlib import Path\n\nplugin_folder = \"plugin_folder\"\n\nPath(plugin_folder).mkdir(parents=True, exist_ok=True)\nurllib.request.urlretrieve(\n    \"https://raw.githubusercontent.com/kili-technology/kili-python-sdk/main/recipes/plugins_library/plugin_image.py\",\n    \"plugin_folder/main.py\",\n)\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-4-upload-the-plugin-from-a-folder","title":"Step 4: Upload the plugin from a folder","text":"<p>With the plugin defined in a separate <code>Python</code> file, you can create a folder containing:</p> <ul> <li>A <code>main.py</code> file which is the entrypoint of the plugin and must have a <code>PluginHandler</code> class which implements a <code>PluginCore</code> class</li> <li>(optionally) a <code>requirements.txt</code> (if you need specific PyPi packages in your plugin)</li> </ul> <p>Note: The <code>requirements.txt</code> file can only be included for the SaaS version of the Kili platform, for on-premise deployments there is a pre-defined list of packages that can be used. For more details, see the documentation of plugins</p> <pre><code>folder/\n     main.py\n     requirements.txt\n</code></pre> <ul> <li>The upload will create the necessary builds to execute the plugin (it will take a few minutes)</li> <li>After the activation, you can start using your plugin right away.</li> </ul> <p>Here is an example of a <code>requirements.txt</code> file: numpy scikit-learn pandas==1.5.1 git+https://github.com/yzhao062/pyod.git</p> <pre><code>requirements_path = Path(plugin_folder) / \"requirements.txt\"\n\npackages_list = [\n    \"numpy\\n\",\n    \"scikit-learn\\n\",\n    \"pandas==1.5.1\\n\",\n    \"git+https://github.com/yzhao062/pyod.git\\n\",\n]\n\nwith requirements_path.open(\"w\") as f:\n    f.writelines(packages_list)\n</code></pre> <pre><code>plugin_name = \"Plugin bbox count\"\nfrom kili.exceptions import GraphQLError\n\ntry:\n    kili.upload_plugin(plugin_folder, plugin_name)\nexcept GraphQLError as error:\n    print(str(error))\n</code></pre> <pre><code>kili.activate_plugin_on_project(plugin_name=plugin_name, project_id=project_id)\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-4-bis-upload-the-plugin-from-a-py-file","title":"Step 4 bis: Upload the plugin from a .py file","text":"<p>Alternatively, you can also create a plugin directly from a <code>.py</code> file.</p> <ul> <li>The upload will create the necessary builds to execute the plugin (it will take a few minutes)</li> <li>After the activation, you can start using your plugin right away.</li> </ul> <pre><code>path_to_plugin = Path(plugin_folder) / \"main.py\"\nplugin_name_file = \"Plugin bbox count - file\"\n\ntry:\n    kili.upload_plugin(str(path_to_plugin), plugin_name_file)\nexcept GraphQLError as error:\n    print(str(error))\n</code></pre> <pre><code>kili.activate_plugin_on_project(plugin_name=plugin_name_file, project_id=project_id)\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-5-plugin-in-action","title":"Step 5: Plugin in action","text":"<p>Wait for the plugin to be successfully deployed.</p> <p>After that, you can test it by labelling in the Kili interface or just by uploading the following label.</p> <p>When you add the label that contains errors, you will see a new issue automatically created in the Kili app.</p> <pre><code>json_response = {\n    \"JOB_0\": {\n        \"annotations\": [\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.15, \"y\": 0.84},\n                            {\"x\": 0.15, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.84},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161451411-13314\",\n                \"type\": \"rectangle\",\n            },\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.79, \"y\": 0.20},\n                            {\"x\": 0.79, \"y\": 0.13},\n                            {\"x\": 0.91, \"y\": 0.13},\n                            {\"x\": 0.91, \"y\": 0.20},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161456406-47055\",\n                \"type\": \"rectangle\",\n            },\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.87, \"y\": 0.36},\n                            {\"x\": 0.87, \"y\": 0.27},\n                            {\"x\": 0.99, \"y\": 0.27},\n                            {\"x\": 0.99, \"y\": 0.36},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161459298-45160\",\n                \"type\": \"rectangle\",\n            },\n        ]\n    }\n}\n</code></pre> <pre><code>kili.append_labels(\n    json_response_array=[json_response], asset_id_array=[asset_id], label_type=\"DEFAULT\"\n)\n</code></pre> <p>If you use the base plugin provided, the plugin should:</p> <ul> <li>Create an issue with information that three bboxes were found, instead of one</li> <li>Send the asset back to the labeling queue (status <code>ONGOING</code>)</li> </ul> <pre><code>print(\n    kili.assets(project_id=project_id, asset_id=asset_id, fields=[\"status\", \"issues.comments.text\"])\n)\n\nprint(\n    f\"Go to my project: {kili.api_endpoint.split('/api')[0]}/label/projects/{project_id}/menu/queue\"\n)\n</code></pre> <p>Woah! Amazing! Well done :) \ud83d\ude80</p> <p>Let's test now to post a proper label, this one for example:</p> <pre><code>json_response = {\n    \"JOB_0\": {\n        \"annotations\": [\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.15, \"y\": 0.84},\n                            {\"x\": 0.15, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.84},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161451411-13314\",\n                \"type\": \"rectangle\",\n            }\n        ]\n    }\n}\nkili.append_labels(\n    json_response_array=[json_response], asset_id_array=[asset_id], label_type=\"DEFAULT\"\n)\n\nprint(kili.assets(project_id=project_id, asset_id=asset_id, fields=[\"status\"]))\n\nprint(\n    f\"Go to my project: {kili.api_endpoint.split('/api')[0]}/label/projects/{project_id}/menu/queue\"\n)\n</code></pre> <p>The status of your asset should have now changed to <code>LABELED</code>. In this plugin, previous issues remain but you can solve them through the API as well.</p> <p>Well done! You can now iterate on the script. To learn how to avoid latency when building and deploying your plugin, refer to the plugins development tutorial.</p>"},{"location":"sdk/tutorials/plugins_example/#step-6-monitor-the-plugin","title":"Step 6: Monitor the plugin","text":"<p>To monitor a certain plugin, you can get its logs by using the following command:</p> <pre><code>import json\nfrom datetime import date, datetime\n\ndt = (\n    date.today()\n)  # You can change this date if needed, or omit it to set it at the plugin creation date\nstart_date = datetime.combine(dt, datetime.min.time())\n\nlogs = kili.get_plugin_logs(project_id=project_id, plugin_name=plugin_name, start_date=start_date)\n\nlogs_json = json.loads(logs)\nprint(json.dumps(logs_json, indent=4))\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-7-manage-the-plugin","title":"Step 7: Manage the plugin","text":"<p>You also have several other methods to manage your plugins.</p> <p>Get the list of all uploaded plugins in your organization:</p> <pre><code>plugins = kili.list_plugins()\n</code></pre> <p>Update a plugin with new source code:</p> <pre><code># Insert the path to the updated plugin\nnew_path_to_plugin = Path(plugin_folder) / \"main.py\"\n\n# Change to True if you want to update the plugin\nshould_update = False\n\nif should_update:\n    kili.update_plugin(plugin_name=plugin_name, plugin_path=str(new_path_to_plugin))\n</code></pre> <p>Deactivate the plugin on a certain project (the plugin can still be active for other projects):</p> <pre><code>kili.deactivate_plugin_on_project(plugin_name=plugin_name, project_id=project_id)\n</code></pre> <p>Delete the plugin completely (deactivates the plugin from all projects):</p> <pre><code>if delete_plugin_from_org:\n    kili.delete_plugin(plugin_name=plugin_name)\n</code></pre>"},{"location":"sdk/tutorials/plugins_library/","title":"Plugins library","text":""},{"location":"sdk/tutorials/plugins_library/#context","title":"Context","text":"<p>In this section you can find multiple examples of use-cases where our system of plugins can help you in the Kili projects.</p> <p>You can also refer to our tutorial to develop your plugin and iterate on it locally, before uploading the final version to Kili.</p> <p>For further information concerning the Kili plugins, refer to the Reference page</p>"},{"location":"sdk/tutorials/plugins_library/#library-of-pre-built-plugins","title":"Library of pre-built plugins","text":"<p>In the folder <code>plugins_library</code> you can find multiple examples of plugins that are ready to use in your projects. They can be split in various use-cases:</p>"},{"location":"sdk/tutorials/plugins_library/#1-programmatic-qa","title":"1. Programmatic QA","text":"<p>One application of plugins is to automate your quality checks: you can directly write your business rules in a Python script and upload them to Kili to have each new label automatically checked.</p>"},{"location":"sdk/tutorials/plugins_library/#11-image-object-detection-example","title":"1.1 Image Object Detection example","text":"<p>Let's imagine a project where we want to process images and detect some objects. One of the jobs is to detect an object and we are sure that in any image of the dataset we can have at most a single object of that type. In order to be sure that we will have only one object in all submitted labels, we can create a plugin that, in case a label has 2 BBoxes for that type of objects, will automatically create an issue with a clear instruction and will send the label back to the queue.</p> <ul> <li>Plugin file: <code>plugin_image.py</code></li> <li>End-to-end notebook showcasing this example: <code>plugins_example.ipynb</code></li> </ul>"},{"location":"sdk/tutorials/plugins_library/#12-document-processing-example","title":"1.2 Document processing example","text":"<p>Let's imagine another project where we process invoices. The project has two jobs and several transcription tasks associated with them. One of the jobs is about payment information and must contain a proper IBAN number as well as currency. The IBAN must start with FR, and the currency should be one of: EURO or DOLLAR. Kili's interface customization options are powerful and flexible, but won't help us in this specific situation so we have to turn to Kili plugins for help. We'll set up our Kili plugin to check these two rules when labelers click Submit. If the annotations don't match our predefined rules, our QA bot will add issues to the asset and send the asset back to the labeling queue. At the end, our script will calculate labeling accuracy and insert the accuracy metric in the json_metadata of the asset. All that with no need to engage a human reviewer.</p> <ul> <li>Plugin file: <code>plugin_document.py</code></li> <li>End-to-end notebook showcasing this example: <code>plugins_example_document.ipynb</code></li> </ul>"},{"location":"sdk/tutorials/plugins_library/#2-consensus-resolution","title":"2. Consensus resolution","text":"<p>When working with consensus for object detection tasks, it is often handy for a reviewer to access the annotations of all the labelers involved, compare them and choose the best one. With Kili plugins, this task will be much simpler.</p> <p>For example: you can program your plugin to create an additional annotation that combines the annotations created by all the labelers. This way, you can instantaneously get a big-picture overview and only act when the situation calls for it. In large projects, this can save you a significant amount of time.</p> <ul> <li>Plugin file: <code>plugin_consensus.py</code></li> </ul>"},{"location":"sdk/tutorials/plugins_library/#3-parallel-labeling","title":"3. Parallel labeling","text":"<p>For projects with specialized workforce, you can split your workforce in several groups, with each of them focused on a specific portion of your labeling tasks. For instance, group A (experts in the A domain) only does labeling for job A and group B (experts in the B domain) only does labeling for job B. With Kili Plugins, you could then combine these workflows by aggregating the annotations done by multiple labelers as one label. Your reviewers would then be presented with the combined results.</p> <ul> <li>Plugin file: <code>parallel_labeling_plugin.py</code></li> </ul>"},{"location":"sdk/tutorials/set_up_workflows/","title":"Managing Workflows","text":""},{"location":"sdk/tutorials/set_up_workflows/#how-to-set-up-and-manage-workflows-with-kili","title":"How to set up and manage workflows with Kili","text":"<p>In this tutorial, we will learn how to set up basic Kili workflows:</p> <ol> <li>Managing reviews<ol> <li>Placing a specific percentage of project assets in the review queue</li> <li>Placing specific assets in the review queue</li> <li>Sending an asset back to the labeling queue</li> </ol> </li> <li>Setting up consensus<ol> <li>Setting consensus for a specific percentage of project assets</li> <li>Setting consensus for specific assets to compute consensus KPIs</li> </ol> </li> <li>Setting up honeypot</li> <li>Assigning labelers to assets</li> <li>Prioritizing assets in the labeling queue</li> </ol> <p>To work with this notebook, you will have to install and instantiate Kili.</p> <pre><code>%pip install kili\n</code></pre> <pre><code>from kili.client import Kili\n</code></pre> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre> <p>For information on how to set up a Kili project, refer to the basic project setup tutorial.</p>"},{"location":"sdk/tutorials/set_up_workflows/#managing-reviews","title":"Managing reviews","text":""},{"location":"sdk/tutorials/set_up_workflows/#placing-a-specific-percentage-of-project-assets-in-the-review-queue","title":"Placing a specific percentage of project assets in the review queue","text":"<p>You can set up the percentage of assets that will automatically appear in the review queue (1-100%).</p> <pre><code>kili.update_properties_in_project(project_id=project_id, review_coverage=50)\n</code></pre> <pre><code>{'reviewCoverage': 50, 'id': 'clnwvhuu000cz088xcqxz1dig'}\n</code></pre>"},{"location":"sdk/tutorials/set_up_workflows/#setting-up-consensus","title":"Setting up consensus","text":"<p>Consensus works by having more than one labeler annotate the same asset. When the asset is labeled, a consensus score is calculated to measure the agreement level between the different annotations for a given asset. This is a key measure for controlling label production quality.</p> <p>To set up consensus, you will need to have at least two project members. For information on how to add users and assign them to your project, refer to the basic project setup tutorial.</p>"},{"location":"sdk/tutorials/set_up_workflows/#setting-consensus-for-a-specific-percentage-of-project-assets","title":"Setting consensus for a specific percentage of project assets","text":"<p>Let's set the percentage of the project dataset that will be annotated several times, to enable consensus calculations. We will also set the minimum number of labelers to label each one of these assets.</p> <pre><code>kili.update_properties_in_project(\n    project_id=project_id,\n    consensus_tot_coverage=1,\n    min_consensus_size=3,\n)\n</code></pre> <pre><code>{'consensusTotCoverage': 1,\n 'minConsensusSize': 3,\n 'id': 'clnwvhuu000cz088xcqxz1dig'}\n</code></pre>"},{"location":"sdk/tutorials/set_up_workflows/#setting-consensus-for-specific-assets-to-compute-consensus-kpis","title":"Setting consensus for specific assets to compute consensus KPIs","text":"<p>You can manually select specific project assets to be used for computing consensus KPIs.</p> <pre><code>kili.update_properties_in_assets(\n    project_id=project_id,\n    external_ids=[\"1.jpg\", \"2.jpg\", \"3.jpg\"],\n    is_used_for_consensus_array=[True] * 3,\n)\n</code></pre> <pre><code>[{'id': 'clnwvhvo00000gsvzinsato00'},\n {'id': 'clnwvhvo00001gsvzsiqcx5dc'},\n {'id': 'clnwvhvo00002gsvzzbjtyuif'}]\n</code></pre> <p>For more information on consensus, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#setting-up-honeypot","title":"Setting up honeypot","text":"<p>Honeypot (or gold standard) is a tool for auditing the work of labelers by measuring the accuracy of their annotations. Honeypot works by interspersing assets with defined ground truth label in the annotation queue. This way you can measure the agreement level between your ground truth and the annotations made by labelers.</p> <p>First, we need to enable honeypot for our project:</p> <pre><code>kili.update_properties_in_project(project_id=project_id, use_honeypot=True)\n</code></pre> <pre><code>{'useHoneyPot': True, 'id': 'clnwvhuu000cz088xcqxz1dig'}\n</code></pre> <p>You can now manually select specific project assets to be used as honeypots:</p> <pre><code>kili.create_honeypot(\n    project_id=project_id,\n    asset_external_id=\"1.jpg\",\n    json_response={\"JOB_0\": {\"categories\": [{\"confidence\": 100, \"name\": \"OBJECT_B\"}]}},\n)\n</code></pre> <p>For more information on honeypot, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#assigning-labelers-to-assets","title":"Assigning labelers to assets","text":"<p>You can assign specific labelers to specific assets in your project. You can do that by assigning users' emails to the selected asset IDs. Remember that you can assign more than one user to a specific asset.</p> <pre><code>kili.update_properties_in_assets(\n    project_id=project_id,\n    external_ids=[\"1.jpg\", \"2.jpg\", \"3.jpg\"],\n    to_be_labeled_by_array=[\n        [\"example1@example.com\"],\n        [\"example2@example.com\"],\n        [\"example3@example.com\"],\n    ],\n)\n</code></pre> <pre><code>[{'id': 'clnwvhvo00000gsvzinsato00'},\n {'id': 'clnwvhvo00001gsvzsiqcx5dc'},\n {'id': 'clnwvhvo00002gsvzzbjtyuif'}]\n</code></pre> <p>The <code>to_be_labeled_by_array</code> argument is a list of lists. Each of the sub-lists can contain several e-mails. This way you can assign several labelers to one asset.</p> <p>For example:</p> <p><code>to_be_labeled_by_array = [[\"example1@example.com\"], [\"example1@example.com\", \"example2@example.com\"], [\"example3@example.com\"]]</code></p> <p>For information on how to add users and assign them to your project, refer to the basic project setup tutorial. For information on assigning assets to users, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#prioritizing-assets-in-the-labeling-queue","title":"Prioritizing assets in the labeling queue","text":"<p>If you have certain assets that you need to have labeled earlier or later than the rest, you can use Kili's asset prioritization methods.</p> <pre><code>kili.update_properties_in_assets(\n    project_id=project_id, external_ids=[\"1.jpg\", \"2.jpg\", \"3.jpg\"], priorities=[1, 5, 10]\n)\n</code></pre> <pre><code>[{'id': 'clnwvhvo00000gsvzinsato00'},\n {'id': 'clnwvhvo00001gsvzsiqcx5dc'},\n {'id': 'clnwvhvo00002gsvzzbjtyuif'}]\n</code></pre> <p>For information on setting asset priorities, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#placing-specific-assets-in-the-review-queue","title":"Placing specific assets in the review queue","text":"<p>When done with your basic workflow setup, you can place specific, labeled assets in the review queue. As this requires the assets to be labeled, first, let's simulate adding labels to some of our assets. The method will return the list of newly-added label IDs.</p> <pre><code>kili.append_labels(\n    project_id=project_id,\n    asset_external_id_array=[\"4.jpg\"],\n    json_response_array=[{\"JOB_0\": {\"categories\": [{\"confidence\": 100, \"name\": \"OBJECT_B\"}]}}],\n    label_type=\"DEFAULT\",\n)\n</code></pre> <p>Now, let's place some assets in the review queue. The method will return a project ID and a list of asset IDs placed in the review queue.</p> <pre><code>kili.add_to_review(project_id=project_id, external_ids=[\"4.jpg\"])\n</code></pre> <p>For more information on asset statuses, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#sending-an-asset-back-to-the-labeling-queue","title":"Sending an asset back to the labeling queue","text":"<p>You can also send specific labeled assets back to the labeling queue.</p> <pre><code>kili.send_back_to_queue(project_id=project_id, external_ids=[\"4.jpg\"])\n</code></pre> <pre><code>{'id': 'clm0sxbgb05hf082tcq813zrc', 'asset_ids': ['clm0sxcpf0003ojvzcrha754l']}\n</code></pre> <p>For more information on asset statuses, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(project_id)\n</code></pre> <pre><code>'clm0sxbgb05hf082tcq813zrc'\n</code></pre>"},{"location":"sdk/tutorials/set_up_workflows/#summary","title":"Summary","text":"<p>Done!</p> <p>We have learned how to handle the review workflow, set up consensus and honeypot in a project, assign specific labelers to specific assets, and how to prioritize assets in the labeling queue.</p>"},{"location":"sdk/tutorials/tagtog_to_kili/","title":"Tagtog","text":""},{"location":"sdk/tutorials/tagtog_to_kili/#how-to-convert-a-tagtog-project-to-kili","title":"How to convert a Tagtog project to Kili","text":""},{"location":"sdk/tutorials/tagtog_to_kili/#setup","title":"Setup","text":"<pre><code>%pip install kili rich beautifulsoup4\n</code></pre> <pre><code>import json\nimport os\nimport pprint\nfrom pathlib import Path\n\nfrom bs4 import BeautifulSoup\n\nfrom kili.client import Kili\n</code></pre> <pre><code>kili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/tagtog_to_kili/#get-data","title":"Get data","text":"<p>For this recipe, we will use data from the Apartment reviews project made by Jennifer D. Ames.</p> <p>The dataset consists in guests' reviews of apartments/houses for short-term lodging and tourism-related activities. The reviews have been obtained from Inside Airbnb. Each review has been manually annotated in tagtog.</p> <p>To download the project data, it is required to be logged in to tagtog. Then, you can download the project data.</p> <p>Once the .zip file is downloaded, we can unzip it:</p> <pre><code>!tar -xvf tagtog_ApartmentReviews.zip\n</code></pre> <pre><code>print(Path(\"ApartmentReviews/README.md\").read_text(encoding=\"utf-8\"))\n</code></pre> <pre><code>This dataset lives in: https://tagtog.com/JaqenNLP/ApartmentReviews\n\nThis zip was generated with:\n  * date: _2023-05-10T11:25:54.902Z_\n  * search: `*`\n  * total found documents: **228**\n\nThe dataset is here written in the [anndoc format](https://docs.tagtog.com/anndoc.html). Use the `annotations-legend.json` file to help you interpret the annotations.\n\n\nWhat great things will you do with the dataset? :-) Enjoy!\n</code></pre> <p>Let's take a look at the ontology:</p> <pre><code>tagtog_class_id_to_class_name = json.loads(\n    Path(\"ApartmentReviews/annotations-legend.json\").read_text(encoding=\"utf-8\")\n)\npprint.pprint(tagtog_class_id_to_class_name)\n</code></pre> <pre><code>{'e_1': 'Loyalty',\n 'e_13': 'TechOpinion',\n 'e_14': 'FoodOpinion',\n 'e_2': 'RoomOpinion',\n 'e_4': 'ApartmentOpinion',\n 'e_5': 'Location',\n 'e_6': 'KitchenOpinion',\n 'e_7': 'BathroomOpinion',\n 'e_8': 'HostOpinion',\n 'e_9': 'PricePayment',\n 'f_10': 'RoomItem',\n 'f_11': 'OutdoorFeature',\n 'f_12': 'BathroomFeature',\n 'f_15': 'TechFeature',\n 'f_16': 'FoodFeature',\n 'f_17': 'LocationFeature',\n 'f_19': 'LoyaltyFeature',\n 'f_20': 'ApartmentFeature',\n 'f_21': 'HostCharacter',\n 'f_22': 'isLocationQuiet',\n 'f_23': 'Sentiment',\n 'f_24': 'isCriticalProblem',\n 'f_25': 'KitchenFeature',\n 'f_26': 'PaymentFeature',\n 'm_18': 'Sentiment'}\n</code></pre> <p>The ontology shows:</p> <ul> <li>10 entity types (keys starting with <code>e_</code>)</li> </ul> <p></p> <ul> <li>1 document label (key starting with <code>m_</code>)</li> </ul> <p></p> <ul> <li>14 entity labels (keys starting with <code>f_</code>)</li> </ul> <p></p> <p>An entity label is used to tag an entity type, and aims at giving more information about the entity being annotated. For example, the <code>\"f_17\": \"LocationFeature\"</code> label can be used to tag a <code>\"e_5\": \"Location\"</code> entity type.</p> <p>Read more about this project ontology here.</p> <p>The <code>plain.html/pool</code> folder contains the reviews in HTML format:</p> <pre><code>print(\n    Path(\"ApartmentReviews/plain.html/pool/a.km05GoV2Uh1mw9QR.UNiNXWUL8-text.plain.html\").read_text(\n        encoding=\"utf-8\"\n    )\n)\n</code></pre> <pre><code>&lt;!DOCTYPE html &gt;\n&lt;html id=\"a.km05GoV2Uh1mw9QR.UNiNXWUL8-text\" data-origid=\"text\" class=\"anndoc\" data-anndoc-version=\"3.6\" lang=\"\" xml:lang=\"\" xmlns=\"http://www.w3.org/1999/xhtml\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\"/&gt;\n    &lt;meta name=\"generator\" content=\"net.tagtog.anndoc.v3.parsers.general.PlainTextParser_NewParagraphAfter1Newline_v2_0_0\"/&gt;\n    &lt;title&gt;a.km05GoV2Uh1mw9QR.UNiNXWUL8-text&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;article&gt;\n      &lt;section data-type=\"\"&gt;\n        &lt;div class=\"content\"&gt;\n          &lt;p id=\"s1p1\"&gt;The house is beautiful, but it is next to 2 very busy roads. There are no aircons in any rooms and to open the windows you hear the cars and trucks pass - very loud. There is no braai facilities and when we asked x 2 we were told the owner had to approve... still waiting! The rooms on the lower floor is empty and depressing, very hot! Kids slept on couches with sliding doors open, so we could not arm the alarm at night. The aircons on the upper level leaks water onto table and electrical wires. I think it is over priced, for that price the basics should be in place. AIRCONS AND BRAAI&lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/article&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>The annotations are stored in the folder <code>ann.json/master/pool</code>:</p> <pre><code>annotation_sample = json.loads(\n    Path(\n        \"ApartmentReviews/ann.json/master/pool/a.km05GoV2Uh1mw9QR.UNiNXWUL8-text.ann.json\"\n    ).read_text(encoding=\"utf-8\")\n)\n# select only two entities for visualization\nannotation_sample[\"entities\"] = annotation_sample[\"entities\"][:2]\npprint.pprint(annotation_sample)\n</code></pre> <pre><code>{'anncomplete': True,\n 'annotatable': {'parts': ['s1p1']},\n 'entities': [{'classId': 'e_4',\n               'confidence': {'prob': 1,\n                              'state': 'pre-added',\n                              'who': ['user:Mrdenho']},\n               'coordinates': [],\n               'fields': {'f_23': {'confidence': {'prob': 1,\n                                                  'state': 'pre-added',\n                                                  'who': ['user:Mrdenho']},\n                                   'value': 'positive'}},\n               'normalizations': {},\n               'offsets': [{'start': 0, 'text': 'The house is beautiful'}],\n               'part': 's1p1'},\n              {'classId': 'e_5',\n               'confidence': {'prob': 1,\n                              'state': 'pre-added',\n                              'who': ['user:Mrdenho']},\n               'coordinates': [],\n               'fields': {'f_22': {'confidence': {'prob': 1,\n                                                  'state': 'pre-added',\n                                                  'who': ['user:Mrdenho']},\n                                   'value': False},\n                          'f_23': {'confidence': {'prob': 1,\n                                                  'state': 'pre-added',\n                                                  'who': ['user:Mrdenho']},\n                                   'value': 'negative'},\n                          'f_24': {'confidence': {'prob': 1,\n                                                  'state': 'pre-added',\n                                                  'who': ['user:Mrdenho']},\n                                   'value': True}},\n               'normalizations': {},\n               'offsets': [{'start': 24,\n                            'text': 'but it is next to 2 very busy roads'}],\n               'part': 's1p1'}],\n 'metas': {'m_18': {'confidence': {'prob': 1,\n                                   'state': 'pre-added',\n                                   'who': ['user:Mrdenho']},\n                    'value': 'negative'}},\n 'relations': [],\n 'sources': []}\n</code></pre>"},{"location":"sdk/tutorials/tagtog_to_kili/#create-the-kili-project","title":"Create the Kili project","text":"<p>We can start creating the Named Entity Recognition (NER) Kili project.</p> <p>To do so, we will need to define a json interface that follows the ontology of the <code>annotations-legend.json</code> file.</p> <p>Note that with Kili, the json interface can be created directly from the Kili UI.</p> <p>Here, we will use a <code>json_interface</code> variable that will be passed to <code>kili.create_project()</code>.</p> <p>We have two main jobs:</p> <ul> <li><code>SENTIMENT_CLASSIFICATION_JOB</code> for classifying the review as positive, negative or neutral</li> <li><code>NAMED_ENTITIES_RECOGNITION_JOB</code> for the entity type.</li> </ul> <p>We also have several child jobs representing the entity labels.</p> <pre><code># fmt: off\njson_interface = {\n    \"jobs\": {\n        \"SENTIMENT_CLASSIFICATION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"positive\": {\"children\": [], \"name\": \"positive\"},\n                    \"neutral\": {\"children\": [], \"name\": \"neutral\"},\n                    \"negative\": {\"children\": [], \"name\": \"negative\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Sentiment\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": False,\n        },\n        \"NAMED_ENTITIES_RECOGNITION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"HostOpinion\": {\n                        \"children\": [\"isCriticalProblem\", \"HostCharacter\", \"Sentiment\"],\n                        \"color\": \"#472CED\",\n                        \"name\": \"HostOpinion\",\n                    },\n                    \"RoomOpinion\": {\n                        \"children\": [\"isCriticalProblem\", \"RoomItem\", \"Sentiment\"],\n                        \"name\": \"RoomOpinion\",\n                        \"color\": \"#5CE7B7\",\n                    },\n                    \"BathroomOpinion\": {\n                        \"children\": [\"isCriticalProblem\", \"Sentiment\", \"BathroomFeature\"],\n                        \"name\": \"BathroomOpinion\",\n                        \"color\": \"#D33BCE\",\n                    },\n                    \"FoodOpinion\": {\n                        \"children\": [\"isCriticalProblem\", \"FoodFeature\", \"Sentiment\"],\n                        \"name\": \"FoodOpinion\",\n                        \"color\": \"#FB753C\",\n                    },\n                    \"Location\": {\n                        \"children\": [\"LocationFeature\", \"isCriticalProblem\", \"Sentiment\", \"isLocationQuiet\"],\n                        \"name\": \"Location\",\n                        \"color\": \"#3BCADB\"\n                    },\n                    \"KitchenOpinion\": {\n                        \"children\": [\"isCriticalProblem\", \"Sentiment\", \"KitchenFeature\"],\n                        \"name\": \"KitchenOpinion\",\n                        \"color\": \"#199CFC\",\n                    },\n                    \"PricePayment\": {\n                        \"children\": [\"isCriticalProblem\", \"Sentiment\", \"PaymentFeature\"],\n                        \"name\": \"PricePayment\",\n                        \"color\": \"#FA484A\",\n                    },\n                    \"ApartmentOpinion\": {\n                        \"children\": [\"isCriticalProblem\", \"ApartmentFeature\", \"Sentiment\", \"KitchenFeature\"],\n                        \"name\": \"ApartmentOpinion\",\n                        \"color\": \"#ECB82A\"\n                    },\n                    \"Loyalty\": {\n                        \"children\": [\"isCriticalProblem\", \"LoyaltyFeature\", \"Sentiment\"],\n                        \"name\": \"Loyalty\",\n                        \"color\": \"#3CD876\",\n                    },\n                    \"TechOpinion\": {\n                        \"children\": [\"isCriticalProblem\", \"Sentiment\", \"TechFeature\"],\n                        \"name\": \"TechOpinion\",\n                        \"color\": \"#733AFB\",\n                    },\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Entity type\",\n            \"mlTask\": \"NAMED_ENTITIES_RECOGNITION\",\n            \"required\": 1,\n            \"isChild\": False,\n        },\n        \"LocationFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"center\": {\"children\": [], \"name\": \"center\"},\n                    \"airport\": {\"children\": [], \"name\": \"airport\"},\n                    \"underground\": {\"children\": [], \"name\": \"underground\"},\n                    \"tram\": {\"children\": [], \"name\": \"tram\"},\n                    \"bus\": {\"children\": [], \"name\": \"bus\"},\n                    \"train\": {\"children\": [], \"name\": \"train\"},\n                    \"highway\": {\"children\": [], \"name\": \"highway\"},\n                    \"parking\": {\"children\": [], \"name\": \"parking\"},\n                    \"shopping\": {\"children\": [], \"name\": \"shopping\"},\n                    \"tourism\": {\"children\": [], \"name\": \"tourism\"},\n                    \"restaurants\": {\"children\": [], \"name\": \"restaurants\"},\n                    \"pubs\": {\"children\": [], \"name\": \"pubs\"},\n                    \"nature\": {\"children\": [], \"name\": \"nature\"},\n                    \"arrival\": {\"children\": [], \"name\": \"arrival\"},\n                    \"safety\": {\"children\": [], \"name\": \"safety\"},\n                    \"ownvehicle\": {\"children\": [], \"name\": \"ownvehicle\"},\n                    \"taxi\": {\"children\": [], \"name\": \"taxi\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"LocationFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"isCriticalProblem\": {\n            \"content\": {\n                \"categories\": {\n                    \"yes\": {\"children\": [], \"name\": \"yes\"},\n                    \"no\": {\"children\": [], \"name\": \"no\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"isCriticalProblem\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"ApartmentFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"cleanliness\": {\"children\": [], \"name\": \"cleanliness\"},\n                    \"stairs\": {\"children\": [], \"name\": \"stairs\"},\n                    \"compliantDescription\": {\"children\": [], \"name\": \"compliantDescription\"},\n                    \"look\": {\"children\": [], \"name\": \"look\"},\n                    \"space\": {\"children\": [], \"name\": \"space\"},\n                    \"climate\": {\"children\": [], \"name\": \"climate\"},\n                    \"pets\": {\"children\": [], \"name\": \"pets\"},\n                    \"gym\": {\"children\": [], \"name\": \"gym\"},\n                    \"safety\": {\"children\": [], \"name\": \"safety\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"ApartmentFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"FoodFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"breakfast\": {\"children\": [], \"name\": \"breakfast\"},\n                    \"drinks\": {\"children\": [], \"name\": \"drinks\"},\n                    \"snacks\": {\"children\": [], \"name\": \"snacks\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"FoodFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"LoyaltyFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"solo\": {\"children\": [], \"name\": \"solo\"},\n                    \"couples\": {\"children\": [], \"name\": \"couples\"},\n                    \"family\": {\"children\": [], \"name\": \"family\"},\n                    \"friends\": {\"children\": [], \"name\": \"friends\"},\n                    \"repeat\": {\"children\": [], \"name\": \"repeat\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"LoyaltyFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"HostCharacter\": {\n            \"content\": {\n                \"categories\": {\n                    \"friendliness\": {\"children\": [], \"name\": \"friendliness\"},\n                    \"politeness\": {\"children\": [], \"name\": \"politeness\"},\n                    \"communication\": {\"children\": [], \"name\": \"communication\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"HostCharacter\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"RoomItem\": {\n            \"content\": {\n                \"categories\": {\n                    \"bed\": {\"children\": [], \"name\": \"bed\"},\n                    \"wardrobe\": {\"children\": [], \"name\": \"wardrobe\"},\n                    \"chair\": {\"children\": [], \"name\": \"chair\"},\n                    \"desk\": {\"children\": [], \"name\": \"desk\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"RoomItem\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"Sentiment\": {\n            \"content\": {\n                \"categories\": {\n                    \"positive\": {\"children\": [], \"name\": \"positive\"},\n                    \"negative\": {\"children\": [], \"name\": \"negative\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Sentiment\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"TechFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"wifi\": {\"children\": [], \"name\": \"wifi\"},\n                    \"keypad\": {\"children\": [], \"name\": \"keypad\"},\n                    \"smarthome\": {\"children\": [], \"name\": \"smarthome\"},\n                    \"mobile\": {\"children\": [], \"name\": \"mobile\"},\n                    \"tv\": {\"children\": [], \"name\": \"tv\"},\n                    \"videogames\": {\"children\": [], \"name\": \"videogames\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"TechFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"BathroomFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"shower\": {\"children\": [], \"name\": \"shower\"},\n                    \"bathtub\": {\"children\": [], \"name\": \"bathtub\"},\n                    \"wc\": {\"children\": [], \"name\": \"wc\"},\n                    \"amenities\": {\"children\": [], \"name\": \"amenities\"},\n                    \"hairdryer\": {\"children\": [], \"name\": \"hairdryer\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"BathroomFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"PaymentFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"refund\": {\"children\": [], \"name\": \"refund\"},\n                    \"deposit\": {\"children\": [], \"name\": \"deposit\"},\n                    \"payment_methods\": {\"children\": [], \"name\": \"payment methods\"},\n                    \"extra_charges\": {\"children\": [], \"name\": \"extra charges\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"PaymentFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"isLocationQuiet\": {\n            \"content\": {\n                \"categories\": {\n                    \"Quiet\": {\"children\": [], \"name\": \"Quiet\"},\n                    \"Noisy\": {\"children\": [], \"name\": \"Noisy\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"isLocationQuiet\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"OutdoorFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"garden\": {\"children\": [], \"name\": \"garden\"},\n                    \"patio\": {\"children\": [], \"name\": \"patio\"},\n                    \"balcon\": {\"children\": [], \"name\": \"balcon\"},\n                    \"terrace\": {\"children\": [], \"name\": \"terrace\"},\n                    \"view\": {\"children\": [], \"name\": \"view\"},\n                    \"pool\": {\"children\": [], \"name\": \"pool\"},\n                    \"barbecue\": {\"children\": [], \"name\": \"barbecue\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"OutdoorFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"KitchenFeature\": {\n            \"content\": {\n                \"categories\": {\"appliances\": {\"children\": [], \"name\": \"appliances\"}},\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"KitchenFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n    }\n}\n# fmt: on\n</code></pre> <p>Let's create the text project with our ontology:</p> <pre><code>project_id = kili.create_project(\n    input_type=\"TEXT\",\n    json_interface=json_interface,\n    title=\"[Kili SDK Notebook]: Tagtog to Kili recipe\",\n)[\"id\"]\n</code></pre> <p>In the Kili project created, we can see the ontology that follows the same structure as the one in tagtog:</p> <p></p>"},{"location":"sdk/tutorials/tagtog_to_kili/#upload-assets","title":"Upload assets","text":"<p>Now that the project is created, we can upload our assets.</p> <pre><code>filepaths = [\n    Path(\"ApartmentReviews/plain.html/pool/\") / filepath\n    for filepath in os.listdir(\"ApartmentReviews/plain.html/pool/\")\n]\nprint(len(filepaths))\n</code></pre> <pre><code>228\n</code></pre> <pre><code>external_ids = [filepath.name.replace(\".plain.html\", \"\") for filepath in filepaths]\nassets = [\n    BeautifulSoup(file.read_text(encoding=\"utf-8\"), \"html.parser\").find(\"body\").get_text().strip()\n    for file in filepaths\n]\n</code></pre> <pre><code>print(external_ids[0])\nprint(assets[0])\n</code></pre> <pre><code>aKRwFKFHhO5FoLBBCEUJl8gkQoBS-text\nJason was great! He welcomed us with cold waters and fully explained the apartment and its many amenities. He provided anything we could have forgotten and made sure to answer the many questions we had. He was quick to answer any additional questions throughout the stay as well. The apartment is located on a quiet hutong right off a main street that is right in the center of the old town and is just a short walk to the metro. The shower is a bit hard to get in and out of, and would be difficult if you have mobility issues. But the apartment was great and we really enjoyed a little bit of local living while in Beijing. Thanks Jason!\n</code></pre> <pre><code>kili.append_many_to_dataset(project_id, content_array=assets, external_id_array=external_ids)\n</code></pre> <p>Our assets have been successfully uploaded to Kili:</p> <p></p>"},{"location":"sdk/tutorials/tagtog_to_kili/#upload-existing-annotations","title":"Upload existing annotations","text":"<p>Now that our project is created with its assets, we can upload the annotations we made in tagtog.</p> <p>But first we need to convert the tagtog annotations to the Kili format.</p> <pre><code>json_response_array = []\n\nfor asset_name, asset in zip(external_ids, assets):\n    # load the tagtog json annotation\n    annotation_path = Path(\"ApartmentReviews/ann.json/master/pool/\") / (asset_name + \".ann.json\")\n    tagtog_annotation = json.loads(annotation_path.read_text(encoding=\"utf-8\"))\n\n    # skip if not annotated\n    if not tagtog_annotation[\"anncomplete\"]:\n        continue\n\n    # kili json response\n    json_response = {}\n\n    # overall review sentiment classification\n    try:\n        sentiment_class = tagtog_annotation[\"metas\"][\"m_18\"][\"value\"]\n    except KeyError:\n        pass  # the asset is not annotated for sentiment\n    else:\n        assert sentiment_class in (\"positive\", \"negative\", \"neutral\"), sentiment_class\n        sentiment_confidence = int(\n            round(tagtog_annotation[\"metas\"][\"m_18\"][\"confidence\"][\"prob\"] * 100)\n        )\n\n        # we add the sentiment classification to the json response\n        json_response[\"SENTIMENT_CLASSIFICATION_JOB\"] = {}\n        json_response[\"SENTIMENT_CLASSIFICATION_JOB\"][\"categories\"] = [\n            {\"name\": sentiment_class, \"confidence\": sentiment_confidence}\n        ]\n\n    # we skip assets with complex html for the sake of clarity\n    if len(tagtog_annotation[\"annotatable\"][\"parts\"]) &gt; 1:\n        json_response_array.append(json_response)\n        continue\n\n    # Named entities recognition job\n    json_response[\"NAMED_ENTITIES_RECOGNITION_JOB\"] = {\"annotations\": []}\n    for entity in tagtog_annotation[\"entities\"]:\n        ner_class = tagtog_class_id_to_class_name[entity[\"classId\"]]\n\n        # make sure the class is in the json interface\n        assert (\n            ner_class\n            in json_interface[\"jobs\"][\"NAMED_ENTITIES_RECOGNITION_JOB\"][\"content\"][\"categories\"]\n        ), ner_class\n\n        confidence = int(round(entity[\"confidence\"][\"prob\"] * 100))\n\n        # get the begin offset and the content of the entity\n        assert len(entity[\"offsets\"]) == 1, entity[\"offsets\"]\n        begin_offset = entity[\"offsets\"][0][\"start\"]\n        content = entity[\"offsets\"][0][\"text\"]\n\n        # we verify that the content and begin_offset match the asset content\n        assert content == asset[begin_offset : begin_offset + len(content)], (\n            content,\n            asset[begin_offset : begin_offset + len(content)],\n        )\n\n        entity_annotation = {\n            \"children\": {},\n            \"beginOffset\": begin_offset,\n            \"categories\": [{\"name\": ner_class, \"confidence\": confidence}],\n            \"content\": content,\n        }\n\n        # an named entity can have tagtog entity labels\n        # we convert them to Kili children annotations\n        for field_id in entity[\"fields\"]:\n            entity_label = tagtog_class_id_to_class_name[field_id]\n            job_interface = json_interface[\"jobs\"][entity_label]\n            confidence = int(round(entity[\"fields\"][field_id][\"confidence\"][\"prob\"] * 100))\n            label_class = entity[\"fields\"][field_id][\"value\"]\n\n            # we convert boolean fields to match our json interface\n            if entity_label == \"isLocationQuiet\":\n                label_class = \"Quiet\" if label_class else \"Noisy\"\n\n            if entity_label == \"isCriticalProblem\":\n                label_class = \"yes\" if label_class else \"no\"\n\n            if entity_label == \"HostCharacter\" and label_class == \"friendly\":\n                label_class = \"friendliness\"\n\n            # some job names have spaces that we converted to \"_\" in our json interface\n            label_class = label_class.replace(\" \", \"_\")\n            assert label_class in job_interface[\"content\"][\"categories\"], f\"{label_class} {entity}\"\n\n            if entity_label not in entity_annotation[\"children\"]:\n                entity_annotation[\"children\"][entity_label] = {\"categories\": []}\n\n            # we add the child annotations to the NER annotation\n            entity_annotation[\"children\"][entity_label][\"categories\"].append(\n                {\"name\": label_class, \"confidence\": confidence}\n            )\n\n        json_response[\"NAMED_ENTITIES_RECOGNITION_JOB\"][\"annotations\"].append(entity_annotation)\n\n    json_response_array.append(json_response)\n</code></pre> <p>We can now upload the Kili annotations to our project:</p> <pre><code>kili.append_labels(\n    json_response_array=json_response_array,\n    project_id=project_id,\n    asset_external_id_array=external_ids,\n)\n</code></pre> <p>We can see that this asset's labels in tagtog labeling interface:</p> <p></p> <p>match the Kili labels we converted previously:</p> <p></p> <p>We also see that the entity labels (child annotations in Kili) are shown in the labeling interface:</p> <p></p>"},{"location":"sdk/tutorials/tagtog_to_kili/#conclusion","title":"Conclusion","text":"<p>In this recipe, we saw how to convert a tagtog project to Kili.</p> <p>As you can see, the Kili json interface and the json response formats are really flexible and can be adapted to a lot of use cases.</p>"},{"location":"sdk/tutorials/tagtog_to_kili/#project-cleanup","title":"Project cleanup","text":"<pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/vertex_ai_automl_od/","title":"Vertex AI AutoML","text":""},{"location":"sdk/tutorials/vertex_ai_automl_od/#train-an-object-detection-model-with-vertex-ai-automl-and-kili-for-faster-annotation","title":"Train an object detection model with Vertex AI AutoML and Kili for faster annotation","text":""},{"location":"sdk/tutorials/vertex_ai_automl_od/#what-is-google-vertex-ai","title":"What is Google Vertex AI?","text":"<p>Vertex AI is a comprehensive machine learning platform designed for the training, deployment, and customization of ML models and AI applications, including large language models (LLMs). It seamlessly integrates with Kili to create a sophisticated model-in-the-loop data annotation workflow.</p> <p>For more information on Google Vertex AI AutoML, you can visit Introduction to Vertex AI and the AutoML beginner's guide.</p>"},{"location":"sdk/tutorials/vertex_ai_automl_od/#tutorial-objectives","title":"Tutorial Objectives","text":"<p>In this tutorial, we will demonstrate how to train an object detection model with annotated data on Google Vertex AI AutoML and utilize it to make predictions on unlabeled data to speed up the annotation process. The tutorial will cover the following steps: 1. Fetching and preparing data from Kili 2. Training a model with Vertex AI 3. Running predictions on unlabeled images from your Kili dataset 4. Uploading predictions to our Kili project for faster annotation</p> <p>All steps can be performed through the Google Cloud Console UI, but this tutorial focuses on performing actions exclusively through the AI Platform Python SDK and Kili Python SDK to provide a deeper integration.</p> <p>For this tutorial, we will use the BCCD dataset (Blood Cell Count and Detection), which is accessible on GitHub and also hosted on Hugging Face or Roboflow. It consists of 3 highly unbalanced classes: platelets, RBCs (red blood cells), and WBCs (white blood cells).</p> <p></p>"},{"location":"sdk/tutorials/vertex_ai_automl_od/#installation-requirements","title":"Installation Requirements","text":"<pre><code>!pip install -U google-cloud-aiplatform\n!pip install kili\n</code></pre> <pre><code>import json\nimport mimetypes\nimport random\nfrom pathlib import Path\nfrom typing import List, Union\n\nimport requests\nfrom google.cloud import aiplatform, storage\nfrom google.cloud.aiplatform.gapic.schema import trainingjob\nfrom google.colab import auth\nfrom PIL import Image\nfrom tqdm import tqdm\n\nfrom kili.client import Kili\n</code></pre> <p>We first initialize the Kili client.</p> <p>The API Key can be found in the settings of your project, in the \"interface\" section.. The object detection job name of your project can be found in the interface of your project.</p> <pre><code>kili_api_key = \"[KILI API KEY]\"\nproject_id = \"[KILI PROJECT ID]\"\nOBJECT_DETECTION_JOB_NAME = \"[OBJECT DETECTION JOB NAME]\"  # e.g: OBJECT_DETECTION_JOB\n\nkili = Kili(api_key=kili_api_key)\n</code></pre> <pre><code># Authenticate with Google Cloud\nauth.authenticate_user()\n\n# Initialize the GCS client\nstorage_client = storage.Client()\n</code></pre> <pre><code>project_name = \"[GCP PROJECT NAME]\"\nlocation = \"[GCP PROJECT LOCATION]\"\nbucket_name = \"[GCS BUCKET NAME]\"\ndataset_name = \"blood_cell\"  # name of the dataset you will create in Vertex AI\nbucket_dataset_dir = (\n    f\"experiments/{dataset_name}\"  # name of the folder in yout bucket where files will be stored.\n)\n\naiplatform.init(project=project_name, location=location)\n</code></pre>"},{"location":"sdk/tutorials/vertex_ai_automl_od/#prepare-the-data","title":"Prepare the Data","text":"<p>To train our Vertex AI AutoML model, we need to prepare the data within our Kili project. This section follows the guidelines provided in the Vertex AI data preparation documentation</p> <p>This section covers the following steps: - Downloading annotated images from Kili to your local machine along with their labels. - Uploading the images to Google Cloud Storage. - Splitting the annotated data into train/validation/test sets. - Converting the images and labels into the required format for Vertex AI datasets. - Uploading the converted input data to Google Cloud Storage.</p> <p>In this particular example, we have annotated 150 assets on the Kili app.</p>"},{"location":"sdk/tutorials/vertex_ai_automl_od/#retrieving-and-downloading-labeled-assets-from-kili","title":"Retrieving and downloading labeled assets from Kili","text":"<p>We first call the Kili Python SDK <code>assets</code> function in order to retrieve assets.</p> <p>The <code>download_media</code> argument allows to download the media (images here) in the folder given in the <code>local_media_dir</code> argument. When doing so, the <code>content</code> field will automatically be replaced by the local path of the downloaded asset.</p> <p>For each asset, we query its <code>id</code>, <code>externalId</code>, and the <code>jsonResponse</code> fields of its latest label (the last one submitted on Kili). For more information on the <code>assets</code> function or on other fields that you can query, you can have a look at the function documentation.</p> <pre><code>assets = kili.assets(\n    project_id=project_id,\n    download_media=True,\n    local_media_dir=\"./images\",\n    status_in=[\"LABELED\"],\n    fields=[\"latestLabel.jsonResponse\", \"content\", \"id\", \"externalId\"],\n    disable_tqdm=False,\n)\n</code></pre> <pre><code># Plot an example image\nImage.open(assets[0][\"content\"])\n</code></pre> <p></p>"},{"location":"sdk/tutorials/vertex_ai_automl_od/#uploading-images-to-google-cloud-storage","title":"Uploading images to Google Cloud Storage","text":"<p>When importing data to a Vertex AI Datset, the images must already be stored on a Google Cloud Storage:</p> <pre><code>def upload_assets_to_bucket(assets: List[dict], bucket_name: str, bucket_dataset_dir: str):\n    bucket = storage_client.get_bucket(bucket_name)\n    for asset in tqdm(assets, desc=\"uploading assets to bucket\"):\n        image_bucket_path = f\"{bucket_dataset_dir}/images/{Path(asset['content']).name}\"\n        image_local_path = asset[\"content\"]\n        blob = bucket.blob(image_bucket_path)\n        blob.upload_from_filename(image_local_path)\n</code></pre> <pre><code>upload_assets_to_bucket(assets, bucket_name, bucket_dataset_dir)\n</code></pre>"},{"location":"sdk/tutorials/vertex_ai_automl_od/#splitting-the-dataset-into-trainvalidationtest-sets","title":"Splitting the Dataset into Train/Validation/Test Sets","text":"<p>We will divide our annotated images using the following proportions:</p> <ul> <li>Training set: 70%</li> <li>Validation set: 20%</li> <li>Test set: 10%</li> </ul> <pre><code>def split_assets_in_train_val_test(assets: list[dict]):\n    # shuffle the assets before splitting\n    random.shuffle(assets)\n\n    # Calculate the lengths of each split\n    total_len = len(assets)\n    train_len = int(0.7 * total_len)\n    val_len = int(0.2 * total_len)\n\n    # Split the list into train, validation, and test\n    train_assets = assets[:train_len]\n    val_assets = assets[train_len : train_len + val_len]\n    test_assets = assets[train_len + val_len :]\n\n    return train_assets, val_assets, test_assets\n</code></pre> <pre><code>train_assets, val_assets, test_assets = split_assets_in_train_val_test(assets)\nprint(len(train_assets), len(val_assets), len(test_assets))\n</code></pre> <pre><code>105 30 15\n</code></pre>"},{"location":"sdk/tutorials/vertex_ai_automl_od/#converting-images-and-labels-into-vertex-ai-required-format","title":"Converting images and labels into Vertex AI required format","text":"<p>Data that we upload to the Vertex AI dataset must follow a predefined schema. The schema is provided in a YAML file format that is based on the OpenAPI format.</p> <p>In the following function, we generate JSON data that adheres to the required schema for an asset. This includes the location of the asset on Google Cloud Storage, the bounding boxes with their coordinates and categories, as well as the asset split.</p> <pre><code>def get_asset_io_input(asset: list[dict], split: str, bucket_name: str, image_bucket_path: str):\n    image_gcs_uri = f\"gs://{bucket_name}/{image_bucket_path}\"\n    labels = []\n    for annotation in asset[\"latestLabel\"][\"jsonResponse\"][OBJECT_DETECTION_JOB_NAME][\n        \"annotations\"\n    ]:\n        normalizedVertices = annotation[\"boundingPoly\"][0][\"normalizedVertices\"]\n        label = {\n            \"displayName\": annotation[\"categories\"][0][\"name\"],\n            \"xMin\": min(map(lambda vertice: vertice[\"x\"], normalizedVertices)),\n            \"yMin\": min(map(lambda vertice: vertice[\"y\"], normalizedVertices)),\n            \"xMax\": max(map(lambda vertice: vertice[\"x\"], normalizedVertices)),\n            \"yMax\": max(map(lambda vertice: vertice[\"y\"], normalizedVertices)),\n        }\n        labels.append(label)\n\n    return {\n        \"imageGcsUri\": image_gcs_uri,\n        \"boundingBoxAnnotations\": labels,\n        \"dataItemResourceLabels\": {\"aiplatform.googleapis.com/ml_use\": split},\n    }\n</code></pre> <p>We will generate one jsonl file storing all image json input. Each line of the jsonl file will corresponds to one data to import in the previously defined format</p> <p>This jsonl file then needs to be imported to the Google Cloud Storage bucket and will be the input given at the dataset creation.</p> <pre><code>def generate_and_upload_inputs_to_bucket(\n    assets: List[dict], bucket_name: str, bucket_dataset_dir: str\n):\n    output_jsonl_file = \"inputs.jsonl\"\n    bucket = storage_client.get_bucket(bucket_name)\n    with open(output_jsonl_file, \"w\") as output_file:\n        for split_name, split_assets in [\n            (\"training\", train_assets),\n            (\"validation\", val_assets),\n            (\"test\", test_assets),\n        ]:\n            for asset in split_assets:\n                # get the input object to be sent when importing the dataset\n                image_bucket_path = f\"{bucket_dataset_dir}/images/{Path(asset['content']).name}\"\n                input = get_asset_io_input(asset, split_name, bucket_name, image_bucket_path)\n\n                # add the example input to the jsonl file\n                json_line = json.dumps(input)\n                output_file.write(json_line + \"\\n\")\n\n    # upload the inputs file to the bucket\n    blob = bucket.blob(f\"{bucket_dataset_dir}/inputs.jsonl\")\n    blob.upload_from_filename(output_jsonl_file)\n</code></pre> <pre><code>generate_and_upload_inputs_to_bucket(assets, bucket_name, bucket_dataset_dir)\n</code></pre>"},{"location":"sdk/tutorials/vertex_ai_automl_od/#create-a-dataset-in-vertex","title":"Create a dataset in Vertex","text":"<p>To train an autoML model, we need a Vertex AI dataset.</p> <p>When creating this dataset, we also provide the jsonl file generated in the last section to import images with their labels into the dataset.</p> <p>For more information on dataset creation, you can have a look at Vertex AI documentation</p> <pre><code>def create_and_import_dataset_image_sample(\n    project: str,\n    location: str,\n    display_name: str,\n    src_uris: Union[str, List[str]],\n    import_schema_uri: str,\n    sync: bool = True,\n):\n    aiplatform.init(project=project, location=location)\n\n    ds = aiplatform.ImageDataset.create(\n        display_name=display_name,\n        gcs_source=src_uris,\n        import_schema_uri=import_schema_uri,\n        sync=sync,\n    )\n\n    ds.wait()\n\n    print(ds.display_name)\n    print(ds.resource_name)\n    return ds\n</code></pre> <pre><code>inputs_uri = f\"gs://{bucket_name}/{bucket_dataset_dir}/inputs.jsonl\"\nimport_schema_uri = (\n    \"gs://google-cloud-aiplatform/schema/dataset/ioformat/image_bounding_box_io_format_1.0.0.yaml\"\n)\nds = create_and_import_dataset_image_sample(\n    project_name, location, dataset_name, inputs_uri, import_schema_uri\n)\n</code></pre> <pre><code>INFO:google.cloud.aiplatform.datasets.dataset:Creating ImageDataset\nINFO:google.cloud.aiplatform.datasets.dataset:Create ImageDataset backing LRO: projects/**********/locations/europe-west4/datasets/2314474175491735552/operations/7318488207820062720\nINFO:google.cloud.aiplatform.datasets.dataset:ImageDataset created. Resource name: projects/**********/locations/europe-west4/datasets/2314474175491735552\nINFO:google.cloud.aiplatform.datasets.dataset:To use this ImageDataset in another session:\nINFO:google.cloud.aiplatform.datasets.dataset:ds = aiplatform.ImageDataset('projects/**********/locations/europe-west4/datasets/2314474175491735552')\nINFO:google.cloud.aiplatform.datasets.dataset:Importing ImageDataset data: projects/**********/locations/europe-west4/datasets/2314474175491735552\nINFO:google.cloud.aiplatform.datasets.dataset:Import ImageDataset data backing LRO: projects/**********/locations/europe-west4/datasets/2314474175491735552/operations/7021250632413609984\nINFO:google.cloud.aiplatform.datasets.dataset:ImageDataset data imported. Resource name: projects/**********/locations/europe-west4/datasets/2314474175491735552\n\n\nplastic\nprojects/**********/locations/europe-west4/datasets/2314474175491735552\n</code></pre> <pre><code>dataset_id = ds.name.split(\"/\")[-1]\nprint(dataset_id)\n</code></pre> <pre><code>2314474175491735552\n</code></pre> <p></p>"},{"location":"sdk/tutorials/vertex_ai_automl_od/#train-a-model","title":"Train a Model","text":"<p>We are now ready to train our model!</p> <p>When creating the training model pipeline, we provide the task definition schema (object detection here), and <code>filter_splits</code> tags that provide autoML training algorithm with the splits that we have made on our dataset when importing images.</p> <p>We also provide some task inputs like the model type and a time budget.</p> <p>We use the default model type <code>CLOUD_HIGH_ACCURACY_1</code> which is expected to have a higher latency, but should also have a higher prediction quality than other models.</p> <p>The time budget signifies the maximum cost budget that we are prepared to allocate for the training. If the model converges before reaching this budget, it will cease operation. We have set the time budget at a minimum level for initial experiments, but you are free to increase it whenever you wish to transition from experimental stages to production. For a detailed explanation of autoML costs, you can visit the Vertex AI Pricing page</p> <pre><code>def create_training_pipeline_image_object_detection_sample(\n    project: str, display_name: str, dataset_id: str, model_display_name: str, location: str\n):\n    client_options = {\"api_endpoint\": f\"{location}-aiplatform.googleapis.com\"}\n    client = aiplatform.gapic.PipelineServiceClient(client_options=client_options)\n\n    training_task_inputs = trainingjob.definition.AutoMlImageObjectDetectionInputs(\n        model_type=\"CLOUD_HIGH_ACCURACY_1\",\n        budget_milli_node_hours=20000,  # The minimum time budget\n        disable_early_stopping=False,\n    ).to_value()\n\n    training_pipeline = {\n        \"display_name\": display_name,\n        \"training_task_definition\": \"gs://google-cloud-aiplatform/schema/trainingjob/definition/automl_image_object_detection_1.0.0.yaml\",\n        \"training_task_inputs\": training_task_inputs,\n        \"input_data_config\": {\n            \"dataset_id\": dataset_id,\n            \"filter_split\": {\n                \"training_filter\": \"labels.aiplatform.googleapis.com/ml_use=training\",\n                \"validation_filter\": \"labels.aiplatform.googleapis.com/ml_use=validation\",\n                \"test_filter\": \"labels.aiplatform.googleapis.com/ml_use=test\",\n            },\n        },\n        \"model_to_upload\": {\"display_name\": model_display_name},\n    }\n    parent = f\"projects/{project}/locations/{location}\"\n    response = client.create_training_pipeline(parent=parent, training_pipeline=training_pipeline)\n    print(\"response:\", response)\n    return response\n</code></pre> <p>The given code will launch an asynchronous training job pipeline.</p> <p>Once launched, the pipeline can be accessed at the following adress: https://console.cloud.google.com/vertex-ai/training/training-pipelines</p> <pre><code>training_name = \"autoML-training-blood_cell-poc-v2\"\nmodel_display_name = \"blood_cell-poc-v2\"\nresponse = create_training_pipeline_image_object_detection_sample(\n    project_name, training_name, dataset_id, model_display_name, location\n)\n</code></pre> <pre><code>response: name: \"projects/**********/locations/europe-west4/trainingPipelines/5236749032969207808\"\ndisplay_name: \"autoML-training-blood_cell-poc-v2\"\ninput_data_config {\n  dataset_id: \"2314474175491735552\"\n  filter_split {\n    training_filter: \"labels.aiplatform.googleapis.com/ml_use=training\"\n    validation_filter: \"labels.aiplatform.googleapis.com/ml_use=validation\"\n    test_filter: \"labels.aiplatform.googleapis.com/ml_use=test\"\n  }\n}\ntraining_task_definition: \"gs://google-cloud-aiplatform/schema/trainingjob/definition/automl_image_object_detection_1.0.0.yaml\"\ntraining_task_inputs {\n  struct_value {\n    fields {\n      key: \"budgetMilliNodeHours\"\n      value {\n        string_value: \"20000\"\n      }\n    }\n    fields {\n      key: \"modelType\"\n      value {\n        string_value: \"CLOUD_HIGH_ACCURACY_1\"\n      }\n    }\n  }\n}\nmodel_to_upload {\n  display_name: \"blood_cell-poc-v2\"\n}\nstate: PIPELINE_STATE_PENDING\ncreate_time {\n  seconds: 1698654485\n  nanos: 864404000\n}\nupdate_time {\n  seconds: 1698654485\n  nanos: 864404000\n}\n</code></pre> <p>Once trained, your model should appear at the following adress: https://console.cloud.google.com/vertex-ai/models</p> <p>You can now evaluate it, deploy it, create predictions etc.</p> <p>To proceed with additional operations, it's necessary to obtain the model's unique identifier (ID) or resource name, which can be found in the model's information section. This identifier is readily accessible through the Google Cloud Console interface. While it is possible to fetch the ID programmatically using the Python SDK for a more comprehensive integration, for the purposes of this tutorial, we will streamline the process by directly retrieving the ID from the console's user interface.</p> <pre><code># MODEL ID to be found on the model registry of Vertex AI: https://console.cloud.google.com/vertex-ai/models\nmodel_resource_name = \"[MODEL ID]\"\n</code></pre>"},{"location":"sdk/tutorials/vertex_ai_automl_od/#batch-inference-prediction","title":"Batch inference prediction","text":"<p>Now that our model is trained, we can download unlabeled data from Kili, upload it to cloud storage and prepare it as required for batch prediction input as defined in Vertex AI's doc</p> <pre><code># Retrieve and download unlabeled assets from Kili\nunlabeled_assets = kili.assets(\n    project_id=project_id,\n    download_media=True,\n    local_media_dir=\"./images\",\n    status_in=[\"TODO\"],\n    fields=[\"content\", \"id\", \"externalId\"],\n    disable_tqdm=False,\n)\n</code></pre> <pre><code>upload_assets_to_bucket(unlabeled_assets, bucket_name, bucket_dataset_dir)\n</code></pre> <pre><code>def upload_test_source_to_bucket(assets: List[dict], bucket_name: str, bucket_dataset_dir: str):\n    output_jsonl_file = \"batch_inference_inputs.jsonl\"\n    bucket = storage_client.get_bucket(bucket_name)\n    with open(output_jsonl_file, \"w\") as output_file:\n        for asset in assets:\n            # get the input object to be sent when importing the dataset\n            input = {\n                \"content\": f\"{bucket_dataset_dir}/images/{Path(asset['content']).name}\",\n                \"mimeType\": mimetypes.guess_type(asset[\"content\"])[0],\n            }\n\n            # add the test input to the jsonl file\n            json_line = json.dumps(input)\n            output_file.write(json_line + \"\\n\")\n\n    # upload the inputs file to the bucket\n    blob = bucket.blob(f\"{bucket_dataset_dir}/batch_inference_inputs.jsonl\")\n    blob.upload_from_filename(output_jsonl_file)\n</code></pre> <pre><code>upload_test_source_to_bucket(unlabeled_assets, bucket_name, bucket_dataset_dir)\n</code></pre> <p>We now create a batch prediction job and wait for its result.</p> <pre><code>def create_batch_prediction_job_sample(\n    project: str,\n    location: str,\n    model_resource_name: str,\n    job_display_name: str,\n    gcs_source: str,\n    gcs_destination: str,\n    sync: bool = True,\n):\n    aiplatform.init(project=project, location=location)\n\n    my_model = aiplatform.Model(model_resource_name)\n\n    batch_prediction_job = my_model.batch_predict(\n        job_display_name=job_display_name,\n        gcs_source=gcs_source,\n        gcs_destination_prefix=gcs_destination,\n        sync=sync,\n    )\n\n    batch_prediction_job.wait()\n\n    print(batch_prediction_job.display_name)\n    print(batch_prediction_job.resource_name)\n    print(batch_prediction_job.state)\n    return batch_prediction_job\n</code></pre> <pre><code>job_display_name = \"batch_prediction_test\"\ngcs_source = f\"gs://{bucket_name}/{bucket_dataset_dir}/batch_inference_inputs.jsonl\"\ngcs_destination = f\"gs://{bucket_name}/{bucket_dataset_dir}/batch_inference\"\n\nbatch_prediction_job = create_batch_prediction_job_sample(\n    project_name, location, model_resource_name, job_display_name, gcs_source, gcs_destination\n)\n</code></pre> <pre><code>Creating BatchPredictionJob\n\n\nINFO:google.cloud.aiplatform.jobs:Creating BatchPredictionJob\n\n\nBatchPredictionJob created. Resource name: projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200\n\n\nINFO:google.cloud.aiplatform.jobs:BatchPredictionJob created. Resource name: projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200\n\n\nTo use this BatchPredictionJob in another session:\n\n\nINFO:google.cloud.aiplatform.jobs:To use this BatchPredictionJob in another session:\n\n\nbpj = aiplatform.BatchPredictionJob('projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200')\n\n\nINFO:google.cloud.aiplatform.jobs:bpj = aiplatform.BatchPredictionJob('projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200')\n\n\nView Batch Prediction Job:\nhttps://console.cloud.google.com/ai/platform/locations/europe-west4/batch-predictions/466893868839731200?project=**********\n\n\nINFO:google.cloud.aiplatform.jobs:View Batch Prediction Job:\nhttps://console.cloud.google.com/ai/platform/locations/europe-west4/batch-predictions/466893868839731200?project=**********\n\n\nBatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nINFO:google.cloud.aiplatform.jobs:BatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nBatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nINFO:google.cloud.aiplatform.jobs:BatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nBatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nINFO:google.cloud.aiplatform.jobs:BatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nBatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nINFO:google.cloud.aiplatform.jobs:BatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nBatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nINFO:google.cloud.aiplatform.jobs:BatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nBatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nINFO:google.cloud.aiplatform.jobs:BatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nBatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nINFO:google.cloud.aiplatform.jobs:BatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nBatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nINFO:google.cloud.aiplatform.jobs:BatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nBatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nINFO:google.cloud.aiplatform.jobs:BatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nBatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nINFO:google.cloud.aiplatform.jobs:BatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_RUNNING\n\n\nBatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_SUCCEEDED\n\n\nINFO:google.cloud.aiplatform.jobs:BatchPredictionJob projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200 current state:\nJobState.JOB_STATE_SUCCEEDED\n\n\nBatchPredictionJob run completed. Resource name: projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200\n\n\nINFO:google.cloud.aiplatform.jobs:BatchPredictionJob run completed. Resource name: projects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200\n\n\nbatch_prediction_test\nprojects/**********/locations/europe-west4/batchPredictionJobs/466893868839731200\nJobState.JOB_STATE_SUCCEEDED\n</code></pre> <p>The URL of the batch prediction pipeline output file in GCP can be infered from the given source destination folder given and the BatchPredictionJob <code>output_info</code> attribute. However once again, for the simplicity, we will assume that we will get the URL by finding the output file on the Google cloud storage at the given source destination folder in the bucket.</p> <pre><code># To be found in the cloud storage at the previously given destination folder\noutput_gcp_url = \"[URL of the prediction output]\"\n</code></pre>"},{"location":"sdk/tutorials/vertex_ai_automl_od/#import-predictions-to-kili","title":"Import predictions to Kili","text":"<pre><code>jsonl_file_path = \"batch_prediction_output.jsonl\"\nrequests.get(output_gcp_url, jsonl_file_path)\n</code></pre> <p>Now that the predictions output are retrieved, we will convert it to the Kili format given described in the Kili documentation and upload them to your Kili project.</p> <pre><code>def vertex_to_kili(json_output):\n    external_id = json_output[\"instance\"][\"content\"].split(\"/\")[-1]\n    annotations = []\n    for category_name, bbox, confidence in zip(\n        json_output[\"prediction\"][\"displayNames\"],\n        json_output[\"prediction\"][\"bboxes\"],\n        json_output[\"prediction\"][\"confidence\"],\n    ):\n        bounding_poly = [\n            {\"x\": bbox[0], \"y\": bbox[3]},\n            {\"x\": bbox[0], \"y\": bbox[2]},\n            {\"x\": bbox[1], \"y\": bbox[2]},\n            {\"x\": bbox[1], \"y\": bbox[3]},\n        ]\n        annotations.append(\n            {\n                \"boundingPoly\": bounding_poly,\n                \"categories\": [{\"name\": category_name.upper(), \"confidence\": confidence}],\n            }\n        )\n    json_response = {\"OBJECT_DETECTION_JOB\": {\"annotations\": annotations}}\n    return json_response, external_id\n</code></pre> <pre><code>json_response_array = []\nexternal_id_array = []\n\nwith open(jsonl_file_path) as jsonl_file:\n    for line in jsonl_file:\n        line = line.strip()\n        json_output = json.loads(line)\n        json_response, external_id = vertex_to_kili(json_output)\n        json_response_array.append(json_response)\n        external_id_array.append(external_id)\n</code></pre> <pre><code>kili.create_predictions(\n    project_id=project_id,\n    json_response_array=json_response_array,\n    external_id_array=external_id_array,\n)\n</code></pre>"},{"location":"sdk/tutorials/vertex_ai_automl_od/#results-and-conclusion","title":"Results and conclusion","text":"<p>You can visualize your predictions in Kili and use them as preannotations for your project:</p> <p></p> <p>We trained the model on a small training dataset and during a small amount of time but we are already able to get satisfying results.</p> <p>In this tutorial, we have successfully demonstrated the synergy between Google Vertex AI AutoML and the Kili platform for efficient object detection model training and preannotation generation. By combining the strengths of Vertex AI and Kili, we have established a seamless workflow that optimizes the training process and fasten data annotation.</p> <p>You are free to take this tutorial as an integration starting point and implement a more complex active learning pipeline.</p>"},{"location":"sdk/tutorials/webhooks_example/","title":"Webhooks","text":""},{"location":"sdk/tutorials/webhooks_example/#how-to-develop-a-kili-webhook","title":"How to develop a Kili Webhook","text":""},{"location":"sdk/tutorials/webhooks_example/#context","title":"Context","text":"<p>This notebook is an end-to-end example that you can follow to create a project, register a first webhook and activate it on this project for the corresponding events in Kili.</p> <p>For more information on the available events, please refer to the documentation.</p> <p>Webhooks are really similar to the plugins, except they are self hosted, and will require a webservice deployed on your premise, callable by Kili (You can implement a header-based security).</p> <p>If you are a Europe SaaS user, plugins &amp; webhooks are available for paying-customers in beta for now. If you are a US/ On Premise customer, only webhooks are available as of version 1.128.0.</p> <p>Webhook allow you to easily access your custom code, manage the CI/CD of the version of the plugin deployed, and easily integrate it with your own stack.</p> <p>If you are looking for a more of-the-shelf capability, you can have a look at the plugins development tutorial.</p> <p>NB: The webhook capabilities of Kili are under active development, and compatible with version 2.128.0 and later of Kili. Don't hesitate to reach out via Github or the Kili support to provide feedback.</p>"},{"location":"sdk/tutorials/webhooks_example/#step-1-instantiate-kili","title":"Step 1: Instantiate Kili","text":"<pre><code>%pip install kili\n</code></pre> <pre><code>from kili.client import Kili\n\nkili = Kili(\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/webhooks_example/#step-2-create-the-project","title":"Step 2: Create the project","text":"<p>First, we need to create a new project. In our example, we will use an <code>IMAGE</code> type project with the following <code>jsonInterace</code>:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"content\": {\n                \"categories\": {\n                    \"OBJECT_A\": {\n                        \"children\": [],\n                        \"name\": \"Object A\",\n                        \"color\": \"#733AFB\",\n                        \"id\": \"category1\",\n                    },\n                    \"OBJECT_B\": {\n                        \"children\": [],\n                        \"name\": \"Object B\",\n                        \"color\": \"#3CD876\",\n                        \"id\": \"category2\",\n                    },\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Categories\",\n            \"isChild\": False,\n            \"tools\": [\"rectangle\"],\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"models\": {},\n            \"isVisible\": True,\n            \"required\": 1,\n            \"isNew\": False,\n        }\n    }\n}\n</code></pre> <pre><code>title = \"[Kili SDK Notebook]: Webhooks example test project\"\ndescription = \"My first project with a webhook\"\ninput_type = \"IMAGE\"\n\nproject = kili.create_project(\n    title=title, description=description, input_type=input_type, json_interface=json_interface\n)\nproject_id = project[\"id\"]\n\nprint(f\"Created project {project_id}\")\n</code></pre> <pre><code>Created project clfcblkni05pq0jrq8wgib142\n</code></pre> <p>Upload an asset:</p> <pre><code>content_array = [\"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\"]\nnames_array = [\"car\"]\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=content_array,\n    external_id_array=names_array,\n    disable_tqdm=True,\n)\n\nasset_id = kili.assets(project_id=project_id, fields=[\"id\"], disable_tqdm=True)[0][\"id\"]\n</code></pre> <p>This project has one job of bounding box creation with two categories.</p> <p>With our plugin, we want to make sure that the labelers don't create more than one bounding box of category A.</p> <p>To iterate on the plugin code, you can refer to the plugins development tutorial.</p>"},{"location":"sdk/tutorials/webhooks_example/#step-3-write-host-the-webhook","title":"Step 3: Write &amp; host the webhook","text":"<p>The webhook rely on the same handlers provided by the plugins. For maximum compatibility, we encourage you to define it with the same base class. Below is an example with FastAPI webservice.</p> <pre><code># file plugin.py\n\"\"\"\nCustom module with basic plugin example\n\"\"\"\nfrom typing import Dict\n\nfrom kili.plugins import PluginCore\n\n\ndef check_rules_on_label(label: Dict):\n    \"\"\"\n    Custom function to check rules on label.\n    For basic rules, a handy object is `search` that \\\n        provides various analytics on objects\n    For more advanced use-cases, you might need to \\\n        fetch the complete `jsonResponse`\n    \"\"\"\n\n    issues_array = []\n    for job_dot_category, nb_of_objects in label['search']['numberOfAnnotationsByObject'].items():\n        if job_dot_category == \"JOB_0.OBJECT_A\":\n            if nb_of_objects &gt; 1:\n                issues_array.append({\n                    'text': f'There are too many BBox ({nb_of_objects}) - Only 1 BBox of Object A accepted',\n                    'mid': None}\n                )\n    return issues_array\n\n\ndef _get_area(bounding_box):\n    \"\"\"\n    Custom helper to compute size of Kili Bounding boxes\n    \"\"\"\n    x_array = [point['x'] for point in bounding_box]\n    y_array = [point['y'] for point in bounding_box]\n    width = max(x_array) - min(x_array)\n    height = max(y_array) - min(y_array)\n    return width * height\n\n\nclass PluginHandler(PluginCore):\n    \"\"\"\n    Custom plugin instance\n    \"\"\"\n\n    def check_complex_rules_on_label(self, asset_id: str):\n        \"\"\"\n        Custom method to check if a box is larger than 33% of the image\n        For basic rules, a handy object is `search` that \\\n            provides various analytics on objects\n        In this more complex use-case, we will \\\n            fetch the complete `jsonResponse`\n        \"\"\"\n        json_response = self.kili.labels(\n            asset_id=asset_id,\n            project_id=self.project_id,\n            fields=['jsonResponse'],\n            disable_tqdm=True\n        )[0]['jsonResponse']\n\n        issues_array = []\n        for annotation in json_response['JOB_0']['annotations']:\n            bounding_box = annotation['boundingPoly'][0]['normalizedVertices']\n            area = _get_area(bounding_box)\n            # Refuse bounding boxes larger than 0.33\n            if area &gt; 0.33:\n                issues_array.append({\n                    'text': 'BBox too large',\n                    'mid': annotation[\"mid\"]\n                })\n\n        return issues_array\n\n    def on_submit(self, label: Dict, asset_id: str) -&gt; None:\n        \"\"\"\n        Dedicated handler for Submit action\n        \"\"\"\n        self.logger.info(\"On submit called\")\n\n        issues_array = check_rules_on_label(label)\n\n        issues_array += self.check_complex_rules_on_label(asset_id)\n\n        project_id = self.project_id\n\n        if len(issues_array) &gt; 0:\n            print(f'Creating {len(issues_array)} issues...')\n\n            for issue in issues_array:\n                print(issue)\n\n                self.kili.create_issues(\n                    label_id_array=[label['id']],\n                    project_id=project_id,\n                    text_array=[issue['text']],\n                    object_mid_array=[issue['mid']]\n                )\n\n            self.logger.warning(\"Issue created!\")\n\n            self.kili.send_back_to_queue(asset_ids=[asset_id])\n\n        else:\n            self.logger.info('No issues encountered')\n</code></pre> <p>You will need to deploy this on your premise for this to work. Easy solutions are FastAPI, with a few lines of codes, and to quickly test your code, we recommend ngrok that allows to quickly expose your local server.</p> <p>For this demo, we will also display the use of https://webhook.site that will enable us to explore the payload of the calls.</p> <p>You can also add a custom <code>Authorization</code> header when creating the webhook in Kili, and then verify that header in your deployed webhook. As an example, you can see the <code>verify_token</code> function below.</p> <pre><code>\"\"\"\nBasic app for kili webhook\nNote: Don't host it locally, it won't work as Kili can't call your localhost\n\"\"\"\n# file main.py\nimport os\nfrom typing import Dict\nfrom fastapi import FastAPI, HTTPException, Depends, Request\nfrom kili.client import Kili\n\n# Assuming your plugin is in a file  `plugin.py` in the same folder\nfrom plugin import PluginHandler\n\napp = FastAPI()\nkili = Kili()\n\nAPI_KEY = \"secret-api-key\"\n\n# Define the token verification, here we assume we only check if the header is equal\n# to a secret value that can be hard-coded / defined from an environment variable, etc.\ndef verify_token(req: Request):\n    \"\"\"\n    Verifies the request token\n\n    Parameters\n    ----------\n    req: request\n    \"\"\"\n    print('Verifying token...')\n    token = req.headers.get('Authorization')\n    if token != API_KEY:\n        print('Token different from API_KEY...')\n        raise HTTPException(\n            status_code=401,\n            detail='Unauthorized'\n        )\n    print('Token ok.')\n    return True\n\n@app.post(\"/\")\ndef main(raw_payload: Dict, authorized: bool = Depends(verify_token)):\n    \"\"\"\n    Basic endpoint to receive kili events\n\n    Parameters\n    ----------\n    - raw_payload: webhook payload\n    - authorized: bool\n        Has the request been authorized\n    \"\"\"\n    if not authorized:\n        print('Not authorized, early return')\n        return None\n\n    event_type = raw_payload.get('eventType')\n    project_id = raw_payload.get('logPayload').get('projectId')\n\n    if not project_id:\n        print('Invalid projectId')\n        return\n\n    plugin = PluginHandler(kili, project_id)\n\n    if not event_type:\n        print('Invalid event')\n        return\n\n    payload = raw_payload.get('payload')\n    label = payload.get('label')\n    asset_id = payload.get('asset_id')\n\n    if event_type == 'onSubmit':\n        plugin.on_submit(label, asset_id)\n\n    if event_type == 'onReview':\n        plugin.on_review(label, asset_id)\n</code></pre>"},{"location":"sdk/tutorials/webhooks_example/#local-dev-webhook","title":"Local dev webhook","text":"<p>To quickly get started, setup the following folder:</p> <p><pre><code>\u251c\u2500\u2500 local_webhook\n \u00a0\u00a0 \u251c\u2500\u2500 main.py\n \u00a0\u00a0 \u2514\u2500\u2500 plugin.py\n</code></pre> with the code the code above.</p> <p>To start your fastapi app, just run <code>uvicorn main:app --reload</code> to have live reload in case your code changes.</p> <p>To start exposing your app, just run <code>ngrok http 8000</code>. You will need to register on ngrok to be able to request a public url that redirects to your computer.</p> <pre><code>Session Status                online\nAccount                       *** (Plan: Free)\nUpdate                        update available (version 2.3.41, Ctrl-U to update)\nVersion                       2.3.40\nRegion                        United States (us)\nWeb Interface                 http://127.0.0.1:4040\nForwarding                    http://your-unique-id.ngrok-free.app -&gt; http://localhost:8000\nForwarding                    https://your-unique-id.ngrok-free.app -&gt; http://localhost:8000\n\nHTTP Requests\n-------------\n\nPOST /                         200 OK\n</code></pre> <p>Then, follow the rest of the tutorial to register the webhook with the <code>https</code> url returned by <code>ngrok</code>.</p>"},{"location":"sdk/tutorials/webhooks_example/#step-4-register-activate-the-webhook","title":"Step 4: Register &amp; activate the webhook","text":"<pre><code>import requests\n\nfrom kili.exceptions import GraphQLError\n\n# we get a new webhook listener\nres = requests.post(\"https://webhook.site/token\")\nuuid = res.json()[\"uuid\"]\nwebhook_url_from_browser = f\"https://webhook.site/#!/{uuid}\"\n\nwebhook_name = \"Webhook bbox count\"\nwebhook_url = f\"https://webhook.site/{uuid}\"\nprint(webhook_url_from_browser)\n\n# The Authorization header that will be used when calling your deployed webhook\nwebhook_security_header = \"secret-api-key\"\n\ntry:\n    kili.create_webhook(\n        plugin_name=webhook_name, webhook_url=webhook_url, header=webhook_security_header\n    )\nexcept GraphQLError as error:\n    print(str(error))\n</code></pre> <pre><code>https://webhook.site/#!/f81dfe6a-****-****-****-4b6dfe4b0721\n</code></pre> <pre><code>kili.activate_plugin_on_project(plugin_name=webhook_name, project_id=project_id)\n</code></pre> <pre><code>Plugin with name \"Webhook bbox count\" activated on project \"clfcblkni05pq0jrq8wgib142\"\nINFO:kili.services.plugins:Plugin with name \"Webhook bbox count\" activated on project \"clfcblkni05pq0jrq8wgib142\"\n\n\n\n\n\n'Plugin with name Webhook bbox count successfully activated'\n</code></pre> <p>Note: Similar to plugins, you have access to the methods <code>kili.update_webhook</code> &amp; <code>kili.deactivate_plugin_on_project</code> for iterations on your code.</p>"},{"location":"sdk/tutorials/webhooks_example/#step-5-webhook-in-action","title":"Step 5: Webhook in action","text":"<p>After that, you can test it by labelling in the Kili interface or just by uploading the following label.</p> <p>When you add the label that contains errors, you will see a new issue automatically created in the Kili app, if you have deployed the webhook. Else, you can visit the webhook site to check incoming events.</p> <pre><code>json_response = {\n    \"JOB_0\": {\n        \"annotations\": [\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.15, \"y\": 0.84},\n                            {\"x\": 0.15, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.84},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161451411-13314\",\n                \"type\": \"rectangle\",\n            },\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.79, \"y\": 0.20},\n                            {\"x\": 0.79, \"y\": 0.13},\n                            {\"x\": 0.91, \"y\": 0.13},\n                            {\"x\": 0.91, \"y\": 0.20},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161456406-47055\",\n                \"type\": \"rectangle\",\n            },\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.87, \"y\": 0.36},\n                            {\"x\": 0.87, \"y\": 0.27},\n                            {\"x\": 0.99, \"y\": 0.27},\n                            {\"x\": 0.99, \"y\": 0.36},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161459298-45160\",\n                \"type\": \"rectangle\",\n            },\n        ]\n    }\n}\n</code></pre> <pre><code>kili.append_labels(\n    json_response_array=[json_response], asset_id_array=[asset_id], label_type=\"DEFAULT\"\n)\n</code></pre> <pre><code>[{'id': 'clfcblncs0h550js5golxg96s'}]\n</code></pre> <p>If you used &amp; hosted the base webhook provided, the webhook should:</p> <ul> <li>Create an issue with information that three bboxes were found, instead of one</li> <li>Create an issue with info that the first bbox is too large</li> <li>Send the asset back to the labeling queue (status <code>ONGOING</code>)</li> </ul> <p>If you haven't deployed your webhook just yet, you can still visit the address here :</p> <pre><code>print(f\"Go to my webhook: {webhook_url_from_browser}\")\ntry:\n    # If your webhook is live !\n    kili.issues(project_id=project_id, fields=[\"comments.text\", \"objectMid\"])\nexcept GraphQLError as error:\n    print(str(error))\n</code></pre> <pre><code>Go to my webhook: https://webhook.site/#!/f81dfe6a-****-****-****-4b6dfe4b0721\n</code></pre> <p>Woah! Amazing! Well done :) \ud83d\ude80</p> <p>Let's test now to post a proper label, this one for example:</p> <pre><code>json_response = {\n    \"JOB_0\": {\n        \"annotations\": [\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.15, \"y\": 0.84},\n                            {\"x\": 0.15, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.84},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161451411-13314\",\n                \"type\": \"rectangle\",\n            }\n        ]\n    }\n}\nkili.append_labels(\n    json_response_array=[json_response], asset_id_array=[asset_id], label_type=\"DEFAULT\"\n)\n\nprint(f\"Go to my webhook: {webhook_url_from_browser}\")\n</code></pre> <pre><code>Go to my webhook: https://webhook.site/#!/f81dfe6a-****-****-****-4b6dfe4b0721\n</code></pre> <p>The status of your asset should have now changed to <code>LABELED</code>. In this webhook, previous issues remain but you can solve them through the API as well.</p> <p>Well done! You can now iterate on the script. To learn how to avoid latency when building and deploying your plugin, refer to the plugins development tutorial.</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"}]}